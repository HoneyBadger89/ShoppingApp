<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#FDFCF4">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Mysa">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    <title>Mysa</title>
    <style>
        :root {
            /* NEW WARM DESIGN - Cream & Sage Theme */
            --bg-app: #FDFCF4;
            --bg-primary: #FDFCF4;
            --bg-secondary: #F5F3ED;
            --bg-card: #FFFFFF;
            --surface-card: #FFFFFF;

            /* Accent colors - Warm palette */
            --color-sage: #C4E7D6;
            --color-lavender: #E8DEF8;
            --color-peach: #FFD8CA;
            --color-slate: #303030;
            --color-blue: #D0E4FF;
            --accent-primary: #303030;
            --accent-secondary: #303030;
            --accent-success: #146C2E;
            --accent-check: #146C2E;
            --accent-danger: #B3261E;
            --accent-orange: #FF8A65;

            /* Text */
            --text-primary: #1A1C1E;
            --text-secondary: #444746;
            --text-tertiary: #747775;
            --text-muted: #747775;
            --text-on-dark: #F2F0F4;

            /* Radius - More rounded */
            --radius-xl: 28px;
            --radius-lg: 20px;
            --radius-md: 12px;
            --radius-sm: 8px;
            --radius-pill: 100px;

            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;

            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.08);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
            --shadow-float: 0 8px 24px rgba(0,0,0,0.12);

            /* Legacy support */
            --gradient-header: linear-gradient(135deg, #303030 0%, #505050 100%);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            overscroll-behavior: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-app);
            min-height: 100vh;
            color: var(--text-primary);
        }

        /* Disable text selection on UI elements */
        .nav-item, .btn, .priority-dot, .item-checkbox, .add-btn, .auth-btn {
            -webkit-user-select: none;
            user-select: none;
        }

        /* Container */
        .container {
            max-width: 480px;
            margin: 0 auto;
            min-height: 100vh;
            background: var(--bg-app);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Header - Warm minimal design */
        .header {
            background: var(--bg-app);
            padding: var(--space-lg);
            padding-top: calc(var(--space-lg) + env(safe-area-inset-top));
            color: var(--text-primary);
            position: relative;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left h1 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 2px;
            color: var(--text-primary);
        }

        .header-subtitle {
            font-size: 14px;
            color: var(--text-tertiary);
            font-weight: 500;
        }

        .share-btn {
            background: var(--surface-card);
            border: none;
            color: var(--text-secondary);
            width: 48px;
            height: 48px;
            border-radius: var(--radius-pill);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }

        .share-btn:hover {
            background: var(--bg-secondary);
            transform: scale(1.05);
        }

        .share-btn:active {
            transform: scale(0.98);
        }

        .share-btn.has-collaborators {
            background: var(--color-sage);
            color: var(--accent-check);
        }

        /* Auth Styles */
        .auth-container {
            padding: 30px 20px;
            flex: 1;
        }

        .auth-container h2 {
            text-align: center;
            margin-bottom: 25px;
            color: var(--text-primary);
            font-size: 24px;
        }

        .auth-tabs {
            display: flex;
            margin-bottom: 20px;
            gap: 10px;
        }

        .auth-tab {
            flex: 1;
            padding: 12px;
            border: none;
            background: var(--bg-secondary);
            border-radius: var(--radius-pill);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .auth-tab.active {
            background: var(--color-slate);
            color: white;
        }

        .auth-form {
            display: none;
        }

        .auth-form.active {
            display: block;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .form-group input {
            width: 100%;
            padding: 14px 16px;
            font-size: 16px;
            border: 2px solid #e5e7eb;
            border-radius: var(--radius-md);
            outline: none;
            transition: border-color 0.2s ease;
            background: var(--bg-card);
        }

        .form-group input:focus {
            border-color: var(--accent-primary);
        }

        .auth-btn {
            width: 100%;
            padding: 14px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: var(--radius-pill);
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 8px;
        }

        .auth-btn.primary {
            background: var(--color-slate);
            color: white;
        }

        .auth-btn.primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .auth-btn.google {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 2px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .auth-btn.google:hover {
            background: var(--bg-secondary);
        }

        .google-icon {
            width: 20px;
            height: 20px;
        }

        .divider {
            text-align: center;
            color: var(--text-muted);
            margin: 20px 0;
            position: relative;
        }

        .divider::before,
        .divider::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40%;
            height: 1px;
            background: #e5e7eb;
        }

        .divider::before { left: 0; }
        .divider::after { right: 0; }

        .error-message {
            background: #fef2f2;
            color: var(--accent-danger);
            padding: 12px 16px;
            border-radius: 12px;
            margin-bottom: 16px;
            font-size: 14px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        /* App Container */
        .app-container {
            display: none;
            flex: 1;
            flex-direction: column;
        }

        .app-container.active {
            display: flex;
        }

        /* Content Area */
        .content {
            flex: 1;
            padding: 16px;
            padding-bottom: calc(180px + env(safe-area-inset-bottom));
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* Pull to Refresh */
        .pull-indicator {
            height: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 14px;
            transition: opacity 0.2s ease;
            opacity: 0;
        }

        .pull-indicator.refreshing {
            height: 50px;
            opacity: 1;
        }

        .pull-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid var(--bg-secondary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Item Cards */
        .items-list {
            list-style: none;
        }

        /* Swipe Container */
        .swipe-container {
            position: relative;
            margin-bottom: 12px;
            border-radius: var(--radius-lg);
            overflow: hidden;
        }

        .swipe-reveal {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
            display: flex;
            align-items: center;
            font-size: 24px;
            color: white;
            pointer-events: none;
        }

        .swipe-reveal-complete {
            left: 0;
            background: #f0fdf4;
            color: var(--accent-success);
            padding-left: 20px;
            justify-content: flex-start;
        }

        .swipe-reveal-delete {
            right: 0;
            background: #fef2f2;
            color: var(--accent-danger);
            padding-right: 20px;
            justify-content: flex-end;
        }

        .item-card {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: 16px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            box-shadow: var(--shadow-md);
            position: relative;
            touch-action: pan-y;
            user-select: none;
            will-change: transform;
        }

        .item-card.swiping {
            transition: none !important;
        }

        .item-card.snapping {
            transition: transform 0.2s ease !important;
        }

        .item-card.deleting {
            transition: transform 0.3s ease, opacity 0.3s ease !important;
            transform: translateX(-100%) !important;
            opacity: 0 !important;
        }

        .item-card.completing-swipe {
            animation: complete-flash-swipe 0.4s ease;
        }

        @keyframes complete-flash-swipe {
            0% { background-color: var(--bg-card); }
            50% { background-color: #d1fae5; transform: scale(1.02); }
            100% { background-color: var(--bg-card); transform: scale(1); }
        }

        .item-checkbox {
            width: 24px;
            height: 24px;
            border: 2px solid #d1d5db;
            border-radius: var(--radius-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .item-checkbox:hover {
            border-color: var(--accent-success);
        }

        .item-card.done .item-checkbox {
            background: var(--color-sage);
            border-color: var(--color-sage);
            transform: scale(1.05);
        }

        .item-checkbox-icon {
            color: var(--accent-check);
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .item-card.done .item-checkbox-icon {
            opacity: 1;
        }

        /* Priority Button (right side) */
        .priority-btn {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            margin: -8px -8px -8px 0;
            flex-shrink: 0;
        }

        .priority-btn:active .priority-dot {
            transform: scale(1.3);
        }

        .priority-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            transition: transform 0.15s ease, background-color 0.2s ease;
        }

        .priority-dot.priority-high {
            background: #fca5a5;
        }

        .priority-dot.priority-medium {
            background: #fcd34d;
        }

        .priority-dot.priority-none {
            background: #e5e7eb;
        }

        /* Edit Item Modal */
        .edit-item-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 20px;
        }

        .edit-item-modal {
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            padding: 24px;
            width: 100%;
            max-width: 360px;
            box-shadow: var(--shadow-float);
        }

        .edit-modal-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .edit-modal-icon {
            font-size: 40px;
            display: block;
            margin-bottom: 8px;
        }

        .edit-modal-header h3 {
            margin: 0;
            font-size: 20px;
            color: #1f2937;
        }

        .edit-modal-field {
            margin-bottom: 20px;
        }

        .edit-modal-field label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .edit-modal-field input,
        .edit-modal-field select {
            width: 100%;
            padding: 14px 16px;
            font-size: 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            background: white;
            color: #1f2937;
            box-sizing: border-box;
        }

        .edit-modal-field input:focus,
        .edit-modal-field select:focus {
            outline: none;
            border-color: var(--color-slate);
        }

        .edit-modal-field select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236b7280' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 16px center;
            padding-right: 40px;
        }

        .edit-modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .edit-modal-buttons button {
            flex: 1;
            padding: 14px 20px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: var(--radius-pill);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .edit-modal-buttons button:active {
            transform: scale(0.98);
        }

        .edit-modal-cancel {
            background: var(--bg-secondary);
            color: var(--text-secondary);
        }

        .edit-modal-save {
            background: var(--color-slate);
            color: white;
        }

        .quantity-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .quantity-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 50%;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 24px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.1s;
        }

        .quantity-btn:active {
            transform: scale(0.95);
            background: var(--bg-tertiary);
        }

        .quantity-display {
            font-size: 24px;
            font-weight: 600;
            min-width: 40px;
            text-align: center;
            color: var(--text-primary);
        }

        .item-content {
            flex: 1;
            min-width: 0;
        }

        .item-text {
            font-size: 16px;
            font-weight: 500;
            color: var(--text-primary);
            word-break: break-word;
            transition: all 0.2s ease;
        }

        .item-card.done .item-text {
            text-decoration: line-through;
            opacity: 0.5;
        }

        .item-quantity {
            color: var(--text-muted);
            font-weight: 400;
            font-size: 14px;
            margin-left: 4px;
        }

        .item-meta {
            display: none !important; /* Hidden - cleaner look */
        }


        /* Enhanced Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            text-align: center;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .empty-state h3 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .empty-state p {
            font-size: 14px;
            color: var(--text-muted);
            max-width: 250px;
        }

        /* Loading Skeletons */
        .skeleton-container {
            display: none;
        }

        .skeleton-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: var(--bg-card);
            border-radius: 12px;
            margin-bottom: 12px;
        }

        .skeleton-checkbox {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-shimmer 1.5s infinite;
        }

        .skeleton-content {
            flex: 1;
        }

        .skeleton-title {
            height: 16px;
            width: 65%;
            border-radius: 4px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-shimmer 1.5s infinite;
            margin-bottom: 8px;
        }

        .skeleton-subtitle {
            height: 12px;
            width: 35%;
            border-radius: 4px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-shimmer 1.5s infinite;
        }

        @keyframes skeleton-shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        /* Confetti */
        .confetti-particle {
            position: fixed;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            animation: confetti-fall 0.8s ease-out forwards;
        }

        @keyframes confetti-fall {
            0% {
                transform: translate(0, 0) rotate(0deg) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--x), calc(var(--y) + 200px)) rotate(720deg) scale(0);
                opacity: 0;
            }
        }

        .loading-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }

        /* Add Input */
        .add-input-container {
            position: fixed;
            bottom: calc(96px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 32px);
            max-width: 448px;
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-float);
            display: flex;
            padding: 10px;
            gap: 10px;
            z-index: 100;
        }

        .add-input {
            flex: 1;
            border: none;
            outline: none;
            padding: 14px 18px;
            font-size: 16px;
            background: var(--bg-secondary);
            border-radius: var(--radius-pill);
        }

        .add-input::placeholder {
            color: var(--text-muted);
        }

        .add-btn {
            background: var(--color-slate);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: var(--radius-pill);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
            margin-right: 2px;
            flex-shrink: 0;
        }

        .add-btn:hover {
            opacity: 0.9;
            transform: scale(1.02);
        }

        /* Category Picker in Add Bar */
        .add-input-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            background: var(--bg-secondary);
            border-radius: var(--radius-pill);
            padding: 0 4px 0 0;
        }

        .add-input-wrapper .add-input {
            background: none;
            border-radius: 0;
        }

        .category-picker-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: white;
            border-radius: var(--radius-pill);
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-sm);
            transition: transform 0.2s;
            flex-shrink: 0;
        }

        .category-picker-btn:active {
            transform: scale(0.95);
        }

        /* Category Picker Modal */
        .add-category-picker-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            z-index: 9999;
        }

        .add-category-picker-modal {
            background: var(--bg-card);
            border-radius: var(--radius-xl) var(--radius-xl) 0 0;
            padding: 20px;
            width: 100%;
            max-width: 500px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .add-category-picker-modal h3 {
            text-align: center;
            margin: 0 0 16px 0;
            font-size: 18px;
            color: #1f2937;
        }

        .add-category-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .add-category-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
        }

        .add-category-option:active {
            background: #f3f4f6;
        }

        .add-category-option.selected {
            border-color: #8b5cf6;
            background: #f3e8ff;
        }

        .add-category-option .cat-emoji {
            font-size: 24px;
            width: 32px;
            text-align: center;
        }

        .add-category-option .cat-name {
            flex: 1;
            font-weight: 600;
            font-size: 15px;
            color: #1f2937;
        }

        .add-category-option .cat-desc {
            font-size: 12px;
            color: #6b7280;
        }

        .add-category-option .check {
            color: #8b5cf6;
            font-weight: bold;
            font-size: 18px;
        }

        .add-category-picker-modal .cancel-btn {
            width: 100%;
            margin-top: 16px;
            padding: 16px;
            border: none;
            border-radius: 12px;
            background: #f3f4f6;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        /* Task Action Menu */
        .task-action-menu-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            z-index: 9999;
        }

        .task-action-menu {
            background: white;
            border-radius: 20px 20px 0 0;
            padding: 20px;
            width: 100%;
            max-width: 500px;
        }

        .task-action-header {
            text-align: center;
            padding-bottom: 16px;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 16px;
        }

        .task-action-text {
            font-size: 16px;
            color: #374151;
            font-style: italic;
        }

        .task-action-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .task-action-btn {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px;
            border: none;
            border-radius: 12px;
            background: #f9fafb;
            cursor: pointer;
            text-align: left;
            transition: background 0.2s;
        }

        .task-action-btn:active {
            background: #f3f4f6;
        }

        .task-action-btn .action-icon {
            font-size: 24px;
        }

        .task-action-btn .action-label {
            flex: 1;
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
        }

        .task-action-btn .action-desc {
            font-size: 12px;
            color: #6b7280;
        }

        .task-action-btn.fuckit {
            background: #fef3c7;
        }

        .task-action-btn.fuckit:active {
            background: #fde68a;
        }

        .task-action-btn.delete {
            background: #fee2e2;
        }

        .task-action-btn.delete:active {
            background: #fecaca;
        }

        /* Fuck It Bucket section styling */
        .fuckit-section {
            margin-top: 24px;
            opacity: 0.85;
        }

        .fuckit-header {
            background: linear-gradient(135deg, #fef3c7, #fde68a) !important;
        }

        .fuckit-item {
            background: #fffbeb !important;
        }

        .fuckit-item .item-text {
            text-decoration: line-through;
            color: #9ca3af !important;
        }

        .restore-btn {
            background: none;
            border: none;
            font-size: 18px;
            padding: 8px;
            cursor: pointer;
        }

        /* Old task prompt */
        .old-task-prompt-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 20px;
        }

        .old-task-prompt {
            background: white;
            border-radius: 20px;
            padding: 24px;
            text-align: center;
            max-width: 340px;
            width: 100%;
        }

        .old-task-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .old-task-prompt h3 {
            margin: 0 0 16px 0;
            font-size: 20px;
        }

        .old-task-text {
            font-size: 16px;
            color: #374151;
            font-style: italic;
            margin-bottom: 8px;
        }

        .old-task-age {
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 24px;
        }

        .old-task-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .old-task-actions button {
            padding: 14px 20px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
        }

        .btn-keep {
            background: #10b981;
            color: white;
        }

        .btn-fuckit {
            background: #fef3c7;
            color: #92400e;
        }

        /* Bottom Navigation - Floating Pill Style */
        .bottom-nav {
            position: fixed;
            bottom: calc(16px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 32px);
            max-width: 400px;
            height: 64px;
            background: var(--bg-card);
            box-shadow: var(--shadow-float);
            border-radius: var(--radius-pill);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 200;
        }

        .nav-item {
            background: none;
            border: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 20px;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.2s ease;
        }

        .nav-item:active {
            opacity: 0.7;
        }

        .nav-item.active {
            color: var(--accent-primary);
        }

        /* Clear Completed Button */
        .clear-completed-btn {
            display: none;
            width: 100%;
            padding: 12px;
            margin-top: 16px;
            background: var(--bg-secondary);
            border: 1px dashed #d1d5db;
            border-radius: 12px;
            color: var(--text-muted);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .clear-completed-btn:hover {
            background: #f3f4f6;
            color: var(--text-secondary);
        }

        .clear-completed-btn.visible {
            display: block;
        }

        /* Offline Indicator */
        .offline-indicator {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #fbbf24;
            color: #78350f;
            text-align: center;
            padding: 8px;
            font-size: 13px;
            font-weight: 500;
            z-index: 9999;
            transform: translateY(-100%);
            transition: transform 0.3s ease;
        }

        .offline-indicator.visible {
            transform: translateY(0);
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: var(--text-primary);
            color: white;
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 14px;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 9999;
            pointer-events: none;
        }

        .toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .nav-icon {
            font-size: 24px;
        }

        .nav-label {
            font-size: 12px;
            font-weight: 500;
        }

        /* Profile Tab */
        .profile-content {
            padding: 20px 16px;
            padding-bottom: calc(140px + env(safe-area-inset-bottom));
            display: none;
            overflow-y: auto;
            height: 100%;
        }

        .profile-content.active {
            display: block;
        }

        .profile-header {
            text-align: center;
            padding: 20px 0 30px;
        }

        .profile-avatar {
            width: 80px;
            height: 80px;
            background: var(--gradient-header);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
            font-size: 32px;
            color: white;
        }

        .profile-email {
            font-size: 16px;
            color: var(--text-primary);
            font-weight: 500;
        }

        .profile-menu {
            list-style: none;
        }

        .profile-menu-item {
            background: var(--bg-card);
            border-radius: 12px;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .profile-menu-btn {
            width: 100%;
            padding: 16px 20px;
            background: none;
            border: none;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            font-size: 16px;
            color: var(--text-primary);
            transition: background 0.2s ease;
        }

        .profile-menu-btn:hover {
            background: var(--bg-secondary);
        }

        .profile-menu-btn.danger {
            color: var(--accent-danger);
        }

        .profile-menu-icon {
            font-size: 20px;
        }

        /* Share Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .share-modal {
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            width: 100%;
            max-width: 400px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-float);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
        }

        .invite-section {
            margin-bottom: 24px;
        }

        .invite-section label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .invite-input-group {
            display: flex;
            gap: 8px;
        }

        .invite-input-group input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: var(--radius-md);
            font-size: 16px;
            outline: none;
        }

        .invite-input-group input:focus {
            border-color: var(--accent-primary);
        }

        .invite-btn {
            background: var(--color-slate);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: var(--radius-pill);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
        }

        .invite-btn:disabled {
            opacity: 0.5;
        }

        .share-message {
            margin-top: 12px;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        .share-message.success {
            display: block;
            background: #d1fae5;
            color: #065f46;
        }

        .share-message.error {
            display: block;
            background: #fef2f2;
            color: var(--accent-danger);
        }

        .collaborators-section h3 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .collaborator-list {
            list-style: none;
        }

        .collaborator-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #f3f4f6;
        }

        .collaborator-item:last-child {
            border-bottom: none;
        }

        .collaborator-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .collaborator-avatar {
            width: 40px;
            height: 40px;
            background: var(--bg-secondary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .collaborator-email {
            font-size: 14px;
            font-weight: 500;
        }

        .collaborator-role {
            font-size: 12px;
            color: var(--text-muted);
        }

        .remove-collaborator {
            background: none;
            border: none;
            color: var(--accent-danger);
            font-size: 13px;
            cursor: pointer;
            padding: 6px 12px;
        }

        .owner-badge {
            background: var(--bg-secondary);
            color: var(--text-muted);
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 20px;
        }

        .no-collaborators {
            color: var(--text-muted);
            font-size: 14px;
            text-align: center;
            padding: 20px;
        }

        /* Hide elements based on state */
        .hidden {
            display: none !important;
        }

        /* Responsive */
        @media (max-width: 480px) {
            .invite-input-group {
                flex-direction: column;
            }

            .invite-btn {
                width: 100%;
            }
        }

        /* =====================================================
           ONBOARDING STYLES
           ===================================================== */
        .onboarding-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            z-index: 10000;
            display: none;
            flex-direction: column;
        }

        .onboarding-overlay.active {
            display: flex;
        }

        .onboarding-screen {
            flex: 1;
            display: none;
            flex-direction: column;
            padding: 40px 24px;
            padding-top: calc(60px + env(safe-area-inset-top));
            padding-bottom: calc(120px + env(safe-area-inset-bottom));
            overflow-y: auto;
        }

        .onboarding-screen.active {
            display: flex;
        }

        .onboarding-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .onboarding-icon {
            font-size: 64px;
            margin-bottom: 24px;
        }

        .onboarding-title {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 12px;
        }

        .onboarding-subtitle {
            font-size: 16px;
            color: var(--text-secondary);
            line-height: 1.5;
            max-width: 300px;
            margin: 0 auto;
        }

        .onboarding-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .onboarding-input {
            width: 100%;
            max-width: 320px;
            padding: 16px 20px;
            font-size: 18px;
            border: 2px solid #e5e7eb;
            border-radius: 16px;
            outline: none;
            text-align: center;
            transition: border-color 0.2s ease;
        }

        .onboarding-input:focus {
            border-color: var(--accent-primary);
        }

        /* Avatar Picker */
        .avatar-picker {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            max-width: 320px;
            margin: 0 auto;
        }

        .avatar-option {
            width: 64px;
            height: 64px;
            font-size: 36px;
            border: 3px solid transparent;
            border-radius: 50%;
            background: var(--bg-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .avatar-option:hover {
            transform: scale(1.1);
        }

        .avatar-option.selected {
            border-color: var(--accent-primary);
            background: #f3e8ff;
            transform: scale(1.1);
        }

        /* Personality Picker */
        .personality-options {
            width: 100%;
            max-width: 320px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .personality-option {
            padding: 16px 20px;
            border: 2px solid #e5e7eb;
            border-radius: 16px;
            background: var(--bg-card);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .personality-option:hover {
            border-color: #d1d5db;
        }

        .personality-option.selected {
            border-color: var(--accent-primary);
            background: #f3e8ff;
        }

        .personality-option-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .personality-option-desc {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Onboarding Footer */
        .onboarding-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px 24px;
            padding-bottom: calc(20px + env(safe-area-inset-bottom));
            background: var(--bg-primary);
        }

        .onboarding-btn {
            width: 100%;
            padding: 16px;
            font-size: 18px;
            font-weight: 600;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .onboarding-btn.primary {
            background: var(--gradient-header);
            color: white;
        }

        .onboarding-btn.primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .onboarding-btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .onboarding-btn.secondary {
            background: transparent;
            color: var(--text-secondary);
            margin-top: 8px;
        }

        .onboarding-progress {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 16px;
        }

        .progress-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #e5e7eb;
            transition: all 0.2s ease;
        }

        .progress-dot.active {
            background: var(--accent-primary);
            width: 24px;
            border-radius: 4px;
        }

        .progress-dot.completed {
            background: var(--accent-success);
        }

        /* =====================================================
           PERSONALITY MESSAGES FOOTER
           ===================================================== */
        .personality-footer {
            text-align: center;
            padding: 16px 20px;
            color: var(--text-muted);
            font-size: 13px;
            font-style: italic;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .personality-message {
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* =====================================================
           ENHANCED PROFILE PAGE
           ===================================================== */
        .profile-avatar-large {
            width: 100px;
            height: 100px;
            background: var(--gradient-header);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
            font-size: 48px;
            cursor: pointer;
            transition: transform 0.2s ease;
            position: relative;
        }

        .profile-avatar-large:hover {
            transform: scale(1.05);
        }

        .profile-avatar-edit {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 32px;
            height: 32px;
            background: var(--accent-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: white;
            border: 3px solid var(--bg-primary);
        }

        .profile-display-name {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .profile-section-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 24px 0 12px;
            padding-left: 4px;
        }

        /* Avatar Edit Modal */
        .avatar-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }

        .avatar-modal.active {
            display: flex;
        }

        .avatar-modal-content {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 24px;
            width: 100%;
            max-width: 340px;
        }

        .avatar-modal-title {
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 20px;
        }

        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .avatar-grid-item {
            width: 48px;
            height: 48px;
            font-size: 28px;
            border: 2px solid transparent;
            border-radius: 50%;
            background: var(--bg-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .avatar-grid-item:hover {
            transform: scale(1.1);
        }

        .avatar-grid-item.selected {
            border-color: var(--accent-primary);
            background: #f3e8ff;
        }

        /* =====================================================
           SHOPPING CATEGORIES
           ===================================================== */
        .category-section {
            margin-bottom: 12px;
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow-md);
        }

        .category-section.all-done {
            opacity: 0.6;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            background: var(--bg-secondary);
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }

        .category-header:active {
            background: #EBE9E3;
        }

        .category-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .category-emoji {
            font-size: 20px;
        }

        .category-name {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
        }

        .category-count {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .category-toggle {
            color: var(--text-muted);
            font-size: 12px;
            transition: transform 0.2s;
        }

        .category-items {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.2s ease;
        }

        .category-items.collapsed {
            max-height: 0;
            opacity: 0;
        }

        /* Shared item styles for both Tasks and Shopping - USE !important to override generic styles */
        .task-item,
        .shopping-item {
            display: flex !important;
            flex-direction: row !important;
            align-items: center !important;
            padding: 12px 16px !important;
            background: white;
            border-top: 1px solid #f3f4f6;
            gap: 12px;
            width: 100%;
            box-sizing: border-box;
        }

        .task-item:first-child,
        .shopping-item:first-child {
            border-top: none;
        }

        .task-item:active,
        .shopping-item:active {
            background: #f9fafb;
        }

        .task-item.done,
        .shopping-item.done {
            background: #fafafa;
        }

        .task-item.done .item-text,
        .shopping-item.done .item-text {
            text-decoration: line-through;
            color: #9ca3af;
        }

        .task-item > .item-checkbox,
        .shopping-item > .item-checkbox {
            width: 24px !important;
            height: 24px !important;
            min-width: 24px !important;
            border: 2px solid #d1d5db !important;
            border-radius: 50% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 14px;
            color: white;
            cursor: pointer;
            flex-shrink: 0 !important;
            margin: 0 !important;
        }

        .task-item > .item-checkbox.checked,
        .shopping-item > .item-checkbox.checked {
            background: #10b981 !important;
            border-color: #10b981 !important;
        }

        .task-item > .item-content,
        .shopping-item > .item-content {
            flex: 1 !important;
            min-width: 0 !important;
            display: flex !important;
            flex-direction: column !important;
        }

        .task-item .item-text,
        .shopping-item .item-text {
            display: block;
            font-size: 15px;
            font-weight: 500;
            color: #1f2937;
            word-break: break-word;
        }

        .task-item .item-meta,
        .shopping-item .item-meta {
            display: none !important; /* Hidden - cleaner look */
        }

        .task-item > .priority-btn,
        .shopping-item > .priority-btn {
            flex-shrink: 0 !important;
            margin-left: 0 !important;
        }

        /* Fuck It Bucket item override */
        .task-item.fuckit-item {
            background: #fefce8;
            border-top-color: #fef08a;
        }

        /* Auto-delete fade animation for completed items */
        .fading-out {
            animation: fadeOutAndSlide 1.5s ease forwards;
            pointer-events: none; /* Disable interactions except... */
        }

        .fading-out .item-checkbox {
            pointer-events: auto !important; /* Keep checkbox tappable to rescue */
            cursor: pointer !important;
        }

        @keyframes fadeOutAndSlide {
            0% {
                opacity: 1;
                transform: translateX(0);
                max-height: 100px;
            }
            70% {
                opacity: 0.4;
                transform: translateX(0);
                max-height: 100px;
            }
            100% {
                opacity: 0;
                transform: translateX(30px);
                max-height: 0;
                padding-top: 0;
                padding-bottom: 0;
                margin: 0;
                border: none;
            }
        }

        /* =====================================================
           AUTOCORRECT MODAL
           ===================================================== */
        .autocorrect-modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 20px;
        }

        .autocorrect-modal {
            background: white;
            border-radius: 20px;
            padding: 24px;
            width: 100%;
            max-width: 340px;
            animation: modalSlideUp 0.3s ease;
        }

        @keyframes modalSlideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .autocorrect-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .autocorrect-icon {
            font-size: 40px;
            display: block;
            margin-bottom: 8px;
        }

        .autocorrect-header h3 {
            margin: 0;
            font-size: 20px;
            color: var(--text-primary);
        }

        .autocorrect-suggestion {
            background: #f9fafb;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .autocorrect-suggestion .label {
            font-size: 12px;
            color: var(--text-muted);
            display: block;
            margin-bottom: 4px;
        }

        .autocorrect-suggestion .value {
            font-size: 18px;
            font-weight: 600;
        }

        .autocorrect-suggestion .original .value {
            text-decoration: line-through;
            color: var(--text-muted);
        }

        .autocorrect-suggestion .corrected .value {
            color: var(--accent-success);
        }

        .autocorrect-suggestion .arrow {
            text-align: center;
            font-size: 20px;
            color: var(--text-muted);
            margin: 8px 0;
        }

        .autocorrect-category {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #f3f4f6;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .autocorrect-category .label {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .autocorrect-category .value {
            font-size: 15px;
            font-weight: 600;
        }

        .autocorrect-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .autocorrect-actions button {
            padding: 14px 20px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-accept {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .btn-accept:active {
            transform: scale(0.98);
        }

        .btn-keep {
            background: #f3f4f6;
            color: var(--text-secondary);
        }

        /* =====================================================
           CATEGORY PICKER MODAL
           ===================================================== */
        .category-picker-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            z-index: 9999;
        }

        .category-picker-modal {
            background: white;
            border-radius: 20px 20px 0 0;
            padding: 20px;
            padding-bottom: calc(20px + env(safe-area-inset-bottom));
            width: 100%;
            max-width: 500px;
            max-height: 70vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .category-picker-modal h3 {
            text-align: center;
            margin: 0 0 16px;
            font-size: 18px;
        }

        .category-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .category-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 14px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .category-option:active {
            background: #f3f4f6;
        }

        .category-option.selected {
            border-color: var(--accent-primary);
            background: #f3e8ff;
        }

        .category-option .cat-emoji {
            font-size: 20px;
        }

        .category-option .cat-name {
            flex: 1;
            font-weight: 500;
            font-size: 14px;
        }

        .category-option .check {
            color: var(--accent-primary);
            font-weight: bold;
        }

        .cancel-btn {
            width: 100%;
            margin-top: 16px;
            padding: 16px;
            border: none;
            border-radius: 12px;
            background: #f3f4f6;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
        }

        /* Add button spinner */
        .btn-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
    </style>
</head>
<body>
    <!-- Onboarding Overlay -->
    <div class="onboarding-overlay" id="onboardingOverlay">
        <!-- Screen 1: Welcome -->
        <div class="onboarding-screen active" data-screen="1">
            <div class="onboarding-header">
                <div class="onboarding-icon">&#127968;</div>
                <h1 class="onboarding-title">Welcome to Mysa</h1>
                <p class="onboarding-subtitle">Your cozy corner for family lists. Tasks, shopping, and good vibes - all in one place.</p>
            </div>
            <div class="onboarding-content">
                <!-- Empty - just intro screen -->
            </div>
            <div class="onboarding-footer">
                <div class="onboarding-progress">
                    <div class="progress-dot active"></div>
                    <div class="progress-dot"></div>
                    <div class="progress-dot"></div>
                    <div class="progress-dot"></div>
                    <div class="progress-dot"></div>
                </div>
                <button class="onboarding-btn primary" id="onboardingNext1">Let's get started</button>
            </div>
        </div>

        <!-- Screen 2: Name -->
        <div class="onboarding-screen" data-screen="2">
            <div class="onboarding-header">
                <div class="onboarding-icon">&#128075;</div>
                <h1 class="onboarding-title">What's your name?</h1>
                <p class="onboarding-subtitle">This is how you'll appear to your family members.</p>
            </div>
            <div class="onboarding-content">
                <input type="text" class="onboarding-input" id="onboardingName" placeholder="Your name" maxlength="20" autocomplete="off">
            </div>
            <div class="onboarding-footer">
                <div class="onboarding-progress">
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot active"></div>
                    <div class="progress-dot"></div>
                    <div class="progress-dot"></div>
                    <div class="progress-dot"></div>
                </div>
                <button class="onboarding-btn primary" id="onboardingNext2" disabled>Continue</button>
                <button class="onboarding-btn secondary" id="onboardingSkip2">Skip for now</button>
            </div>
        </div>

        <!-- Screen 3: Avatar -->
        <div class="onboarding-screen" data-screen="3">
            <div class="onboarding-header">
                <div class="onboarding-icon">&#128513;</div>
                <h1 class="onboarding-title">Pick your avatar</h1>
                <p class="onboarding-subtitle">Choose an emoji that represents you!</p>
            </div>
            <div class="onboarding-content">
                <div class="avatar-picker" id="avatarPicker">
                    <div class="avatar-option" data-avatar="&#128512;">&#128512;</div>
                    <div class="avatar-option" data-avatar="&#128522;">&#128522;</div>
                    <div class="avatar-option" data-avatar="&#128526;">&#128526;</div>
                    <div class="avatar-option" data-avatar="&#129299;">&#129299;</div>
                    <div class="avatar-option" data-avatar="&#128536;">&#128536;</div>
                    <div class="avatar-option" data-avatar="&#128525;">&#128525;</div>
                    <div class="avatar-option" data-avatar="&#129303;">&#129303;</div>
                    <div class="avatar-option" data-avatar="&#128571;">&#128571;</div>
                    <div class="avatar-option" data-avatar="&#128055;">&#128055;</div>
                    <div class="avatar-option" data-avatar="&#128049;">&#128049;</div>
                    <div class="avatar-option" data-avatar="&#129412;">&#129412;</div>
                    <div class="avatar-option" data-avatar="&#128038;">&#128038;</div>
                </div>
            </div>
            <div class="onboarding-footer">
                <div class="onboarding-progress">
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot active"></div>
                    <div class="progress-dot"></div>
                    <div class="progress-dot"></div>
                </div>
                <button class="onboarding-btn primary" id="onboardingNext3">Continue</button>
                <button class="onboarding-btn secondary" id="onboardingSkip3">Skip for now</button>
            </div>
        </div>

        <!-- Screen 4: Personality -->
        <div class="onboarding-screen" data-screen="4">
            <div class="onboarding-header">
                <div class="onboarding-icon">&#127881;</div>
                <h1 class="onboarding-title">Set the vibe</h1>
                <p class="onboarding-subtitle">How playful should Mysa be?</p>
            </div>
            <div class="onboarding-content">
                <div class="personality-options" id="personalityPicker">
                    <div class="personality-option" data-personality="off">
                        <div class="personality-option-title">&#128566; Zen Mode</div>
                        <div class="personality-option-desc">Just the basics. No funny business.</div>
                    </div>
                    <div class="personality-option selected" data-personality="subtle">
                        <div class="personality-option-title">&#128578; Subtle</div>
                        <div class="personality-option-desc">Occasional encouragement and gentle humor.</div>
                    </div>
                    <div class="personality-option" data-personality="fun">
                        <div class="personality-option-title">&#129395; Full Fun</div>
                        <div class="personality-option-desc">Maximum silliness! Jokes, puns, and celebration.</div>
                    </div>
                </div>
            </div>
            <div class="onboarding-footer">
                <div class="onboarding-progress">
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot active"></div>
                    <div class="progress-dot"></div>
                </div>
                <button class="onboarding-btn primary" id="onboardingNext4">Continue</button>
            </div>
        </div>

        <!-- Screen 5: Ready -->
        <div class="onboarding-screen" data-screen="5">
            <div class="onboarding-header">
                <div class="onboarding-icon">&#127881;</div>
                <h1 class="onboarding-title">You're all set!</h1>
                <p class="onboarding-subtitle">Time to get organized. Your family is going to love this.</p>
            </div>
            <div class="onboarding-content">
                <div style="font-size: 80px; text-align: center;" id="finalAvatarPreview">&#128512;</div>
                <div style="font-size: 24px; font-weight: 600; text-align: center; margin-top: 16px;" id="finalNamePreview">Friend</div>
            </div>
            <div class="onboarding-footer">
                <div class="onboarding-progress">
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot active"></div>
                </div>
                <button class="onboarding-btn primary" id="onboardingFinish">Start using Mysa</button>
            </div>
        </div>
    </div>

    <!-- Avatar Edit Modal -->
    <div class="avatar-modal" id="avatarModal">
        <div class="avatar-modal-content">
            <h3 class="avatar-modal-title">Choose your avatar</h3>
            <div class="avatar-grid" id="avatarGrid">
                <div class="avatar-grid-item" data-avatar="&#128512;">&#128512;</div>
                <div class="avatar-grid-item" data-avatar="&#128522;">&#128522;</div>
                <div class="avatar-grid-item" data-avatar="&#128526;">&#128526;</div>
                <div class="avatar-grid-item" data-avatar="&#129299;">&#129299;</div>
                <div class="avatar-grid-item" data-avatar="&#128536;">&#128536;</div>
                <div class="avatar-grid-item" data-avatar="&#128525;">&#128525;</div>
                <div class="avatar-grid-item" data-avatar="&#129303;">&#129303;</div>
                <div class="avatar-grid-item" data-avatar="&#128571;">&#128571;</div>
                <div class="avatar-grid-item" data-avatar="&#128055;">&#128055;</div>
                <div class="avatar-grid-item" data-avatar="&#128049;">&#128049;</div>
                <div class="avatar-grid-item" data-avatar="&#129412;">&#129412;</div>
                <div class="avatar-grid-item" data-avatar="&#128038;">&#128038;</div>
                <div class="avatar-grid-item" data-avatar="&#129409;">&#129409;</div>
                <div class="avatar-grid-item" data-avatar="&#128029;">&#128029;</div>
                <div class="avatar-grid-item" data-avatar="&#127803;">&#127803;</div>
            </div>
            <button class="onboarding-btn primary" id="avatarModalClose">Done</button>
        </div>
    </div>

    <!-- Offline Indicator -->
    <div class="offline-indicator" id="offlineIndicator">You are offline</div>

    <!-- Toast Notifications -->
    <div class="toast" id="toast"></div>

    <div class="container">
        <!-- Header -->
        <div class="header" id="mainHeader">
            <div class="header-content">
                <div class="header-left">
                    <h1 id="pageTitle">Mysa</h1>
                    <div class="header-subtitle" id="headerSubtitle"></div>
                </div>
                <button class="share-btn hidden" id="shareBtn" title="Share">
                    <span>&#128101;</span>
                </button>
            </div>
        </div>

        <!-- Auth Section -->
        <div class="auth-container" id="authContainer">
            <h2>Welcome</h2>
            <div class="auth-tabs">
                <button class="auth-tab active" data-tab="login">Login</button>
                <button class="auth-tab" data-tab="signup">Sign Up</button>
            </div>

            <div class="error-message" id="authError"></div>

            <div class="auth-form active" id="loginForm">
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" id="loginEmail" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="loginPassword" placeholder="Enter your password">
                </div>
                <button class="auth-btn primary" id="loginBtn">Login</button>
            </div>

            <div class="auth-form" id="signupForm">
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" id="signupEmail" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="signupPassword" placeholder="Create a password (6+ chars)">
                </div>
                <button class="auth-btn primary" id="signupBtn">Sign Up</button>
            </div>

            <div class="divider">or</div>

            <button class="auth-btn google" id="googleBtn">
                <svg class="google-icon" viewBox="0 0 24 24">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Continue with Google
            </button>
        </div>

        <!-- App Section -->
        <div class="app-container" id="appContainer">
            <!-- Tasks/Shopping Content -->
            <div class="content" id="listContent">
                <!-- Pull to Refresh Indicator -->
                <div class="pull-indicator" id="pullIndicator">
                    <div class="pull-spinner"></div>
                </div>

                <!-- Loading Skeletons -->
                <div class="skeleton-container" id="skeletonContainer">
                    <div class="skeleton-card">
                        <div class="skeleton-checkbox"></div>
                        <div class="skeleton-content">
                            <div class="skeleton-title"></div>
                            <div class="skeleton-subtitle"></div>
                        </div>
                    </div>
                    <div class="skeleton-card">
                        <div class="skeleton-checkbox"></div>
                        <div class="skeleton-content">
                            <div class="skeleton-title"></div>
                            <div class="skeleton-subtitle"></div>
                        </div>
                    </div>
                    <div class="skeleton-card">
                        <div class="skeleton-checkbox"></div>
                        <div class="skeleton-content">
                            <div class="skeleton-title"></div>
                            <div class="skeleton-subtitle"></div>
                        </div>
                    </div>
                </div>

                <ul class="items-list" id="itemList"></ul>
            </div>

            <!-- Profile Content -->
            <div class="profile-content" id="profileContent">
                <div class="profile-header">
                    <div class="profile-avatar-large" id="profileAvatarLarge" title="Tap to change avatar">
                        <span id="profileAvatarEmoji">&#128512;</span>
                        <div class="profile-avatar-edit">&#9998;</div>
                    </div>
                    <div class="profile-display-name" id="profileDisplayName">Friend</div>
                    <div class="profile-email" id="profileEmail"></div>
                </div>

                <div class="profile-section-title">Settings</div>
                <ul class="profile-menu">
                    <li class="profile-menu-item">
                        <button class="profile-menu-btn" id="editNameBtn">
                            <span class="profile-menu-icon">&#9998;</span>
                            Edit Display Name
                        </button>
                    </li>
                    <li class="profile-menu-item">
                        <button class="profile-menu-btn" id="personalitySettingBtn">
                            <span class="profile-menu-icon">&#127881;</span>
                            <span id="personalitySettingLabel">Personality: Subtle</span>
                        </button>
                    </li>
                    <li class="profile-menu-item">
                        <button class="profile-menu-btn" id="apiKeySettingBtn">
                            <span class="profile-menu-icon">&#128273;</span>
                            <span id="apiKeySettingLabel">Claude API Key</span>
                        </button>
                    </li>
                </ul>

                <div class="profile-section-title">Lists</div>
                <ul class="profile-menu">
                    <li class="profile-menu-item">
                        <button class="profile-menu-btn" id="manageSharingBtn">
                            <span class="profile-menu-icon">&#128101;</span>
                            Manage Sharing
                        </button>
                    </li>
                    <li class="profile-menu-item">
                        <button class="profile-menu-btn" id="clearAllCompletedBtn">
                            <span class="profile-menu-icon">&#128465;</span>
                            Clear All Completed
                        </button>
                    </li>
                </ul>

                <div class="profile-section-title">Account</div>
                <ul class="profile-menu">
                    <li class="profile-menu-item">
                        <button class="profile-menu-btn danger" id="logoutBtn">
                            <span class="profile-menu-icon">&#128682;</span>
                            Logout
                        </button>
                    </li>
                </ul>

                <div class="personality-footer" id="personalityFooter">
                    <!-- Rotating funny messages will appear here -->
                </div>

                <div class="profile-version" style="text-align: center; padding: 10px 20px; color: #9ca3af; font-size: 12px;">
                    <div id="appVersionDisplay">Mysa v5.2.1</div>
                    <div style="margin-top: 4px;">Made with &#10084;&#65039;</div>
                </div>
            </div>

            <!-- Add Input (floating) -->
            <div class="add-input-container" id="addInputContainer">
                <div class="add-input-wrapper" id="addInputWrapper">
                    <input type="text" class="add-input" id="itemInput" placeholder="Add a task...">
                    <button class="category-picker-btn" id="taskCategoryPickerBtn" onclick="showTaskCategoryPicker()" style="display: flex;">
                        <span id="selectedTaskCategoryEmoji"></span>
                    </button>
                    <button class="category-picker-btn" id="categoryPickerBtn" onclick="showAddCategoryPicker()" style="display: none;">
                        <span id="selectedCategoryEmoji"></span>
                    </button>
                </div>
                <button class="add-btn" id="addBtn">Add</button>
            </div>

            <!-- Bottom Navigation -->
            <nav class="bottom-nav">
                <button data-tab="tasks" class="nav-item active">
                    <span class="nav-icon">&#128203;</span>
                    <span class="nav-label">Tasks</span>
                </button>
                <button data-tab="shopping" class="nav-item">
                    <span class="nav-icon">&#128722;</span>
                    <span class="nav-label">Shopping</span>
                </button>
                <button data-tab="profile" class="nav-item">
                    <span class="nav-icon">&#128100;</span>
                    <span class="nav-label">Profile</span>
                </button>
            </nav>
        </div>
    </div>

    <!-- Edit Item Modal -->
    <div class="edit-item-modal-overlay" id="editItemModal" style="display: none;">
        <div class="edit-item-modal">
            <div class="edit-modal-header">
                <span class="edit-modal-icon"></span>
                <h3>Edit Item</h3>
            </div>

            <div class="edit-modal-field">
                <label for="editItemText">Item name:</label>
                <input type="text" id="editItemText" placeholder="Enter item name" />
            </div>

            <div class="edit-modal-field">
                <label for="editItemCategory">Category:</label>
                <select id="editItemCategory">
                    <option value="produce"> Produce</option>
                    <option value="dairy_eggs"> Dairy & Eggs</option>
                    <option value="meat_seafood"> Meat & Seafood</option>
                    <option value="bakery"> Bakery & Bread</option>
                    <option value="pantry"> Pantry Staples</option>
                    <option value="frozen"> Frozen</option>
                    <option value="beverages"> Beverages</option>
                    <option value="snacks"> Snacks</option>
                    <option value="household"> Household</option>
                    <option value="personal_care"> Personal Care</option>
                    <option value="baby"> Baby</option>
                    <option value="pet"> Pet</option>
                    <option value="other"> Other</option>
                </select>
            </div>

            <div class="edit-modal-field">
                <label>Quantity:</label>
                <div class="quantity-controls">
                    <button type="button" class="quantity-btn" onclick="adjustEditQuantity(-1)"></button>
                    <span id="editItemQuantity" class="quantity-display">1</span>
                    <button type="button" class="quantity-btn" onclick="adjustEditQuantity(1)">+</button>
                </div>
            </div>

            <div class="edit-modal-buttons">
                <button class="edit-modal-cancel" onclick="closeEditItemModal()">Cancel</button>
                <button class="edit-modal-save" onclick="saveEditedItem()">Save</button>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div class="modal-overlay" id="shareModal">
        <div class="share-modal">
            <div class="modal-header">
                <h2>Household</h2>
                <button class="modal-close" id="modalClose">&times;</button>
            </div>
            <div class="modal-body">
                <div class="invite-section" id="inviteSection">
                    <label>Invite family member</label>
                    <div class="invite-input-group">
                        <input type="email" id="inviteEmail" placeholder="Enter email address">
                        <button class="invite-btn" id="inviteBtn">Invite</button>
                    </div>
                    <div class="share-message" id="shareMessage"></div>
                </div>
                <div class="collaborators-section">
                    <h3>Household Members</h3>
                    <ul class="collaborator-list" id="collaboratorList">
                        <li class="no-collaborators">Just you for now</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBpibQqkud3uVUuG2AXabVhzot64h35Qr0",
            authDomain: "shoppingapp-f08f4.firebaseapp.com",
            projectId: "shoppingapp-f08f4",
            storageBucket: "shoppingapp-f08f4.firebasestorage.app",
            messagingSenderId: "54382196312",
            appId: "1:54382196312:web:b46aa2e5648a816783554d"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        // App Version
        const APP_VERSION = '5.2.1';
        console.log(`[App] Mysa Version ${APP_VERSION} - Clean Household Model`);

        // Update version display in profile
        const versionEl = document.getElementById('appVersionDisplay');
        if (versionEl) versionEl.textContent = `Mysa v${APP_VERSION}`;

        // =====================================================
        // CLAUDE API CONFIGURATION
        // =====================================================
        const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';
        const CLAUDE_MODEL = 'claude-3-haiku-20240307';

        // Get/Set Claude API Key from localStorage
        function getClaudeApiKey() {
            return localStorage.getItem('claudeApiKey') || '';
        }
        function setClaudeApiKey(key) {
            localStorage.setItem('claudeApiKey', key);
        }

        // User preferences cache (for category corrections)
        const userCategoryPrefs = JSON.parse(localStorage.getItem('userCategoryPrefs') || '{}');
        function saveUserCategoryPrefs() {
            localStorage.setItem('userCategoryPrefs', JSON.stringify(userCategoryPrefs));
        }

        // =====================================================
        // SHOPPING CATEGORIES
        // =====================================================
        const SHOPPING_CATEGORIES = [
            { id: 'produce', name: 'Produce', emoji: '' },
            { id: 'dairy_eggs', name: 'Dairy & Eggs', emoji: '' },
            { id: 'meat_seafood', name: 'Meat & Seafood', emoji: '' },
            { id: 'bakery', name: 'Bakery & Bread', emoji: '' },
            { id: 'pantry', name: 'Pantry Staples', emoji: '' },
            { id: 'frozen', name: 'Frozen', emoji: '' },
            { id: 'beverages', name: 'Beverages', emoji: '' },
            { id: 'snacks', name: 'Snacks', emoji: '' },
            { id: 'household', name: 'Household', emoji: '' },
            { id: 'personal_care', name: 'Personal Care', emoji: '' },
            { id: 'baby', name: 'Baby', emoji: '' },
            { id: 'pet', name: 'Pet', emoji: '' },
            { id: 'other', name: 'Other', emoji: '' }
        ];

        // =====================================================
        // TASK CATEGORIES
        // =====================================================
        const TASK_CATEGORIES = [
            { id: 'home', name: 'Home', emoji: '' },
            { id: 'kids', name: 'Kids', emoji: '' },
            { id: 'projects', name: 'Projects', emoji: '' },
            { id: 'calls_bookings', name: 'Calls & Bookings', emoji: '' },
            { id: 'other', name: 'Other', emoji: '' },
            { id: 'fuckit', name: 'Fuck It Bucket', emoji: '' }
        ];

        const CATEGORY_KEYWORDS = {
            produce: [
                'apple', 'apples', 'banana', 'bananas', 'orange', 'oranges', 'lemon', 'lemons', 'lime', 'limes',
                'grape', 'grapes', 'strawberry', 'strawberries', 'blueberry', 'blueberries', 'raspberry', 'raspberries',
                'mango', 'mangoes', 'pineapple', 'watermelon', 'melon', 'peach', 'peaches', 'pear', 'pears', 'plum', 'plums',
                'avocado', 'avocados', 'tomato', 'tomatoes', 'potato', 'potatoes', 'onion', 'onions', 'garlic',
                'carrot', 'carrots', 'broccoli', 'cauliflower', 'spinach', 'lettuce', 'kale', 'cabbage',
                'cucumber', 'cucumbers', 'pepper', 'peppers', 'bell pepper', 'jalapeno', 'celery', 'corn',
                'mushroom', 'mushrooms', 'zucchini', 'squash', 'eggplant', 'asparagus', 'green beans',
                'salad', 'herbs', 'basil', 'cilantro', 'parsley', 'mint', 'ginger', 'beet', 'beets',
                'sweet potato', 'yam', 'radish', 'turnip', 'artichoke', 'leek', 'scallion', 'shallot',
                'fruit', 'fruits', 'vegetable', 'vegetables', 'veggies', 'greens', 'pomelo', 'clementine', 'tangerine'
            ],
            dairy_eggs: [
                'milk', 'eggs', 'egg', 'cheese', 'butter', 'yogurt', 'yoghurt', 'cream', 'sour cream',
                'cream cheese', 'cottage cheese', 'mozzarella', 'cheddar', 'parmesan', 'feta', 'brie',
                'half and half', 'half & half', 'whipping cream', 'heavy cream', 'oat milk', 'almond milk',
                'soy milk', 'coconut milk', 'lactose free', 'dairy', 'creamer', 'ghee', 'margarine'
            ],
            meat_seafood: [
                'chicken', 'beef', 'pork', 'steak', 'ground beef', 'ground turkey', 'turkey', 'lamb',
                'bacon', 'ham', 'sausage', 'sausages', 'hot dog', 'hot dogs', 'salami', 'pepperoni',
                'fish', 'salmon', 'tuna', 'shrimp', 'prawns', 'crab', 'lobster', 'scallops', 'mussels',
                'tilapia', 'cod', 'halibut', 'trout', 'sardines', 'anchovies', 'seafood',
                'ribs', 'roast', 'chops', 'tenderloin', 'brisket', 'wings', 'thighs', 'drumsticks',
                'deli meat', 'lunch meat', 'meat', 'poultry'
            ],
            bakery: [
                'bread', 'bagel', 'bagels', 'muffin', 'muffins', 'croissant', 'croissants', 'donut', 'donuts',
                'roll', 'rolls', 'bun', 'buns', 'tortilla', 'tortillas', 'pita', 'naan', 'baguette',
                'english muffin', 'ciabatta', 'sourdough', 'whole wheat', 'white bread', 'rye bread',
                'cake', 'cupcake', 'pie', 'pastry', 'pastries', 'danish', 'scone', 'biscuit', 'biscuits',
                'brownies', 'brioche'
            ],
            pantry: [
                'rice', 'pasta', 'spaghetti', 'noodles', 'macaroni', 'penne', 'linguine', 'fettuccine',
                'cereal', 'oatmeal', 'oats', 'granola', 'flour', 'sugar', 'salt',
                'oil', 'olive oil', 'vegetable oil', 'coconut oil', 'vinegar', 'balsamic',
                'canned', 'beans', 'black beans', 'kidney beans', 'chickpeas', 'lentils',
                'tomato sauce', 'pasta sauce', 'marinara', 'salsa', 'ketchup', 'mustard', 'mayo', 'mayonnaise',
                'soy sauce', 'hot sauce', 'bbq sauce', 'honey', 'maple syrup', 'jam', 'jelly', 'peanut butter',
                'nutella', 'almond butter', 'broth', 'stock', 'soup', 'canned soup',
                'tuna can', 'canned tuna', 'canned chicken', 'spam',
                'spice', 'spices', 'seasoning', 'cinnamon', 'cumin', 'paprika', 'oregano', 'thyme',
                'baking soda', 'baking powder', 'yeast', 'vanilla', 'cocoa', 'chocolate chips',
                'quinoa', 'couscous', 'barley', 'breadcrumbs', 'croutons', 'stuffing'
            ],
            frozen: [
                'frozen', 'ice cream', 'gelato', 'sorbet', 'popsicle', 'frozen pizza', 'pizza rolls',
                'frozen vegetables', 'frozen fruit', 'frozen berries', 'frozen dinner', 'tv dinner',
                'frozen chicken', 'frozen fish', 'fish sticks', 'chicken nuggets', 'frozen fries',
                'waffles', 'frozen waffles', 'frozen breakfast', 'burritos', 'frozen burritos',
                'ice', 'ice cubes', 'peas frozen', 'corn frozen', 'edamame'
            ],
            beverages: [
                'water', 'sparkling water', 'soda', 'coke', 'pepsi', 'sprite', 'fanta',
                'juice', 'orange juice', 'apple juice', 'grape juice', 'cranberry juice',
                'coffee', 'tea', 'green tea', 'black tea', 'herbal tea', 'iced tea',
                'energy drink', 'red bull', 'monster', 'gatorade', 'powerade', 'sports drink',
                'beer', 'wine', 'liquor', 'vodka', 'whiskey', 'rum', 'gin', 'tequila',
                'lemonade', 'smoothie', 'kombucha', 'coconut water', 'tonic water',
                'drink', 'drinks', 'beverage', 'beverages', 'seltzer', 'la croix'
            ],
            snacks: [
                'chips', 'crisps', 'pretzels', 'popcorn', 'crackers', 'goldfish',
                'nuts', 'almonds', 'peanuts', 'cashews', 'walnuts', 'pistachios', 'trail mix',
                'chocolate', 'candy', 'gummy', 'gummies', 'm&ms', 'skittles', 'twix', 'snickers',
                'granola bar', 'protein bar', 'energy bar', 'cliff bar', 'kind bar',
                'cookies', 'oreos', 'chips ahoy', 'fruit snacks', 'dried fruit', 'jerky', 'beef jerky',
                'cheese puffs', 'cheetos', 'doritos', 'lays', 'pringles', 'ruffles', 'tostitos',
                'dip', 'hummus', 'guacamole', 'snack', 'snacks', 'munchies'
            ],
            household: [
                'paper towel', 'paper towels', 'toilet paper', 'tissues', 'kleenex', 'napkins',
                'trash bags', 'garbage bags', 'ziploc', 'plastic wrap', 'aluminum foil', 'foil',
                'dish soap', 'dishwasher', 'detergent', 'laundry detergent', 'tide', 'tide pods',
                'fabric softener', 'dryer sheets', 'bleach', 'cleaner', 'cleaning', 'wipes', 'clorox',
                'sponge', 'sponges', 'scrubber', 'mop', 'broom', 'dustpan',
                'light bulb', 'batteries', 'aa batteries', 'aaa batteries',
                'candle', 'candles', 'air freshener', 'febreze',
                'household', 'cleaning supplies', 'laundry', 'lysol', 'windex', 'pledge'
            ],
            personal_care: [
                'shampoo', 'conditioner', 'body wash', 'soap', 'bar soap', 'hand soap',
                'toothpaste', 'toothbrush', 'mouthwash', 'floss', 'dental',
                'deodorant', 'antiperspirant', 'lotion', 'moisturizer', 'sunscreen', 'sunblock',
                'razor', 'razors', 'shaving cream', 'aftershave',
                'makeup', 'mascara', 'lipstick', 'foundation', 'concealer', 'eyeliner',
                'hair gel', 'hair spray', 'mousse', 'hair dye',
                'cotton balls', 'cotton swabs', 'q-tips', 'band-aid', 'bandages', 'first aid',
                'medicine', 'advil', 'tylenol', 'ibuprofen', 'aspirin', 'vitamins', 'supplements',
                'tampons', 'pads', 'feminine', 'personal care', 'hygiene'
            ],
            baby: [
                'diaper', 'diapers', 'baby wipes', 'baby food', 'formula', 'baby formula',
                'baby cereal', 'baby snacks', 'baby bottle', 'pacifier', 'sippy cup',
                'baby shampoo', 'baby lotion', 'baby powder', 'diaper cream', 'rash cream',
                'baby', 'infant', 'toddler', 'newborn', 'nursing', 'breast pump'
            ],
            pet: [
                'dog food', 'cat food', 'pet food', 'kibble', 'wet food',
                'dog treats', 'cat treats', 'pet treats', 'milk bone',
                'cat litter', 'litter', 'kitty litter',
                'dog toy', 'cat toy', 'pet toy', 'chew toy',
                'leash', 'collar', 'pet bed', 'dog bed', 'cat bed',
                'flea', 'tick', 'heartworm', 'pet shampoo',
                'pet', 'puppy', 'kitten', 'fish food', 'bird food'
            ]
        };

        // Category cache for AI results
        const categoryCache = {};

        // Load category cache from localStorage
        function loadCategoryCache() {
            try {
                const cached = localStorage.getItem('categoryCache');
                if (cached) {
                    Object.assign(categoryCache, JSON.parse(cached));
                    console.log('[Category] Loaded cache with', Object.keys(categoryCache).length, 'items');
                }
            } catch (e) {
                console.error('[Category] Error loading cache:', e);
            }
        }

        // Save category cache to localStorage
        function saveCategoryCache() {
            try {
                localStorage.setItem('categoryCache', JSON.stringify(categoryCache));
            } catch (e) {
                console.error('[Category] Error saving cache:', e);
            }
        }

        // Keyword matching
        function matchKeywords(text) {
            const normalized = text.toLowerCase().trim();
            for (const [category, keywords] of Object.entries(CATEGORY_KEYWORDS)) {
                for (const keyword of keywords) {
                    // Exact match or contains
                    if (normalized === keyword || normalized.includes(keyword) || keyword.includes(normalized)) {
                        return category;
                    }
                }
            }
            return null;
        }


        // AI categorization with spelling correction (Claude Haiku)
        async function callClaudeForCategorization(itemText) {
            console.log(`[AI] Calling Claude for: "${itemText}"`);

            const apiKey = getClaudeApiKey();
            if (!apiKey) {
                console.log('[AI] No API key configured, using fallback');
                return null;
            }

            const categoryList = SHOPPING_CATEGORIES.map(c => `${c.id} (${c.name})`).join(', ');

            try {
                const response = await fetch(CLAUDE_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: CLAUDE_MODEL,
                        max_tokens: 200,
                        messages: [{
                            role: 'user',
                            content: `You are a multilingual grocery shopping assistant. You understand ALL languages including Danish, Norwegian, Swedish, German, Spanish, French, and more.

Item entered by user: "${itemText}"

IMPORTANT: Users may enter items in ANY language. Recognize the language and categorize correctly.

Common Danish examples:
- "mlk" = milk = dairy_eggs
- "g" = eggs = dairy_eggs
- "brd" = bread = bakery
- "kylling" = chicken = meat_seafood
- "ost" = cheese = dairy_eggs
- "smr" = butter = dairy_eggs
- "frugt" = fruit = produce
- "grntsager" = vegetables = produce
- "kaffe" = coffee = beverages
- "te" = tea = beverages
- "l" = beer = beverages
- "vin" = wine = beverages
- "slik" = candy = snacks
- "chips" = chips = snacks
- "rengring" = cleaning = household
- "Ovnrens" = oven cleaner = household
- "Glas keramisk" = glass ceramic cleaner = household
- "Glad keramisk" = ceramic cleaner = household
- "Vel ultra" = dish soap = household
- "Ajax" = cleaning product = household
- "Zewa" = paper towels = household
- "toiletpapir" = toilet paper = household
- "shampoo" = shampoo = personal_care
- "tandpasta" = toothpaste = personal_care
- "bleer" = diapers = baby
- "hundemad" = dog food = pet
- "kattemad" = cat food = pet

Tasks:
1. Identify the language (might be English, Danish, or any other)
2. Understand what the item is
3. Check spelling in the ORIGINAL language. If misspelled, correct it in the same language.
4. Categorize into ONE of: ${categoryList}
5. Detect priority from context:
   - "high" if user says: urgent, important, asap, critical, must have, need now, "!" at end
   - "medium" if user implies moderate importance
   - "none" for normal items (DEFAULT - use this if unsure)
   - IMPORTANT: "urgent care" is a PLACE, not priority. Context matters!
6. Remove priority words from corrected text (e.g., "milk urgent"  corrected: "milk")
7. Rate confidence: high, medium, or low

Respond ONLY with valid JSON:
{
  "original": "${itemText}",
  "corrected": "item name only, priority words removed, spelling fixed",
  "category": "category_id",
  "priority": "high/medium/none",
  "confidence": "high/medium/low"
}`
                        }]
                    })
                });

                if (!response.ok) {
                    console.error('[AI] API error:', response.status);
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();
                const content = data.content[0].text;

                // Parse JSON from response
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);
                    // Validate category
                    if (!SHOPPING_CATEGORIES.find(c => c.id === result.category)) {
                        result.category = 'other';
                    }
                    // Validate priority (default to none if invalid)
                    if (!['high', 'medium', 'none'].includes(result.priority)) {
                        result.priority = 'none';
                    }
                    console.log('[AI] Result:', result);
                    return result;
                }

                throw new Error('No JSON in response');

            } catch (error) {
                console.error('[AI] Error:', error);
                return {
                    original: itemText,
                    corrected: itemText,
                    category: 'other',
                    priority: 'none',
                    confidence: 'low'
                };
            }
        }

        // Smart categorization with user preferences and caching
        async function smartCategorize(itemText) {
            const normalized = itemText.toLowerCase().trim();

            // 1. FIRST: Check for priority words - if present, skip ALL caches and use AI
            const priorityWords = ['urgent', 'important', 'asap', 'critical', 'must have', 'need now'];
            const hasPriority = priorityWords.some(word => normalized.includes(word)) || itemText.trim().endsWith('!');

            if (hasPriority) {
                console.log(`[AI] Priority words detected in "${itemText}" - forcing AI call (skipping all caches)`);
                // Go directly to AI - skip user prefs and cache
                if (navigator.onLine) {
                    const result = await callClaudeForCategorization(itemText);
                    result.source = 'ai';
                    // Don't cache priority items - they should always be processed fresh
                    return result;
                }
                // Offline fallback for priority items
                return {
                    original: itemText,
                    corrected: itemText,
                    category: 'other',
                    priority: 'high', // Assume high if they used priority words
                    confidence: 'low',
                    source: 'fallback'
                };
            }

            // 2. Check user preferences (only for non-priority items)
            if (userCategoryPrefs[normalized]) {
                console.log(`[AI] User preference hit: "${itemText}"  ${userCategoryPrefs[normalized].category}`);
                return {
                    original: itemText,
                    corrected: userCategoryPrefs[normalized].corrected || itemText,
                    category: userCategoryPrefs[normalized].category,
                    priority: userCategoryPrefs[normalized].priority || 'none',
                    confidence: 'high',
                    source: 'user_preference'
                };
            }

            // 3. Check AI cache (only for non-priority items)
            if (categoryCache[normalized] && typeof categoryCache[normalized] === 'object') {
                console.log(`[AI] Cache hit: "${itemText}"  ${categoryCache[normalized].category}`);
                return { ...categoryCache[normalized], source: 'cache' };
            }

            // 4. Try keyword matching for known items
            const keywordMatch = matchKeywords(normalized);
            if (keywordMatch) {
                console.log(`[AI] Keyword match: "${itemText}"  ${keywordMatch}`);
                const result = {
                    original: itemText,
                    corrected: itemText,
                    category: keywordMatch,
                    priority: 'none',
                    confidence: 'high',
                    source: 'keyword'
                };
                categoryCache[normalized] = result;
                saveCategoryCache();
                return result;
            }

            // 5. Call AI for unknown items
            if (navigator.onLine) {
                const result = await callClaudeForCategorization(itemText);
                result.source = 'ai';
                categoryCache[normalized] = result;
                saveCategoryCache();
                return result;
            }

            // 5. Offline fallback
            return {
                original: itemText,
                corrected: itemText,
                category: 'other',
                priority: 'none',
                confidence: 'low',
                source: 'fallback'
            };
        }

        // Legacy function for compatibility
        async function categorizeItem(itemText) {
            const result = await smartCategorize(itemText);
            return result.category;
        }

        // =====================================================
        // TASK AI CATEGORIZATION
        // =====================================================
        const taskCategoryCache = JSON.parse(localStorage.getItem('taskCategoryCache') || '{}');

        function saveTaskCategoryCache() {
            localStorage.setItem('taskCategoryCache', JSON.stringify(taskCategoryCache));
        }

        // AI categorization for tasks (category + priority detection)
        async function callClaudeForTaskCategorization(taskText) {
            console.log(`[AI-Task] Calling Claude for: "${taskText}"`);

            const apiKey = getClaudeApiKey();
            if (!apiKey) {
                console.log('[AI-Task] No API key configured, using fallback');
                return null;
            }

            const categoryList = TASK_CATEGORIES
                .filter(c => c.id !== 'fuckit') // Never auto-assign to fuckit
                .map(c => `${c.id} (${c.name})`).join(', ');

            try {
                const response = await fetch(CLAUDE_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: CLAUDE_MODEL,
                        max_tokens: 150,
                        messages: [{
                            role: 'user',
                            content: `You are a task categorization assistant. Categorize this task and detect priority.

Task entered: "${taskText}"

Categories (pick ONE):
- home: Household chores, repairs, maintenance, cleaning, yard work (fix lights, mow lawn, clean garage)
- kids: Children-related tasks, school, activities, childcare (school pickup, homework help, pediatrician)
- projects: DIY projects, building, renovating, creative work (build shelf, paint room, assemble furniture)
- calls_bookings: Phone calls, appointments, reservations, bookings (call mom, doctor appointment, dentist, book hotel)
- other: Anything that doesn't fit above

NEVER use "fuckit" - that's user-controlled only.

Priority detection:
- "high" if user says: urgent, important, asap, critical, "!" at end
- "none" for normal tasks (DEFAULT - use this if unsure)
- IMPORTANT: "urgent care" is a medical facility, NOT a priority indicator!

Remove priority words from the task text in your response.

Respond ONLY with valid JSON:
{
  "text": "task text with priority words removed",
  "category": "category_id",
  "priority": "high/medium/none",
  "confidence": "high/medium/low"
}`
                        }]
                    })
                });

                if (!response.ok) {
                    console.error('[AI-Task] API error:', response.status);
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();
                const content = data.content[0].text;

                // Parse JSON from response
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);
                    // Validate category
                    const validCategories = TASK_CATEGORIES.filter(c => c.id !== 'fuckit').map(c => c.id);
                    if (!validCategories.includes(result.category)) {
                        result.category = 'other';
                    }
                    // Validate priority
                    if (!['high', 'medium', 'none'].includes(result.priority)) {
                        result.priority = 'none';
                    }
                    console.log('[AI-Task] Result:', result);
                    return result;
                }

                throw new Error('No JSON in response');

            } catch (error) {
                console.error('[AI-Task] Error:', error);
                return {
                    text: taskText,
                    category: 'other',
                    priority: 'none',
                    confidence: 'low'
                };
            }
        }

        // Smart task categorization with caching
        async function smartCategorizeTask(taskText) {
            const normalized = taskText.toLowerCase().trim();

            // 1. Check cache
            if (taskCategoryCache[normalized]) {
                console.log(`[AI-Task] Cache hit: "${taskText}"  ${taskCategoryCache[normalized].category}`);
                return { ...taskCategoryCache[normalized], source: 'cache' };
            }

            // 2. Call AI for categorization
            if (navigator.onLine) {
                const result = await callClaudeForTaskCategorization(taskText);
                if (result) {
                    result.source = 'ai';
                    taskCategoryCache[normalized] = result;
                    saveTaskCategoryCache();
                    return result;
                }
            }

            // 3. Fallback (no API key or offline)
            return {
                text: taskText,
                category: 'other',
                priority: 'none',
                confidence: 'low',
                source: 'fallback'
            };
        }

        // =====================================================
        // TEXT NORMALIZATION (Capitalize first letter, lowercase rest)
        // =====================================================
        function normalizeItemText(text) {
            const trimmed = text.trim();
            if (!trimmed) return trimmed;
            // "MILK"  "Milk", "milk"  "Milk", "MiLk"  "Milk"
            return trimmed.charAt(0).toUpperCase() + trimmed.slice(1).toLowerCase();
        }

        // =====================================================
        // QUANTITY PARSING (Shopping only, client-side)
        // =====================================================
        function parseQuantity(text) {
            // Returns { text: "cleaned text", quantity: number }
            // Patterns: "milk x2", "milk x 2", "milk 2", "2 milk", "2x milk", "3 bananas"

            let cleanText = text.trim();
            let quantity = 1;

            // Pattern 1: Suffix - "milk x2", "milk x 2", "milk 2"
            const suffixMatch = cleanText.match(/^(.+?)\s*[x]\s*(\d+)$/i);
            if (suffixMatch) {
                cleanText = suffixMatch[1].trim();
                quantity = parseInt(suffixMatch[2], 10);
                console.log(`[Quantity] Suffix pattern: "${text}"  "${cleanText}"  ${quantity}`);
                return { text: cleanText, quantity };
            }

            // Pattern 2: Prefix - "2 milk", "2x milk", "3 bananas"
            const prefixMatch = cleanText.match(/^(\d+)\s*[x]?\s+(.+)$/i);
            if (prefixMatch) {
                quantity = parseInt(prefixMatch[1], 10);
                cleanText = prefixMatch[2].trim();
                console.log(`[Quantity] Prefix pattern: "${text}"  "${cleanText}"  ${quantity}`);
                return { text: cleanText, quantity };
            }

            // No quantity pattern found
            return { text: cleanText, quantity: 1 };
        }

        // Collapsed sections state
        function getCollapsedSections() {
            try {
                return JSON.parse(localStorage.getItem('collapsedSections') || '{}');
            } catch (e) {
                return {};
            }
        }

        function setCollapsedSections(sections) {
            localStorage.setItem('collapsedSections', JSON.stringify(sections));
        }

        function toggleSection(categoryId) {
            const sections = getCollapsedSections();
            sections[categoryId] = !sections[categoryId];
            setCollapsedSections(sections);

            const section = document.querySelector(`[data-category="${categoryId}"]`);
            if (!section) return;

            const items = section.querySelector('.category-items');
            const toggle = section.querySelector('.category-toggle');

            if (sections[categoryId]) {
                items.classList.add('collapsed');
                toggle.textContent = '';
            } else {
                items.classList.remove('collapsed');
                toggle.textContent = '';
            }
        }

        // Initialize category cache on load
        loadCategoryCache();

        // =====================================================
        // USER PROFILE STATE
        // =====================================================
        let userProfile = {
            displayName: '',
            avatar: '&#128512;',
            personality: 'subtle' // 'off', 'subtle', 'fun'
        };

        // =====================================================
        // PERSONALITY MESSAGES (50+ messages)
        // =====================================================
        const PERSONALITY_MESSAGES = {
            subtle: [
                "You're doing great today!",
                "One task at a time...",
                "Progress, not perfection",
                "Small steps, big results",
                "You've got this!",
                "Keep up the momentum",
                "Every checkmark counts",
                "Steady wins the race",
                "Making it happen!",
                "Look at you go!",
                "Crushing it quietly",
                "Organized and thriving",
                "Today is your day",
                "Making progress!",
                "Step by step..."
            ],
            fun: [
                "Your list is judging you... kindly!",
                "Plot twist: You're the main character!",
                "This list won't complete itself... or will it?",
                "Pro tip: Checking things off feels AMAZING",
                "Your future self thanks you!",
                "Is it a list? Is it a lifestyle? Yes!",
                "Groceries fear you!",
                "Tasks tremble at your approach!",
                "Level up! Adulting unlocked!",
                "Achievement: Actually using a list app",
                "You're basically a productivity ninja",
                "Legend has it, this list gets done",
                "Breaking news: You're crushing it!",
                "Studies show: You're awesome",
                "This list is 100% organic, free-range tasks",
                "Warning: Productivity levels off the charts!",
                "Certified list-making professional",
                "Plot armor: ACTIVATED",
                "Mood: Unstoppable",
                "Your shopping cart called. It believes in you.",
                "Tasks? More like suggestions you'll destroy!",
                "Running errands like a boss!",
                "Somewhere, Marie Kondo is smiling",
                "This list sparks joy!",
                "Error 404: Laziness not found",
                "Loading motivation... 100% complete!",
                "Buffering... just kidding, let's GO!",
                "Today's vibe: Getting stuff DONE",
                "Spoiler: You finish everything",
                "Queue dramatic productivity music",
                "Permission granted to feel proud",
                "Official excuse to buy snacks",
                "Shopping: It's basically self-care",
                "List status: Looking good!",
                "Your dedication is showing!",
                "The milk will remember this kindness"
            ]
        };

        function getPersonalityMessage() {
            if (userProfile.personality === 'off') return '';
            const messages = PERSONALITY_MESSAGES[userProfile.personality] || PERSONALITY_MESSAGES.subtle;
            return messages[Math.floor(Math.random() * messages.length)];
        }

        function updatePersonalityFooter() {
            const footer = document.getElementById('personalityFooter');
            if (!footer) return;

            const message = getPersonalityMessage();
            if (message) {
                footer.innerHTML = `<span class="personality-message">"${message}"</span>`;
            } else {
                footer.innerHTML = '';
            }
        }

        // Update message every 30 seconds if on profile tab
        setInterval(() => {
            if (currentTab === 'profile') {
                updatePersonalityFooter();
            }
        }, 30000);

        // =====================================================
        // TOAST NOTIFICATIONS
        // =====================================================
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('visible');
            setTimeout(() => toast.classList.remove('visible'), duration);
        }

        // =====================================================
        // ONBOARDING SYSTEM
        // =====================================================
        let onboardingData = {
            name: '',
            avatar: '&#128512;',
            personality: 'subtle'
        };

        function showOnboarding() {
            document.getElementById('onboardingOverlay').classList.add('active');
            goToOnboardingScreen(1);
        }

        function hideOnboarding() {
            document.getElementById('onboardingOverlay').classList.remove('active');
        }

        function goToOnboardingScreen(screenNum) {
            document.querySelectorAll('.onboarding-screen').forEach(s => s.classList.remove('active'));
            const screen = document.querySelector(`.onboarding-screen[data-screen="${screenNum}"]`);
            if (screen) screen.classList.add('active');

            // Update progress dots
            document.querySelectorAll('.progress-dot').forEach((dot, idx) => {
                dot.classList.remove('active', 'completed');
                if (idx + 1 < screenNum) dot.classList.add('completed');
                if (idx + 1 === screenNum) dot.classList.add('active');
            });

            // Focus name input on screen 2
            if (screenNum === 2) {
                setTimeout(() => document.getElementById('onboardingName')?.focus(), 300);
            }

            // Update final preview on screen 5
            if (screenNum === 5) {
                document.getElementById('finalAvatarPreview').innerHTML = onboardingData.avatar;
                document.getElementById('finalNamePreview').textContent = onboardingData.name || 'Friend';
            }
        }

        async function completeOnboarding() {
            // Save profile to Firestore
            try {
                await db.collection('users').doc(currentUser.uid).set({
                    displayName: onboardingData.name || '',
                    avatar: onboardingData.avatar,
                    personality: onboardingData.personality,
                    onboardingComplete: true,
                    onboardingDate: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });

                // Update local state
                userProfile = {
                    displayName: onboardingData.name,
                    avatar: onboardingData.avatar,
                    personality: onboardingData.personality
                };

                updateProfileUI();
                hideOnboarding();
                showToast('Welcome to Mysa!');
            } catch (error) {
                console.error('[Onboarding] Error saving:', error);
                showToast('Error saving profile');
            }
        }

        // Initialize onboarding event listeners
        function initOnboarding() {
            // Screen 1: Welcome -> Name
            document.getElementById('onboardingNext1')?.addEventListener('click', () => {
                goToOnboardingScreen(2);
            });

            // Screen 2: Name
            const nameInput = document.getElementById('onboardingName');
            const nameNextBtn = document.getElementById('onboardingNext2');

            nameInput?.addEventListener('input', () => {
                onboardingData.name = nameInput.value.trim();
                nameNextBtn.disabled = onboardingData.name.length === 0;
            });

            nameNextBtn?.addEventListener('click', () => {
                goToOnboardingScreen(3);
            });

            document.getElementById('onboardingSkip2')?.addEventListener('click', () => {
                onboardingData.name = '';
                goToOnboardingScreen(3);
            });

            // Screen 3: Avatar
            document.getElementById('avatarPicker')?.addEventListener('click', (e) => {
                const option = e.target.closest('.avatar-option');
                if (!option) return;

                document.querySelectorAll('#avatarPicker .avatar-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                onboardingData.avatar = option.dataset.avatar;
            });

            document.getElementById('onboardingNext3')?.addEventListener('click', () => {
                goToOnboardingScreen(4);
            });

            document.getElementById('onboardingSkip3')?.addEventListener('click', () => {
                goToOnboardingScreen(4);
            });

            // Screen 4: Personality
            document.getElementById('personalityPicker')?.addEventListener('click', (e) => {
                const option = e.target.closest('.personality-option');
                if (!option) return;

                document.querySelectorAll('.personality-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                onboardingData.personality = option.dataset.personality;
            });

            document.getElementById('onboardingNext4')?.addEventListener('click', () => {
                goToOnboardingScreen(5);
            });

            // Screen 5: Finish
            document.getElementById('onboardingFinish')?.addEventListener('click', () => {
                completeOnboarding();
            });
        }

        // =====================================================
        // PROFILE MANAGEMENT
        // =====================================================
        function updateProfileUI() {
            const avatarEl = document.getElementById('profileAvatarEmoji');
            const nameEl = document.getElementById('profileDisplayName');
            const emailEl = document.getElementById('profileEmail');
            const personalityLabel = document.getElementById('personalitySettingLabel');

            if (avatarEl) avatarEl.innerHTML = userProfile.avatar || '&#128512;';
            if (nameEl) nameEl.textContent = userProfile.displayName || currentUser?.email?.split('@')[0] || 'Friend';
            if (emailEl) emailEl.textContent = currentUser?.email || '';

            const personalityLabels = {
                'off': 'Personality: Zen Mode',
                'subtle': 'Personality: Subtle',
                'fun': 'Personality: Full Fun'
            };
            if (personalityLabel) {
                personalityLabel.textContent = personalityLabels[userProfile.personality] || personalityLabels.subtle;
            }

            updatePersonalityFooter();
        }

        async function loadUserProfile() {
            try {
                console.log('[Profile] Loading profile for:', currentUser.uid);
                const doc = await db.collection('users').doc(currentUser.uid).get();
                if (doc.exists) {
                    const data = doc.data();
                    console.log('[Profile] Loaded from Firestore:', data);
                    userProfile = {
                        displayName: data.displayName || '',
                        avatar: data.avatar || '&#128512;',
                        personality: data.personality || 'subtle'
                    };
                    console.log('[Profile] userProfile set to:', userProfile);
                    return data.onboardingComplete || false;
                } else {
                    console.log('[Profile] No existing profile document');
                }
            } catch (error) {
                console.error('[Profile] Error loading:', error);
            }
            return false;
        }

        async function updateUserProfile(updates) {
            try {
                await db.collection('users').doc(currentUser.uid).set(updates, { merge: true });
                Object.assign(userProfile, updates);
                updateProfileUI();
                showToast('Profile updated!');
            } catch (error) {
                console.error('[Profile] Error updating:', error);
                showToast('Error updating profile');
            }
        }

        async function showEditNamePrompt() {
            const currentName = userProfile.displayName || '';
            const newName = prompt('Enter your display name:', currentName);

            console.log('[Profile] Edit name dialog - current:', currentName, 'new:', newName);

            if (newName === null) {
                console.log('[Profile] User cancelled');
                return;
            }

            const trimmedName = newName.trim();
            if (trimmedName === '') {
                showToast('Name cannot be empty');
                return;
            }

            if (trimmedName === currentName) {
                console.log('[Profile] Name unchanged');
                return;
            }

            console.log('[Profile] Saving new display name:', trimmedName);

            try {
                // Save to Firestore
                await db.collection('users').doc(currentUser.uid).set({
                    displayName: trimmedName
                }, { merge: true });

                console.log('[Profile] SUCCESS - Display name saved to Firestore');

                // Verify it saved
                const verify = await db.collection('users').doc(currentUser.uid).get();
                console.log('[Profile] Verification - Firestore now has:', verify.data());

                // Update local state
                userProfile.displayName = trimmedName;

                // Update UI
                updateProfileUI();
                updateHeader();

                // Clear name cache so other items refresh
                delete userNameCache[currentUser.uid];

                showToast('Name saved!');

            } catch (error) {
                console.error('[Profile] FAILED to save:', error);
                showToast('Failed to save. Try again.');
            }
        }

        function cyclePersonality() {
            const order = ['off', 'subtle', 'fun'];
            const currentIdx = order.indexOf(userProfile.personality);
            const nextIdx = (currentIdx + 1) % order.length;
            updateUserProfile({ personality: order[nextIdx] });
        }

        // API Key prompt
        function showApiKeyPrompt() {
            const currentKey = getClaudeApiKey();
            const maskedKey = currentKey ? `${currentKey.substring(0, 12)}...${currentKey.substring(currentKey.length - 4)}` : '(not set)';

            const newKey = prompt(
                `Claude API Key for Smart Categorization\n\nCurrent: ${maskedKey}\n\nEnter your Claude API key (or leave empty to disable AI features):`,
                currentKey
            );

            if (newKey === null) return; // Cancelled

            setClaudeApiKey(newKey.trim());

            if (newKey.trim()) {
                showToast('API key saved!');
            } else {
                showToast('API key cleared');
            }
        }

        // =====================================================
        // EDIT ITEM MODAL
        // =====================================================
        let currentEditingItemId = null;

        let currentEditingItemQuantity = 1;

        function showEditItemModal(itemId, itemText, itemCategory, itemQuantity = 1) {
            currentEditingItemId = itemId;
            currentEditingItemQuantity = itemQuantity;

            // Populate fields
            document.getElementById('editItemText').value = itemText;
            document.getElementById('editItemCategory').value = itemCategory || 'other';
            document.getElementById('editItemQuantity').textContent = itemQuantity;

            // Show modal
            document.getElementById('editItemModal').style.display = 'flex';

            // Focus on text input
            setTimeout(() => {
                document.getElementById('editItemText').focus();
                document.getElementById('editItemText').select();
            }, 100);
        }

        function adjustEditQuantity(delta) {
            currentEditingItemQuantity = Math.max(1, currentEditingItemQuantity + delta);
            document.getElementById('editItemQuantity').textContent = currentEditingItemQuantity;
        }

        function closeEditItemModal() {
            document.getElementById('editItemModal').style.display = 'none';
            currentEditingItemId = null;
        }

        async function saveEditedItem() {
            if (!currentEditingItemId) return;

            const newText = document.getElementById('editItemText').value.trim();
            const newCategory = document.getElementById('editItemCategory').value;
            const newQuantity = currentEditingItemQuantity;

            if (!newText) {
                showToast('Please enter an item name');
                return;
            }

            try {
                // Update Firestore
                await db.collection('lists').doc(lists.shopping)
                    .collection('items').doc(currentEditingItemId)
                    .update({
                        text: newText,
                        category: newCategory,
                        quantity: newQuantity
                    });

                // Save user preference for future items
                userCategoryPrefs[newText.toLowerCase().trim()] = {
                    corrected: newText,
                    category: newCategory
                };
                saveUserCategoryPrefs();

                // Also update AI cache so this exact text uses this category
                categoryCache[newText.toLowerCase().trim()] = {
                    original: newText,
                    corrected: newText,
                    category: newCategory,
                    confidence: 'high'
                };
                saveCategoryCache();

                closeEditItemModal();

                const cat = SHOPPING_CATEGORIES.find(c => c.id === newCategory);
                showToast(`Moved to ${cat.emoji} ${cat.name}`);

            } catch (error) {
                console.error('[Edit] Error saving:', error);
                showToast('Failed to save changes');
            }
        }

        // Close edit modal when clicking outside
        document.getElementById('editItemModal')?.addEventListener('click', (e) => {
            if (e.target.classList.contains('edit-item-modal-overlay')) {
                closeEditItemModal();
            }
        });

        // Avatar modal
        function showAvatarModal() {
            const modal = document.getElementById('avatarModal');
            modal?.classList.add('active');

            // Mark current avatar as selected
            const currentAvatar = userProfile.avatar;
            document.querySelectorAll('#avatarGrid .avatar-grid-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.avatar === currentAvatar);
            });
        }

        function hideAvatarModal() {
            document.getElementById('avatarModal')?.classList.remove('active');
        }

        function initProfileHandlers() {
            // Avatar click to open modal
            document.getElementById('profileAvatarLarge')?.addEventListener('click', showAvatarModal);

            // Avatar grid selection
            document.getElementById('avatarGrid')?.addEventListener('click', (e) => {
                const item = e.target.closest('.avatar-grid-item');
                if (!item) return;

                document.querySelectorAll('#avatarGrid .avatar-grid-item').forEach(i => i.classList.remove('selected'));
                item.classList.add('selected');
                updateUserProfile({ avatar: item.dataset.avatar });
            });

            // Close avatar modal
            document.getElementById('avatarModalClose')?.addEventListener('click', hideAvatarModal);
            document.getElementById('avatarModal')?.addEventListener('click', (e) => {
                if (e.target.id === 'avatarModal') hideAvatarModal();
            });

            // Edit name button
            document.getElementById('editNameBtn')?.addEventListener('click', showEditNamePrompt);

            // Personality setting button
            document.getElementById('personalitySettingBtn')?.addEventListener('click', cyclePersonality);

            // API key setting button
            document.getElementById('apiKeySettingBtn')?.addEventListener('click', showApiKeyPrompt);
        }

        // =====================================================
        // OFFLINE/ONLINE HANDLERS
        // =====================================================
        window.addEventListener('online', () => {
            document.getElementById('offlineIndicator').classList.remove('visible');
            showToast('Back online!');
        });

        window.addEventListener('offline', () => {
            document.getElementById('offlineIndicator').classList.add('visible');
        });

        // Check initial state
        if (!navigator.onLine) {
            document.getElementById('offlineIndicator').classList.add('visible');
        }

        // State
        let currentUser = null;
        let currentTab = 'tasks'; // 'tasks', 'shopping', or 'profile'
        let lists = { tasks: null, shopping: null }; // List IDs
        let listData = { tasks: null, shopping: null }; // Full list documents
        let itemCounts = { tasks: 0, shopping: 0 };
        let completedCounts = { tasks: 0, shopping: 0 };
        let unsubscribeItems = null;
        let unsubscribeList = null;
        const pendingDeletions = new Map(); // itemId -> timeoutId for auto-delete
        const pendingPriorityChanges = new Map(); // itemId -> { timeoutId, originalSortKey } for delayed re-sort

        // DOM Elements
        const authContainer = document.getElementById('authContainer');
        const appContainer = document.getElementById('appContainer');
        const pageTitle = document.getElementById('pageTitle');
        const headerSubtitle = document.getElementById('headerSubtitle');
        const authError = document.getElementById('authError');
        const shareBtn = document.getElementById('shareBtn');
        const shareModal = document.getElementById('shareModal');
        const modalClose = document.getElementById('modalClose');
        const inviteEmail = document.getElementById('inviteEmail');
        const inviteBtn = document.getElementById('inviteBtn');
        const inviteSection = document.getElementById('inviteSection');
        const shareMessage = document.getElementById('shareMessage');
        const collaboratorList = document.getElementById('collaboratorList');
        const listContent = document.getElementById('listContent');
        const profileContent = document.getElementById('profileContent');
        const addInputContainer = document.getElementById('addInputContainer');
        const itemInput = document.getElementById('itemInput');

        // =====================================================
        // HOUSEHOLD MODULE (New Architecture)
        // =====================================================
        let currentHousehold = null; // { id, name, members }

        const HouseholdModule = {
            // Find user by email
            async findUserByEmail(email) {
                const usersRef = db.collection('users');
                const snapshot = await usersRef.where('email', '==', email.toLowerCase()).limit(1).get();
                if (!snapshot.empty) {
                    const doc = snapshot.docs[0];
                    return { id: doc.id, ...doc.data() };
                }
                return null;
            },

            // Save/update user profile
            async saveUserProfile(user) {
                const userRef = db.collection('users').doc(user.uid);
                const existingDoc = await userRef.get();

                if (existingDoc.exists) {
                    console.log('[Profile] Existing user, preserving displayName and householdId');
                    await userRef.set({
                        email: user.email.toLowerCase(),
                        lastLogin: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                } else {
                    console.log('[Profile] New user, creating profile');
                    await userRef.set({
                        email: user.email.toLowerCase(),
                        displayName: user.displayName || user.email.split('@')[0],
                        householdId: null,
                        lastLogin: firebase.firestore.FieldValue.serverTimestamp(),
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
            },

            // Get user's household ID from their profile
            async getUserHouseholdId(userId) {
                const userDoc = await db.collection('users').doc(userId).get();
                return userDoc.exists ? userDoc.data().householdId : null;
            },

            // Create a new household for a user
            async createHousehold(userId, userEmail, userDisplayName) {
                console.log('[Household] Creating new household for:', userEmail);

                const householdRef = await db.collection('households').add({
                    name: userDisplayName + "'s Home",
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    createdBy: userId,
                    members: {
                        [userId]: {
                            email: userEmail,
                            displayName: userDisplayName,
                            joinedAt: firebase.firestore.FieldValue.serverTimestamp()
                        }
                    }
                });

                // Update user's householdId
                await db.collection('users').doc(userId).update({
                    householdId: householdRef.id
                });

                // Create Shopping and Tasks lists for the household
                const listsRef = db.collection('lists');

                const shoppingRef = await listsRef.add({
                    type: 'shopping',
                    householdId: householdRef.id,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                const tasksRef = await listsRef.add({
                    type: 'tasks',
                    householdId: householdRef.id,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                console.log('[Household] Created household:', householdRef.id);
                console.log('[Household] Created lists - shopping:', shoppingRef.id, 'tasks:', tasksRef.id);

                return householdRef.id;
            },

            // Get household data
            async getHousehold(householdId) {
                const doc = await db.collection('households').doc(householdId).get();
                if (!doc.exists) return null;
                return { id: doc.id, ...doc.data() };
            },

            // Get lists for a household
            async getHouseholdLists(householdId) {
                const snapshot = await db.collection('lists')
                    .where('householdId', '==', householdId)
                    .get();

                const result = { shopping: null, tasks: null };
                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    if (data.type === 'shopping') result.shopping = doc.id;
                    if (data.type === 'tasks') result.tasks = doc.id;
                });

                return result;
            },

            // Invite someone to household (v5.2.0 - bulletproof version)
            async inviteToHousehold(householdId, inviteeEmail) {
                console.log('[Invite] Starting invite for:', inviteeEmail, 'to household:', householdId);

                const invitee = await this.findUserByEmail(inviteeEmail);

                if (!invitee) {
                    throw new Error('User not found. They need to sign up first.');
                }

                console.log('[Invite] Found user:', invitee.id, invitee.displayName);

                if (invitee.id === currentUser.uid) {
                    throw new Error('You cannot invite yourself.');
                }

                // Check if OUR household exists
                let household = await this.getHousehold(householdId);
                if (!household) {
                    console.error('[Invite] Our household does not exist! Recreating...');
                    // Our household is missing - this shouldn't happen but let's recover
                    throw new Error('Your household data is missing. Please refresh the app and try again.');
                }

                // Check if invitee is already in this household
                if (household.members && household.members[invitee.id]) {
                    throw new Error('Already a member of this household.');
                }

                // Check if invitee is in another household (with other people)
                const oldHouseholdId = invitee.householdId;
                if (oldHouseholdId && oldHouseholdId !== householdId) {
                    const theirHousehold = await this.getHousehold(oldHouseholdId);
                    if (theirHousehold) {
                        const memberCount = Object.keys(theirHousehold.members || {}).length;
                        if (memberCount > 1) {
                            throw new Error('This person is already in another household with others.');
                        }
                        // They're in a solo household - we'll merge their items
                        console.log('[Invite] Invitee has solo household:', oldHouseholdId);
                    } else {
                        // Their householdId points to a non-existent household - ignore it
                        console.log('[Invite] Invitee has orphaned householdId, will clean up');
                    }
                }

                // Migrate invitee's items from their old lists to this household's lists
                console.log('[Invite] Migrating items...');
                await this.migrateUserToHousehold(invitee, householdId);

                // CRITICAL: Use batch write to ensure ALL updates happen atomically
                console.log('[Invite] Performing atomic batch update...');
                const batch = db.batch();

                // 1. Add invitee to household members
                const householdRef = db.collection('households').doc(householdId);
                batch.update(householdRef, {
                    [`members.${invitee.id}`]: {
                        email: invitee.email,
                        displayName: invitee.displayName || invitee.email.split('@')[0],
                        joinedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }
                });

                // 2. Update invitee's householdId - THIS IS THE CRITICAL ONE
                const inviteeRef = db.collection('users').doc(invitee.id);
                batch.update(inviteeRef, {
                    householdId: householdId
                });

                // Commit the batch
                await batch.commit();
                console.log('[Invite] Batch commit successful!');

                // VERIFICATION: Confirm the update actually worked
                const verifyUser = await db.collection('users').doc(invitee.id).get();
                const verifiedHouseholdId = verifyUser.data()?.householdId;
                console.log('[Invite] Verification - user householdId is now:', verifiedHouseholdId);

                if (verifiedHouseholdId !== householdId) {
                    console.error('[Invite] VERIFICATION FAILED! Expected:', householdId, 'Got:', verifiedHouseholdId);
                    // Try one more time with a direct update
                    console.log('[Invite] Retrying with direct update...');
                    await db.collection('users').doc(invitee.id).set({
                        householdId: householdId
                    }, { merge: true });

                    // Verify again
                    const retryVerify = await db.collection('users').doc(invitee.id).get();
                    if (retryVerify.data()?.householdId !== householdId) {
                        throw new Error('Failed to update user household. Please try again.');
                    }
                    console.log('[Invite] Retry successful!');
                }

                // Update household name if it's now 2 people
                const updatedHousehold = await this.getHousehold(householdId);
                const members = Object.values(updatedHousehold.members || {});
                if (members.length === 2) {
                    const names = members.map(m => m.displayName || m.email.split('@')[0]);
                    await db.collection('households').doc(householdId).update({
                        name: names.join(' & ') + "'s Home"
                    });
                }

                // Clean up old solo household if it exists
                if (oldHouseholdId && oldHouseholdId !== householdId) {
                    console.log('[Invite] Cleaning up old household:', oldHouseholdId);
                    try {
                        // Delete old lists
                        const oldLists = await this.getHouseholdLists(oldHouseholdId);
                        if (oldLists.shopping) {
                            const items = await db.collection('lists').doc(oldLists.shopping).collection('items').get();
                            items.forEach(doc => doc.ref.delete());
                            await db.collection('lists').doc(oldLists.shopping).delete();
                        }
                        if (oldLists.tasks) {
                            const items = await db.collection('lists').doc(oldLists.tasks).collection('items').get();
                            items.forEach(doc => doc.ref.delete());
                            await db.collection('lists').doc(oldLists.tasks).delete();
                        }
                        // Delete old household
                        await db.collection('households').doc(oldHouseholdId).delete();
                        console.log('[Invite] Old household cleaned up');
                    } catch (cleanupError) {
                        console.warn('[Invite] Cleanup warning:', cleanupError.message);
                        // Don't throw - cleanup is not critical
                    }
                }

                console.log('[Invite] SUCCESS! Added member:', invitee.email);
                return invitee;
            },

            // Migrate user's items from their old household to new household
            async migrateUserToHousehold(user, newHouseholdId) {
                const oldHouseholdId = user.householdId;
                if (!oldHouseholdId || oldHouseholdId === newHouseholdId) {
                    console.log('[Migration] No old household to migrate from');
                    return;
                }

                console.log('[Migration] Migrating items from household:', oldHouseholdId);

                // Get old and new lists
                const oldLists = await this.getHouseholdLists(oldHouseholdId);
                const newLists = await this.getHouseholdLists(newHouseholdId);

                // Migrate shopping items
                if (oldLists.shopping && newLists.shopping) {
                    await this.migrateItems(oldLists.shopping, newLists.shopping, 'shopping');
                }

                // Migrate tasks items
                if (oldLists.tasks && newLists.tasks) {
                    await this.migrateItems(oldLists.tasks, newLists.tasks, 'tasks');
                }

                // Delete old household if it's now empty (solo household)
                const oldHousehold = await this.getHousehold(oldHouseholdId);
                if (oldHousehold) {
                    const memberCount = Object.keys(oldHousehold.members || {}).length;
                    if (memberCount <= 1) {
                        console.log('[Migration] Deleting empty old household');
                        // Delete old lists
                        if (oldLists.shopping) await db.collection('lists').doc(oldLists.shopping).delete();
                        if (oldLists.tasks) await db.collection('lists').doc(oldLists.tasks).delete();
                        // Delete old household
                        await db.collection('households').doc(oldHouseholdId).delete();
                    }
                }
            },

            // Migrate items from one list to another
            async migrateItems(fromListId, toListId, type) {
                const fromRef = db.collection('lists').doc(fromListId).collection('items');
                const toRef = db.collection('lists').doc(toListId).collection('items');

                const fromSnapshot = await fromRef.get();
                if (fromSnapshot.empty) {
                    console.log(`[Migration] No ${type} items to migrate`);
                    return;
                }

                // Get existing items in destination
                const toSnapshot = await toRef.get();
                const existingTexts = new Set(
                    toSnapshot.docs.map(doc => (doc.data().text || '').toLowerCase())
                );

                let migratedCount = 0;
                const batch = db.batch();

                for (const doc of fromSnapshot.docs) {
                    const itemData = doc.data();
                    const itemText = (itemData.text || '').toLowerCase();

                    if (existingTexts.has(itemText)) {
                        // Duplicate - just delete from old list
                        batch.delete(doc.ref);
                        continue;
                    }

                    // Move to new list
                    const newDocRef = toRef.doc();
                    batch.set(newDocRef, itemData);
                    batch.delete(doc.ref);

                    existingTexts.add(itemText);
                    migratedCount++;
                }

                if (migratedCount > 0 || fromSnapshot.size > 0) {
                    await batch.commit();
                    console.log(`[Migration] Migrated ${migratedCount} ${type} items`);
                    if (migratedCount > 0) {
                        showToast(`Merged ${migratedCount} ${type} items`, 2000);
                    }
                }
            },

            // Remove member from household
            async removeMember(householdId, memberId) {
                const household = await this.getHousehold(householdId);
                if (!household) throw new Error('Household not found');

                const memberCount = Object.keys(household.members || {}).length;
                if (memberCount <= 1) {
                    throw new Error('Cannot remove the last member');
                }

                // Remove from household members
                await db.collection('households').doc(householdId).update({
                    [`members.${memberId}`]: firebase.firestore.FieldValue.delete()
                });

                // Clear user's householdId
                await db.collection('users').doc(memberId).update({
                    householdId: null
                });

                console.log('[Household] Removed member:', memberId);
            },

            // Check if household has collaborators (for UI)
            async hasCollaborators(householdId) {
                const household = await this.getHousehold(householdId);
                return household && Object.keys(household.members || {}).length > 1;
            }
        };

        // Legacy SharingModule - redirects to HouseholdModule
        const SharingModule = {
            findUserByEmail: (email) => HouseholdModule.findUserByEmail(email),
            saveUserProfile: (user) => HouseholdModule.saveUserProfile(user),

            // Redirect to household invite
            async addCollaborator(listId, collaboratorEmail) {
                if (!currentHousehold) {
                    throw new Error('No household found');
                }
                return await HouseholdModule.inviteToHousehold(currentHousehold.id, collaboratorEmail);
            },

            // Redirect to household remove
            async removeCollaborator(listId, collaboratorId) {
                if (!currentHousehold) {
                    throw new Error('No household found');
                }
                await HouseholdModule.removeMember(currentHousehold.id, collaboratorId);
            },

            // Everyone in a household has equal rights
            isOwner(listDoc) {
                return currentHousehold !== null;
            },

            // Check if household has multiple members
            isShared(listDoc) {
                return currentHousehold && Object.keys(currentHousehold.members || {}).length > 1;
            },

            // Get household members as collaborators
            getCollaborators(listDoc) {
                if (!currentHousehold || !currentHousehold.members) return [];
                return Object.entries(currentHousehold.members)
                    .filter(([id]) => id !== currentUser.uid) // Exclude self
                    .map(([id, data]) => ({
                        id,
                        email: data.email,
                        displayName: data.displayName,
                        joinedAt: data.joinedAt
                    }));
            }
        };

        // =====================================================
        // UTILITY FUNCTIONS
        // =====================================================
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Escape text for use in onclick attributes
        function escapeForAttr(text) {
            if (!text) return '';
            return text.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, ' ');
        }

        function showError(message) {
            authError.textContent = message;
            authError.classList.add('show');
            setTimeout(() => authError.classList.remove('show'), 5000);
        }

        function truncateEmail(email) {
            if (!email) return '';
            const parts = email.split('@');
            const name = parts[0];
            return name.length > 12 ? name.substring(0, 12) + '...' : name;
        }

        // User name cache for display names
        const userNameCache = {};

        async function getDisplayName(userId, fallbackEmail) {
            // If it's current user
            if (userId === currentUser?.uid) {
                return 'You';
            }

            // Check cache first
            if (userNameCache[userId]) {
                return userNameCache[userId];
            }

            // Fetch from Firestore users collection
            try {
                console.log('[Profile] Fetching display name for user:', userId);
                const userDoc = await db.collection('users').doc(userId).get();
                if (userDoc.exists) {
                    const data = userDoc.data();
                    const name = data.displayName || fallbackEmail?.split('@')[0] || 'Someone';
                    console.log('[Profile] Found display name:', name, 'for user:', userId);
                    userNameCache[userId] = name;
                    return name;
                } else {
                    console.log('[Profile] No user document found for:', userId);
                }
            } catch (e) {
                console.error('[Profile] Error fetching user:', e);
            }

            // Fallback to email prefix
            const name = fallbackEmail?.split('@')[0] || 'Someone';
            if (userId) userNameCache[userId] = name;
            return name;
        }

        function getAddedByText(item) {
            // Compare by UID (primary) or email (fallback for old items)
            if (item.createdBy === currentUser?.uid) {
                return 'added by You';
            }
            // Fallback: compare emails (case-insensitive) for old items without UID
            if (item.createdByEmail && currentUser?.email &&
                item.createdByEmail.toLowerCase() === currentUser.email.toLowerCase()) {
                return 'added by You';
            }
            // Return placeholder with email prefix or cached name - will be updated async
            if (item.createdByEmail) {
                // Check cache for immediate display
                if (item.createdBy && userNameCache[item.createdBy]) {
                    return `added by ${userNameCache[item.createdBy]}`;
                }
                const name = item.createdByEmail.split('@')[0];
                return `added by ${name}`;
            }
            return '';
        }

        // Update display names asynchronously after render
        async function updateItemDisplayNames() {
            const metaElements = document.querySelectorAll('.item-meta[data-creator-id]');

            for (const el of metaElements) {
                const creatorId = el.dataset.creatorId;
                const creatorEmail = el.dataset.creatorEmail;

                if (!creatorId || creatorId === currentUser?.uid) continue;

                // Fetch display name
                const displayName = await getDisplayName(creatorId, creatorEmail);

                // Update the element if it still exists
                if (el.isConnected) {
                    el.textContent = `added by ${displayName}`;
                }
            }
        }

        // =====================================================
        // UI UPDATE FUNCTIONS
        // =====================================================
        function updateHeader() {
            if (currentTab === 'profile') {
                pageTitle.textContent = 'Profile';
                headerSubtitle.textContent = '';
                shareBtn.classList.add('hidden');
            } else {
                const title = currentTab === 'tasks' ? 'Tasks' : 'Shopping';
                pageTitle.textContent = title;

                // Use display name if available, otherwise email
                const displayName = userProfile.displayName || truncateEmail(currentUser?.email);
                const total = itemCounts[currentTab] || 0;
                const completed = completedCounts[currentTab] || 0;
                const remaining = total - completed;

                let countText;
                if (total === 0) {
                    countText = 'No items';
                } else if (completed > 0) {
                    countText = `${remaining} remaining`;
                } else {
                    countText = `${total} item${total !== 1 ? 's' : ''}`;
                }

                headerSubtitle.textContent = `${displayName}  ${countText}`;

                shareBtn.classList.remove('hidden');

                // Update share button state
                const data = listData[currentTab];
                if (data && (SharingModule.isShared(data) || !SharingModule.isOwner(data))) {
                    shareBtn.classList.add('has-collaborators');
                } else {
                    shareBtn.classList.remove('has-collaborators');
                }
            }
        }

        function updatePlaceholder() {
            const placeholder = currentTab === 'tasks' ? 'Add a task...' : 'Add an item...';
            itemInput.placeholder = placeholder;

            // Show/hide category picker buttons based on tab
            const shoppingCategoryBtn = document.getElementById('categoryPickerBtn');
            const taskCategoryBtn = document.getElementById('taskCategoryPickerBtn');

            if (shoppingCategoryBtn) {
                shoppingCategoryBtn.style.display = currentTab === 'shopping' ? 'flex' : 'none';
            }
            if (taskCategoryBtn) {
                taskCategoryBtn.style.display = currentTab === 'tasks' ? 'flex' : 'none';
            }
        }

        // =====================================================
        // NAVIGATION
        // =====================================================
        function switchTab(tab) {
            currentTab = tab;

            // Update nav buttons
            document.querySelectorAll('.nav-item').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });

            // Show/hide content
            if (tab === 'profile') {
                listContent.classList.add('hidden');
                profileContent.classList.add('active');
                addInputContainer.classList.add('hidden');
                updatePersonalityFooter(); // Refresh personality message
            } else {
                listContent.classList.remove('hidden');
                profileContent.classList.remove('active');
                addInputContainer.classList.remove('hidden');
                subscribeToItems();
            }

            updateHeader();
            updatePlaceholder();
        }

        // =====================================================
        // PWA VISIBILITY REFRESH
        // =====================================================
        async function refreshCurrentList() {
            if (!lists[currentTab] || currentTab === 'profile') return;
            console.log('[PWA] Refreshing current list...');

            const listId = lists[currentTab];
            const itemsRef = db.collection('lists').doc(listId).collection('items');

            try {
                const snapshot = await itemsRef.get();
                renderItems(snapshot);
            } catch (error) {
                console.error('[PWA] Refresh error:', error);
            }
        }

        // Refresh when app becomes visible (PWA returning from background)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && currentUser) {
                console.log('[PWA] App became visible, refreshing...');
                refreshCurrentList();
            }
        });

        window.addEventListener('focus', () => {
            if (currentUser) {
                console.log('[PWA] Window focused, refreshing...');
                refreshCurrentList();
            }
        });

        // =====================================================
        // CLEAN HOUSEHOLD INITIALIZATION (v5.1.0)
        // No migration, no fallback - pure Household model
        // =====================================================
        async function initializeLists() {
            console.log('[Init v5.1] Initializing for user:', currentUser.email);

            // Step 1: Check if user has a household
            let householdId = await HouseholdModule.getUserHouseholdId(currentUser.uid);
            console.log('[Init v5.1] User householdId:', householdId);

            // Step 2: If no household, create one (fresh start)
            if (!householdId) {
                console.log('[Init v5.1] No household - creating fresh household...');
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                const userData = userDoc.data() || {};
                const displayName = userData.displayName || currentUser.email.split('@')[0];

                householdId = await HouseholdModule.createHousehold(
                    currentUser.uid,
                    currentUser.email,
                    displayName
                );
                console.log('[Init v5.1] Created new household:', householdId);
            }

            // Step 3: Load household data
            currentHousehold = await HouseholdModule.getHousehold(householdId);
            if (!currentHousehold) {
                throw new Error('Household not found: ' + householdId);
            }
            console.log('[Init v5.1] Household:', currentHousehold.name, '| Members:', Object.keys(currentHousehold.members || {}).length);

            // Step 4: Get household's lists
            const householdLists = await HouseholdModule.getHouseholdLists(householdId);
            console.log('[Init v5.1] Lists:', householdLists);

            // Step 5: Create any missing lists (shouldn't happen, but safety net)
            if (!householdLists.shopping || !householdLists.tasks) {
                console.log('[Init v5.1] Creating missing lists...');
                const listsRef = db.collection('lists');

                if (!householdLists.shopping) {
                    const ref = await listsRef.add({
                        type: 'shopping',
                        householdId: householdId,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    householdLists.shopping = ref.id;
                    console.log('[Init v5.1] Created shopping list:', ref.id);
                }

                if (!householdLists.tasks) {
                    const ref = await listsRef.add({
                        type: 'tasks',
                        householdId: householdId,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    householdLists.tasks = ref.id;
                    console.log('[Init v5.1] Created tasks list:', ref.id);
                }
            }

            // Step 6: Set the active lists
            lists.shopping = householdLists.shopping;
            lists.tasks = householdLists.tasks;

            console.log('[Init v5.1] SUCCESS! Shopping:', lists.shopping, '| Tasks:', lists.tasks);
        }

        // =====================================================
        // ITEMS RENDERING
        // =====================================================
        function renderItems(snapshot, isUserAction = false) {
            const listEl = document.getElementById('itemList');
            hideSkeletons();

            if (snapshot.empty) {
                const isTasksTab = currentTab === 'tasks';
                const icon = isTasksTab ? '&#10024;' : '&#128722;';
                const title = isTasksTab ? 'All done!' : 'Shopping list is empty';
                const subtitle = isTasksTab
                    ? 'No tasks right now. Enjoy your free time!'
                    : 'Add items and they\'ll be auto-organized!';

                listEl.innerHTML = `
                    <li class="empty-state">
                        <div class="empty-state-icon">${icon}</div>
                        <h3>${title}</h3>
                        <p>${subtitle}</p>
                    </li>
                `;
                itemCounts[currentTab] = 0;
                completedCounts[currentTab] = 0;
                updateHeader();
                return;
            }

            const items = [];
            snapshot.forEach(doc => {
                items.push({ id: doc.id, ...doc.data() });
            });

            const completedCount = items.filter(i => i.done).length;
            itemCounts[currentTab] = items.length;
            completedCounts[currentTab] = completedCount;
            updateHeader();

            // Use category view for both tabs
            if (currentTab === 'shopping') {
                renderShoppingWithCategories(listEl, items, completedCount);
            } else {
                renderTasksWithCategories(listEl, items, completedCount);
                // Check for old tasks that might need attention
                checkOldTasks(items);
            }

            // Update display names asynchronously
            updateItemDisplayNames();

            // Initialize swipe handlers for new items
            initSwipeHandlers();
        }

        // Render tasks with category sections
        function renderTasksWithCategories(listEl, items, completedCount) {
            // Group items by category
            const grouped = {};
            TASK_CATEGORIES.forEach(cat => {
                grouped[cat.id] = [];
            });

            items.forEach(item => {
                const cat = item.category || 'other';
                if (grouped[cat]) {
                    grouped[cat].push(item);
                } else {
                    grouped['other'].push(item);
                }
            });

            // Sort items within each category by: incomplete first, then priority, then date
            // Items with pending priority changes keep their original sort position
            const priorityOrder = { high: 0, medium: 1, none: 2, undefined: 2 };
            const getPriorityForSort = (item) => {
                if (pendingPriorityChanges.has(item.id)) {
                    const pending = pendingPriorityChanges.get(item.id);
                    return priorityOrder[pending.originalPriority] ?? 2;
                }
                return priorityOrder[item.priority] ?? 2;
            };
            for (const catItems of Object.values(grouped)) {
                catItems.sort((a, b) => {
                    if (a.done !== b.done) return a.done ? 1 : -1;
                    const aPriority = getPriorityForSort(a);
                    const bPriority = getPriorityForSort(b);
                    if (aPriority !== bPriority) return aPriority - bPriority;
                    const aTime = a.createdAt?.toMillis() || 0;
                    const bTime = b.createdAt?.toMillis() || 0;
                    return aTime - bTime;
                });
            }

            const taskCollapsed = JSON.parse(localStorage.getItem('taskCollapsedSections') || '{}');

            const getPriorityClass = (priority) => {
                if (priority === 'high') return 'priority-high';
                if (priority === 'medium') return 'priority-medium';
                return 'priority-none';
            };

            let html = '';
            let hasItems = false;

            // Render regular categories (not fuckit)
            const regularCategories = TASK_CATEGORIES.filter(c => c.id !== 'fuckit');

            regularCategories.forEach(category => {
                const categoryItems = grouped[category.id];
                if (categoryItems.length === 0) return;
                hasItems = true;

                const doneCount = categoryItems.filter(i => i.done).length;
                const remaining = categoryItems.length - doneCount;
                const isCollapsed = taskCollapsed[category.id] || false;
                const allDone = remaining === 0;

                html += `
                    <li class="category-section ${allDone ? 'all-done' : ''}" data-category="${category.id}">
                        <div class="category-header" onclick="toggleTaskSection('${category.id}')">
                            <div class="category-info">
                                <span class="category-emoji">${category.emoji}</span>
                                <span class="category-name">${category.name}</span>
                                <span class="category-count">${allDone ? '' : remaining + ' left'}</span>
                            </div>
                            <span class="category-toggle">${isCollapsed ? '' : ''}</span>
                        </div>
                        <div class="category-items ${isCollapsed ? 'collapsed' : ''}">
                            ${categoryItems.map(item => `
                                <div class="task-item ${item.done ? 'done' : ''}" data-id="${item.id}"
                                     ontouchstart="startTaskLongPress(event, '${item.id}', '${escapeForAttr(item.text)}', '${item.category || 'other'}')"
                                     ontouchend="cancelTaskLongPress()" ontouchmove="cancelTaskLongPress()">
                                    <div class="item-checkbox ${item.done ? 'checked' : ''}" data-action="toggle">
                                        ${item.done ? '' : ''}
                                    </div>
                                    <div class="item-content">
                                        <span class="item-text">${escapeHtml(item.text)}</span>
                                    </div>
                                    <button class="priority-btn" data-action="priority" title="Change priority">
                                        <span class="priority-dot ${getPriorityClass(item.priority)}"></span>
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    </li>
                `;
            });

            // Render Fuck It Bucket separately at the bottom (if has items)
            const fuckitItems = grouped['fuckit'];
            if (fuckitItems.length > 0) {
                const isCollapsed = taskCollapsed['fuckit'] || false;
                html += `
                    <li class="category-section fuckit-section" data-category="fuckit">
                        <div class="category-header fuckit-header" onclick="toggleTaskSection('fuckit')">
                            <div class="category-info">
                                <span class="category-emoji"></span>
                                <span class="category-name">Fuck It Bucket</span>
                                <span class="category-count">${fuckitItems.length} released</span>
                            </div>
                            <span class="category-toggle">${isCollapsed ? '' : ''}</span>
                        </div>
                        <div class="category-items ${isCollapsed ? 'collapsed' : ''}">
                            ${fuckitItems.map(item => `
                                <div class="task-item fuckit-item" data-id="${item.id}">
                                    <div class="item-content">
                                        <span class="item-text">${escapeHtml(item.text)}</span>
                                        <span class="item-meta">let go ${formatTimeAgo(item.fuckitAt)}</span>
                                    </div>
                                    <button class="restore-btn" onclick="restoreFromFuckit('${item.id}')" title="Restore task"></button>
                                </div>
                            `).join('')}
                        </div>
                    </li>
                `;
            }

            // Clear completed button removed - items auto-delete after 3 seconds

            // Add personality message footer
            const message = getPersonalityMessage();
            if (message && (hasItems || fuckitItems.length > 0)) {
                html += `
                    <li class="personality-footer">
                        <span class="personality-message">"${message}"</span>
                    </li>
                `;
            }

            listEl.innerHTML = html;
        }

        function toggleTaskSection(catId) {
            const collapsed = JSON.parse(localStorage.getItem('taskCollapsedSections') || '{}');
            collapsed[catId] = !collapsed[catId];
            localStorage.setItem('taskCollapsedSections', JSON.stringify(collapsed));

            const section = document.querySelector(`[data-category="${catId}"]`);
            if (!section) return;
            const items = section.querySelector('.category-items');
            const toggle = section.querySelector('.category-toggle');
            items?.classList.toggle('collapsed');
            if (toggle) toggle.textContent = collapsed[catId] ? '' : '';
        }

        function formatTimeAgo(timestamp) {
            if (!timestamp) return 'recently';
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            const now = new Date();
            const diffDays = Math.floor((now - date) / (1000 * 60 * 60 * 24));

            if (diffDays === 0) return 'today';
            if (diffDays === 1) return 'yesterday';
            if (diffDays < 7) return `${diffDays} days ago`;
            if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
            return `${Math.floor(diffDays / 30)} months ago`;
        }

        // Render shopping list with category sections
        function renderShoppingWithCategories(listEl, items, completedCount) {
            // Group items by category
            const grouped = {};
            SHOPPING_CATEGORIES.forEach(cat => {
                grouped[cat.id] = [];
            });

            items.forEach(item => {
                const cat = item.category || 'other';
                if (grouped[cat]) {
                    grouped[cat].push(item);
                } else {
                    grouped['other'].push(item);
                }
            });

            // Sort items within each category by: incomplete first, then priority, then date
            // Items with pending priority changes keep their original sort position
            const priorityOrder = { high: 0, medium: 1, none: 2, undefined: 2 };
            const getPriorityForSort = (item) => {
                if (pendingPriorityChanges.has(item.id)) {
                    const pending = pendingPriorityChanges.get(item.id);
                    return priorityOrder[pending.originalPriority] ?? 2;
                }
                return priorityOrder[item.priority] ?? 2;
            };
            for (const catItems of Object.values(grouped)) {
                catItems.sort((a, b) => {
                    if (a.done !== b.done) return a.done ? 1 : -1;
                    const aPriority = getPriorityForSort(a);
                    const bPriority = getPriorityForSort(b);
                    if (aPriority !== bPriority) return aPriority - bPriority;
                    const aTime = a.createdAt?.toMillis() || 0;
                    const bTime = b.createdAt?.toMillis() || 0;
                    return aTime - bTime;
                });
            }

            const collapsedSections = getCollapsedSections();

            const getPriorityClass = (priority) => {
                if (priority === 'high') return 'priority-high';
                if (priority === 'medium') return 'priority-medium';
                return 'priority-none';
            };

            let html = '';

            // Render each category that has items
            SHOPPING_CATEGORIES.forEach(category => {
                const categoryItems = grouped[category.id];
                if (categoryItems.length === 0) return;

                const doneCount = categoryItems.filter(i => i.done).length;
                const totalCount = categoryItems.length;
                const isCollapsed = collapsedSections[category.id] || false;
                const allDone = doneCount === totalCount;

                html += `
                    <li class="category-section ${allDone ? 'all-done' : ''}" data-category="${category.id}">
                        <div class="category-header" onclick="toggleSection('${category.id}')">
                            <div class="category-info">
                                <span class="category-emoji">${category.emoji}</span>
                                <span class="category-name">${category.name}</span>
                                <span class="category-count">(${doneCount}/${totalCount})</span>
                            </div>
                            <span class="category-toggle">${isCollapsed ? '' : ''}</span>
                        </div>
                        <div class="category-items ${isCollapsed ? 'collapsed' : ''}">
                            ${categoryItems.map(item => `
                                <div class="shopping-item ${item.done ? 'done' : ''}" data-id="${item.id}"
                                     ontouchstart="startLongPress(event, '${item.id}', '${escapeForAttr(item.text)}', '${item.category || 'other'}', ${item.quantity || 1})"
                                     ontouchend="cancelLongPress()" ontouchmove="cancelLongPress()">
                                    <div class="item-checkbox ${item.done ? 'checked' : ''}" data-action="toggle">
                                        ${item.done ? '' : ''}
                                    </div>
                                    <div class="item-content">
                                        <span class="item-text">${escapeHtml(item.text)}${(item.quantity || 1) > 1 ? ` <span class="item-quantity"> ${item.quantity}</span>` : ''}</span>
                                    </div>
                                    <button class="priority-btn" data-action="priority" title="Change priority">
                                        <span class="priority-dot ${getPriorityClass(item.priority)}"></span>
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    </li>
                `;
            });

            // Clear completed button removed - items auto-delete after 3 seconds

            // Add personality message footer
            const message = getPersonalityMessage();
            if (message && items.length > 0) {
                html += `
                    <li class="personality-footer">
                        <span class="personality-message">"${message}"</span>
                    </li>
                `;
            }

            listEl.innerHTML = html;
        }

        // =====================================================
        // LOADING SKELETONS
        // =====================================================
        let loadingTimer = null;

        function showSkeletons() {
            document.getElementById('itemList').innerHTML = '';
            loadingTimer = setTimeout(() => {
                document.getElementById('skeletonContainer').style.display = 'block';
            }, 200); // Only show if loading > 200ms
        }

        function hideSkeletons() {
            clearTimeout(loadingTimer);
            document.getElementById('skeletonContainer').style.display = 'none';
        }

        // =====================================================
        // SUBSCRIBE TO ITEMS
        // =====================================================
        function subscribeToItems() {
            if (unsubscribeItems) unsubscribeItems();
            if (unsubscribeList) unsubscribeList();

            const listId = lists[currentTab];
            if (!listId) return;

            const listRef = db.collection('lists').doc(listId);
            const itemsRef = listRef.collection('items');

            showSkeletons();

            // Subscribe to list document
            unsubscribeList = listRef.onSnapshot(doc => {
                if (doc.exists) {
                    listData[currentTab] = { id: doc.id, ...doc.data() };
                    updateHeader();
                }
            });

            // Subscribe to items
            unsubscribeItems = itemsRef.onSnapshot(snapshot => {
                renderItems(snapshot);
            }, error => {
                console.error('Error:', error);
                hideSkeletons();
                document.getElementById('itemList').innerHTML =
                    '<li class="empty-state"><h3>Oops!</h3><p>Error loading. Please refresh.</p></li>';
            });
        }

        // =====================================================
        // ITEM ACTIONS
        // =====================================================
        async function addItem() {
            const text = itemInput.value.trim();
            if (!text || !currentUser) return;

            const listId = lists[currentTab];
            if (!listId) return;

            // For tasks tab - AI categorization with comma support
            if (currentTab !== 'shopping') {
                itemInput.disabled = true;
                const addBtn = document.getElementById('addBtn');
                addBtn.innerHTML = '<span class="btn-spinner"></span>';
                addBtn.disabled = true;

                try {
                    // Check for comma-separated tasks
                    const hasCommas = text.includes(',');
                    const taskTexts = hasCommas
                        ? text.split(',').map(t => t.trim()).filter(t => t.length > 0)
                        : [text];

                    // Check if user manually selected a category
                    if (selectedTaskCategory !== 'auto') {
                        // User manually selected category - use that, but still detect priority via AI
                        for (const taskText of taskTexts) {
                            const aiResult = await smartCategorizeTask(taskText);
                            const finalText = aiResult.text || taskText;
                            const finalPriority = aiResult.priority || 'none';

                            await db.collection('lists').doc(listId).collection('items').add({
                                text: finalText,
                                done: false,
                                category: selectedTaskCategory,
                                priority: finalPriority,
                                createdBy: currentUser.uid,
                                createdByEmail: currentUser.email,
                                createdAt: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        }

                        const cat = TASK_CATEGORIES.find(c => c.id === selectedTaskCategory);
                        if (taskTexts.length > 1) {
                            showToast(`Added ${taskTexts.length} tasks to ${cat?.name || 'Other'}`, 1500);
                        } else {
                            showToast(`${cat?.emoji || ''} Added to ${cat?.name || 'Other'}`, 1500);
                        }
                    } else {
                        // Auto-categorize with AI
                        for (const taskText of taskTexts) {
                            const aiResult = await smartCategorizeTask(taskText);
                            const finalText = aiResult.text || taskText;
                            const finalCategory = aiResult.category || 'other';
                            const finalPriority = aiResult.priority || 'none';

                            await db.collection('lists').doc(listId).collection('items').add({
                                text: finalText,
                                done: false,
                                category: finalCategory,
                                priority: finalPriority,
                                createdBy: currentUser.uid,
                                createdByEmail: currentUser.email,
                                createdAt: firebase.firestore.FieldValue.serverTimestamp()
                            });

                            // Cache the result
                            taskCategoryCache[taskText.toLowerCase().trim()] = aiResult;
                        }
                        saveTaskCategoryCache();

                        if (taskTexts.length > 1) {
                            showToast(`Added ${taskTexts.length} tasks`, 1500);
                        } else {
                            const cat = TASK_CATEGORIES.find(c => c.id === (taskCategoryCache[text.toLowerCase().trim()]?.category || 'other'));
                            showToast(`${cat?.emoji || ''} Added to ${cat?.name || 'Other'}`, 1500);
                        }
                    }

                    itemInput.value = '';
                } catch (error) {
                    console.error('Error adding task:', error);
                    showToast('Failed to add task');
                } finally {
                    itemInput.disabled = false;
                    addBtn.innerHTML = 'Add';
                    addBtn.disabled = false;
                    itemInput.focus();
                }
                return;
            }

            // For shopping tab, use smart categorization with autocorrect
            itemInput.disabled = true;
            const addBtn = document.getElementById('addBtn');
            addBtn.innerHTML = '<span class="btn-spinner"></span>';
            addBtn.disabled = true;

            try {
                // Check for comma-separated items
                const hasCommas = text.includes(',');
                const itemTexts = hasCommas
                    ? text.split(',').map(t => t.trim()).filter(t => t.length > 0)
                    : [text];

                // Parse quantity from each item (before AI processing)
                const parsedItems = itemTexts.map(t => parseQuantity(t));

                // Check if user manually selected a category
                if (selectedAddCategory !== 'auto') {
                    // User manually selected category - still use AI for priority detection
                    for (const parsed of parsedItems) {
                        const aiResult = await smartCategorize(parsed.text);
                        const finalText = aiResult.corrected || parsed.text;
                        const finalPriority = aiResult.priority || 'none';

                        await saveShoppingItem(finalText, selectedAddCategory, finalPriority, parsed.quantity, parsedItems.length > 1);

                        // Save user preference
                        userCategoryPrefs[parsed.text.toLowerCase().trim()] = {
                            corrected: finalText,
                            category: selectedAddCategory,
                            priority: finalPriority
                        };
                    }
                    saveUserCategoryPrefs();
                    itemInput.value = '';

                    if (parsedItems.length > 1) {
                        showToast(`Added ${parsedItems.length} items`, 1500);
                    }

                    // Reset to auto-detect for next item
                    selectedAddCategory = 'auto';
                    document.getElementById('selectedCategoryEmoji').textContent = '';
                } else if (parsedItems.length > 1) {
                    // Multiple items with AI categorization - process all in parallel
                    console.log('[Add] Processing multiple items:', parsedItems);

                    const results = await Promise.all(parsedItems.map(p => smartCategorize(p.text)));

                    for (let i = 0; i < results.length; i++) {
                        const result = results[i];
                        const parsed = parsedItems[i];
                        const needsCorrection = result.corrected.toLowerCase() !== result.original.toLowerCase();
                        const finalText = (needsCorrection && result.confidence === 'high') ? result.corrected : parsed.text;
                        const finalPriority = result.priority || 'none';

                        await saveShoppingItem(finalText, result.category, finalPriority, parsed.quantity, true);

                        // Save preference
                        userCategoryPrefs[parsed.text.toLowerCase()] = {
                            corrected: finalText,
                            category: result.category,
                            priority: finalPriority
                        };
                    }
                    saveUserCategoryPrefs();
                    itemInput.value = '';
                    showToast(`Added ${parsedItems.length} items`, 1500);
                } else {
                    // Single item - use AI categorization with autocorrect modal
                    const parsed = parsedItems[0];
                    const result = await smartCategorize(parsed.text);
                    console.log('[Add] Smart categorize result:', result);

                    const needsCorrection = result.corrected.toLowerCase() !== result.original.toLowerCase();
                    const shouldAskUser = needsCorrection && result.confidence !== 'high';
                    const finalPriority = result.priority || 'none';

                    if (shouldAskUser) {
                        // Show autocorrect modal for user confirmation
                        showAutocorrectModal(result, async (accepted, finalText, finalCategory) => {
                            await saveShoppingItem(finalText, finalCategory, finalPriority, parsed.quantity);
                            if (accepted && finalText !== parsed.text) {
                                userCategoryPrefs[parsed.text.toLowerCase()] = {
                                    corrected: finalText,
                                    category: finalCategory,
                                    priority: finalPriority
                                };
                                saveUserCategoryPrefs();
                            }
                        });
                        itemInput.value = '';
                    } else {
                        // Auto-add (high confidence or no correction needed)
                        const finalText = needsCorrection ? result.corrected : parsed.text;
                        await saveShoppingItem(finalText, result.category, finalPriority, parsed.quantity);
                        itemInput.value = '';

                        if (needsCorrection) {
                            showToast(`Auto-corrected to "${finalText}"`, 2000);
                        }
                    }
                }

            } catch (error) {
                console.error('Error adding item:', error);
                showToast('Failed to add item');
            } finally {
                itemInput.disabled = false;
                addBtn.innerHTML = 'Add';
                addBtn.disabled = false;
                itemInput.focus();
            }
        }

        // Find semantic match (AI-powered multilingual duplicate detection)
        async function findSemanticMatch(newItemText, existingItems) {
            if (!existingItems.length) return null;

            const apiKey = getClaudeApiKey();
            if (!apiKey || !navigator.onLine) return null;

            const existingNames = existingItems.map(i => i.text).join(', ');

            try {
                const response = await fetch(CLAUDE_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: CLAUDE_MODEL,
                        max_tokens: 50,
                        messages: [{
                            role: 'user',
                            content: `Is "${newItemText}" the same grocery item as any of these? (could be different language, spelling variation, or singular/plural)

Existing items: ${existingNames}

Rules:
- "agurk" (Danish) = "Cucumber" (English)  MATCH
- "mlk" (Danish) = "Milk" (English)  MATCH
- "tomatoes" = "Tomato"  MATCH (plural/singular)
- "cheese"  "Milk"  NO MATCH (different items)
- "ost" (Danish cheese)  "Milk"  NO MATCH

If MATCH exists, respond with ONLY the matching item name exactly as written above.
If NO MATCH, respond with only: NONE`
                        }]
                    })
                });

                if (!response.ok) return null;

                const data = await response.json();
                const answer = data.content[0].text.trim();

                console.log(`[SemanticMatch] "${newItemText}" vs [${existingNames}]  "${answer}"`);

                if (answer.toUpperCase() === 'NONE') return null;

                // Find the matching item (case-insensitive)
                return existingItems.find(i =>
                    i.text.toLowerCase() === answer.toLowerCase() ||
                    answer.toLowerCase().includes(i.text.toLowerCase()) ||
                    i.text.toLowerCase().includes(answer.toLowerCase())
                );
            } catch (error) {
                console.error('[SemanticMatch] Error:', error);
                return null;
            }
        }

        // Save shopping item to Firestore (with smart duplicate merging)
        async function saveShoppingItem(text, category, priority = 'none', quantity = 1, silent = false) {
            const listId = lists['shopping'];
            if (!listId) return;

            // Normalize text: "MILK"  "Milk", "milk"  "Milk"
            const normalizedText = normalizeItemText(text);
            console.log(`[saveShoppingItem] text="${text}"  normalized="${normalizedText}", category="${category}", priority="${priority}", quantity=${quantity}`);

            const cat = SHOPPING_CATEGORIES.find(c => c.id === category);

            // Get all uncompleted items for duplicate checking
            const existingSnapshot = await db.collection('lists').doc(listId).collection('items')
                .where('done', '==', false)
                .get();

            // Build list of existing items with their refs
            const existingItems = existingSnapshot.docs.map(doc => ({
                text: doc.data().text || '',
                quantity: doc.data().quantity || 1,
                priority: doc.data().priority || 'none',
                ref: doc.ref
            }));

            // 1. First try exact match (fast, no AI)
            let matchingItem = existingItems.find(i =>
                i.text.toLowerCase() === normalizedText.toLowerCase()
            );

            // 2. If no exact match, try semantic match (AI-powered)
            if (!matchingItem && existingItems.length > 0) {
                matchingItem = await findSemanticMatch(normalizedText, existingItems);
            }

            if (matchingItem) {
                // Merge: Update quantity of existing item
                const newQty = matchingItem.quantity + quantity;
                const newPriority = (priority === 'high' || matchingItem.priority === 'high') ? 'high'
                    : (priority === 'medium' || matchingItem.priority === 'medium') ? 'medium'
                    : 'none';

                await matchingItem.ref.update({
                    quantity: newQty,
                    priority: newPriority
                });

                console.log(`[saveShoppingItem] Merged "${normalizedText}" with existing "${matchingItem.text}"   ${newQty}`);
                if (!silent) {
                    showToast(`${cat?.emoji || ''} ${matchingItem.text}  ${newQty}`, 1500);
                }
            } else {
                // Add new item
                await db.collection('lists').doc(listId).collection('items').add({
                    text: normalizedText,
                    done: false,
                    category: category,
                    priority: priority,
                    quantity: quantity,
                    createdBy: currentUser.uid,
                    createdByEmail: currentUser.email,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                if (!silent) {
                    const qtyText = quantity > 1 ? ` (${quantity})` : '';
                    showToast(`${cat?.emoji || ''} Added to ${cat?.name || 'Other'}${qtyText}`, 1500);
                }
            }
        }

        // =====================================================
        // AUTOCORRECT MODAL
        // =====================================================
        let autocorrectCallback = null;
        let autocorrectResult = null;

        function showAutocorrectModal(result, callback) {
            autocorrectCallback = callback;
            autocorrectResult = result;

            const cat = SHOPPING_CATEGORIES.find(c => c.id === result.category);

            const modal = document.createElement('div');
            modal.className = 'autocorrect-modal-overlay';
            modal.id = 'autocorrectModal';
            modal.innerHTML = `
                <div class="autocorrect-modal">
                    <div class="autocorrect-header">
                        <span class="autocorrect-icon"></span>
                        <h3>Did you mean?</h3>
                    </div>
                    <div class="autocorrect-suggestion">
                        <div class="original">
                            <span class="label">You typed:</span>
                            <span class="value">"${escapeHtml(result.original)}"</span>
                        </div>
                        <div class="arrow"></div>
                        <div class="corrected">
                            <span class="label">Suggested:</span>
                            <span class="value">"${escapeHtml(result.corrected)}"</span>
                        </div>
                    </div>
                    <div class="autocorrect-category">
                        <span class="label">Category:</span>
                        <span class="value">${cat?.emoji || ''} ${cat?.name || 'Other'}</span>
                    </div>
                    <div class="autocorrect-actions">
                        <button class="btn-accept" onclick="acceptCorrection()"> Yes, use "${escapeHtml(result.corrected)}"</button>
                        <button class="btn-keep" onclick="keepOriginal()">Keep "${escapeHtml(result.original)}"</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function acceptCorrection() {
            if (autocorrectCallback && autocorrectResult) {
                autocorrectCallback(true, autocorrectResult.corrected, autocorrectResult.category);
            }
            closeAutocorrectModal();
        }

        function keepOriginal() {
            if (autocorrectCallback && autocorrectResult) {
                autocorrectCallback(false, autocorrectResult.original, autocorrectResult.category);
            }
            closeAutocorrectModal();
        }

        function closeAutocorrectModal() {
            document.getElementById('autocorrectModal')?.remove();
            autocorrectCallback = null;
            autocorrectResult = null;
        }

        // =====================================================
        // LONG-PRESS CATEGORY PICKER
        // =====================================================
        let longPressTimer = null;

        function startLongPress(event, itemId, itemText, category, quantity = 1) {
            longPressTimer = setTimeout(() => {
                if (navigator.vibrate) navigator.vibrate(30);
                showEditItemModal(itemId, itemText, category, quantity);
            }, 500);
        }

        function cancelLongPress() {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
        }

        // =====================================================
        // ADD BAR CATEGORY PICKER
        // =====================================================
        let selectedAddCategory = 'auto'; // 'auto' means AI will detect

        function showAddCategoryPicker() {
            const modal = document.createElement('div');
            modal.className = 'add-category-picker-overlay';
            modal.id = 'addCategoryPickerModal';
            modal.onclick = (e) => {
                if (e.target === modal) closeAddCategoryPicker();
            };

            modal.innerHTML = `
                <div class="add-category-picker-modal">
                    <h3>Select Category</h3>
                    <div class="add-category-options">
                        <button class="add-category-option ${selectedAddCategory === 'auto' ? 'selected' : ''}" onclick="selectAddCategory('auto', '')">
                            <span class="cat-emoji"></span>
                            <span class="cat-name">Auto-detect</span>
                            <span class="cat-desc">AI will categorize</span>
                            ${selectedAddCategory === 'auto' ? '<span class="check"></span>' : ''}
                        </button>
                        ${SHOPPING_CATEGORIES.map(cat => `
                            <button class="add-category-option ${selectedAddCategory === cat.id ? 'selected' : ''}" onclick="selectAddCategory('${cat.id}', '${cat.emoji}')">
                                <span class="cat-emoji">${cat.emoji}</span>
                                <span class="cat-name">${cat.name}</span>
                                ${selectedAddCategory === cat.id ? '<span class="check"></span>' : ''}
                            </button>
                        `).join('')}
                    </div>
                    <button class="cancel-btn" onclick="closeAddCategoryPicker()">Cancel</button>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function closeAddCategoryPicker() {
            document.getElementById('addCategoryPickerModal')?.remove();
        }

        function selectAddCategory(categoryId, emoji) {
            selectedAddCategory = categoryId;
            document.getElementById('selectedCategoryEmoji').textContent = emoji;
            closeAddCategoryPicker();
        }

        // =====================================================
        // TASK CATEGORY PICKER (for add bar)
        // =====================================================
        let selectedTaskCategory = 'home'; // Default to Home

        function showTaskCategoryPicker() {
            const modal = document.createElement('div');
            modal.className = 'add-category-picker-overlay';
            modal.id = 'taskCategoryPickerModal';
            modal.onclick = (e) => {
                if (e.target === modal) closeTaskCategoryPicker();
            };

            // Exclude 'fuckit' from add picker - that's only for moving tasks TO
            const addableCategories = TASK_CATEGORIES.filter(c => c.id !== 'fuckit');

            modal.innerHTML = `
                <div class="add-category-picker-modal">
                    <h3>Select Category</h3>
                    <div class="add-category-options">
                        ${addableCategories.map(cat => `
                            <button class="add-category-option ${selectedTaskCategory === cat.id ? 'selected' : ''}"
                                    onclick="selectTaskCategory('${cat.id}', '${cat.emoji}')">
                                <span class="cat-emoji">${cat.emoji}</span>
                                <span class="cat-name">${cat.name}</span>
                                ${selectedTaskCategory === cat.id ? '<span class="check"></span>' : ''}
                            </button>
                        `).join('')}
                    </div>
                    <button class="cancel-btn" onclick="closeTaskCategoryPicker()">Cancel</button>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function closeTaskCategoryPicker() {
            document.getElementById('taskCategoryPickerModal')?.remove();
        }

        function selectTaskCategory(categoryId, emoji) {
            selectedTaskCategory = categoryId;
            document.getElementById('selectedTaskCategoryEmoji').textContent = emoji;
            closeTaskCategoryPicker();
        }

        // =====================================================
        // TASK LONG-PRESS ACTION MENU
        // =====================================================
        let taskLongPressTimer = null;

        function startTaskLongPress(e, itemId, itemText, itemCategory) {
            taskLongPressTimer = setTimeout(() => {
                if (navigator.vibrate) navigator.vibrate(30);
                showTaskActionMenu(itemId, itemText, itemCategory);
            }, 500);
        }

        function cancelTaskLongPress() {
            if (taskLongPressTimer) {
                clearTimeout(taskLongPressTimer);
                taskLongPressTimer = null;
            }
        }

        function showTaskActionMenu(itemId, itemText, itemCategory) {
            const modal = document.createElement('div');
            modal.className = 'task-action-menu-overlay';
            modal.id = 'taskActionMenuModal';
            modal.onclick = (e) => {
                if (e.target === modal) closeTaskActionMenu();
            };

            modal.innerHTML = `
                <div class="task-action-menu">
                    <div class="task-action-header">
                        <span class="task-action-text">"${escapeHtml(itemText)}"</span>
                    </div>
                    <div class="task-action-options">
                        <button class="task-action-btn edit" onclick="editTaskFromMenu('${itemId}', '${escapeForAttr(itemText)}', '${itemCategory}')">
                            <span class="action-icon"></span>
                            <span class="action-label">Edit Task</span>
                        </button>
                        <button class="task-action-btn fuckit" onclick="moveToFuckitBucket('${itemId}')">
                            <span class="action-icon"></span>
                            <span class="action-label">Fuck It - Not Doing This</span>
                            <span class="action-desc">Let it go guilt-free</span>
                        </button>
                        <button class="task-action-btn delete" onclick="deleteTaskFromMenu('${itemId}')">
                            <span class="action-icon"></span>
                            <span class="action-label">Delete</span>
                        </button>
                    </div>
                    <button class="cancel-btn" onclick="closeTaskActionMenu()">Cancel</button>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function closeTaskActionMenu() {
            document.getElementById('taskActionMenuModal')?.remove();
        }

        function editTaskFromMenu(itemId, itemText, itemCategory) {
            closeTaskActionMenu();
            showEditTaskModal(itemId, itemText, itemCategory);
        }

        async function moveToFuckitBucket(itemId) {
            const listId = lists['tasks'];
            if (!listId) return;

            try {
                await db.collection('lists').doc(listId).collection('items').doc(itemId).update({
                    category: 'fuckit',
                    done: false, // Reset done status
                    fuckitAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                closeTaskActionMenu();

                // Celebration message!
                const messages = [
                    " Freedom! You've released yourself from this task!",
                    " Into the bucket it goes! Zero guilt!",
                    " Letting go is a superpower. Well done!",
                    " One less thing to pretend you'll do!",
                    " Ahhhh... feel that weight lift off!",
                    " The Fuck It Bucket welcomes another!"
                ];
                const msg = messages[Math.floor(Math.random() * messages.length)];
                showToast(msg, 3000);

            } catch (error) {
                console.error('[Fuckit] Error:', error);
                showToast('Failed to move task');
            }
        }

        async function restoreFromFuckit(itemId) {
            const listId = lists['tasks'];
            if (!listId) return;

            try {
                await db.collection('lists').doc(listId).collection('items').doc(itemId).update({
                    category: 'other',
                    fuckitAt: null
                });
                showToast('Task restored! Back to work ');
            } catch (error) {
                console.error('[Restore] Error:', error);
                showToast('Failed to restore');
            }
        }

        async function deleteTaskFromMenu(itemId) {
            if (!confirm('Delete this task permanently?')) return;

            const listId = lists['tasks'];
            if (!listId) return;

            try {
                await db.collection('lists').doc(listId).collection('items').doc(itemId).delete();
                closeTaskActionMenu();
                showToast('Task deleted');
            } catch (error) {
                console.error('[Delete] Error:', error);
                showToast('Failed to delete');
            }
        }

        // =====================================================
        // EDIT TASK MODAL
        // =====================================================
        let currentEditingTaskId = null;

        function showEditTaskModal(itemId, itemText, itemCategory) {
            currentEditingTaskId = itemId;

            const modal = document.createElement('div');
            modal.className = 'edit-item-modal-overlay';
            modal.id = 'editTaskModal';
            modal.onclick = (e) => {
                if (e.target === modal) closeEditTaskModal();
            };

            const categoryOptions = TASK_CATEGORIES
                .filter(c => c.id !== 'fuckit')
                .map(c => `<option value="${c.id}" ${c.id === itemCategory ? 'selected' : ''}>${c.emoji} ${c.name}</option>`)
                .join('');

            modal.innerHTML = `
                <div class="edit-item-modal">
                    <div class="edit-modal-header">
                        <span class="edit-modal-icon"></span>
                        <h3>Edit Task</h3>
                    </div>
                    <div class="edit-modal-field">
                        <label>Task:</label>
                        <input type="text" id="editTaskText" value="${escapeHtml(itemText)}" />
                    </div>
                    <div class="edit-modal-field">
                        <label>Category:</label>
                        <select id="editTaskCategory">${categoryOptions}</select>
                    </div>
                    <div class="edit-modal-buttons">
                        <button class="edit-modal-cancel" onclick="closeEditTaskModal()">Cancel</button>
                        <button class="edit-modal-save" onclick="saveEditedTask()">Save</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            setTimeout(() => {
                document.getElementById('editTaskText')?.focus();
                document.getElementById('editTaskText')?.select();
            }, 100);
        }

        function closeEditTaskModal() {
            document.getElementById('editTaskModal')?.remove();
            currentEditingTaskId = null;
        }

        async function saveEditedTask() {
            if (!currentEditingTaskId) return;

            const newText = document.getElementById('editTaskText').value.trim();
            const newCategory = document.getElementById('editTaskCategory').value;

            if (!newText) {
                showToast('Please enter a task');
                return;
            }

            const listId = lists['tasks'];
            if (!listId) return;

            try {
                await db.collection('lists').doc(listId).collection('items').doc(currentEditingTaskId).update({
                    text: newText,
                    category: newCategory
                });

                closeEditTaskModal();

                const cat = TASK_CATEGORIES.find(c => c.id === newCategory);
                showToast(` Updated! ${cat?.emoji || ''} ${cat?.name || 'Other'}`);

            } catch (error) {
                console.error('[Edit] Error:', error);
                showToast('Failed to save');
            }
        }

        // =====================================================
        // OLD TASK PROMPT (30+ days)
        // =====================================================
        function checkOldTasks(items) {
            const now = new Date();
            const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);

            // Find old incomplete tasks not in fuckit bucket
            const oldTasks = items.filter(item => {
                if (item.done || item.category === 'fuckit') return false;
                if (!item.createdAt) return false;
                const createdDate = item.createdAt.toDate ? item.createdAt.toDate() : new Date(item.createdAt);
                return createdDate < thirtyDaysAgo;
            });

            // Check if we've already prompted for these recently
            const prompted = JSON.parse(localStorage.getItem('oldTasksPrompted') || '{}');
            const today = new Date().toDateString();

            if (prompted.date === today) return; // Only prompt once per day

            // Find one task to prompt about
            const taskToPrompt = oldTasks.find(t => !prompted.ids?.includes(t.id));

            if (taskToPrompt) {
                const createdDate = taskToPrompt.createdAt.toDate ? taskToPrompt.createdAt.toDate() : new Date(taskToPrompt.createdAt);
                const daysOld = Math.floor((now - createdDate) / (1000 * 60 * 60 * 24));

                setTimeout(() => {
                    showOldTaskPrompt(taskToPrompt, daysOld);
                }, 2000); // Delay so it doesn't interrupt loading

                // Mark as prompted
                prompted.date = today;
                prompted.ids = [...(prompted.ids || []), taskToPrompt.id];
                localStorage.setItem('oldTasksPrompted', JSON.stringify(prompted));
            }
        }

        function showOldTaskPrompt(task, daysOld) {
            const modal = document.createElement('div');
            modal.className = 'old-task-prompt-overlay';
            modal.id = 'oldTaskPromptModal';
            modal.onclick = (e) => {
                if (e.target === modal) closeOldTaskPrompt();
            };

            modal.innerHTML = `
                <div class="old-task-prompt">
                    <div class="old-task-icon"></div>
                    <h3>Still happening?</h3>
                    <p class="old-task-text">"${escapeHtml(task.text)}"</p>
                    <p class="old-task-age">This task is <strong>${daysOld} days old</strong></p>
                    <div class="old-task-actions">
                        <button class="btn-keep" onclick="keepOldTask('${task.id}')">
                             Yes, I'll do it
                        </button>
                        <button class="btn-fuckit" onclick="fuckitOldTask('${task.id}')">
                             Fuck it, let it go
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function closeOldTaskPrompt() {
            document.getElementById('oldTaskPromptModal')?.remove();
        }

        function keepOldTask(itemId) {
            closeOldTaskPrompt();
            showToast("Alright, it stays! You've got this ");
        }

        async function fuckitOldTask(itemId) {
            closeOldTaskPrompt();
            await moveToFuckitBucket(itemId);
        }

        function showCategoryPicker(itemId, currentCat) {
            const modal = document.createElement('div');
            modal.className = 'category-picker-overlay';
            modal.id = 'categoryPickerModal';
            modal.onclick = (e) => { if (e.target === modal) closeCategoryPicker(); };
            modal.innerHTML = `
                <div class="category-picker-modal">
                    <h3>Move to category</h3>
                    <div class="category-options">
                        ${SHOPPING_CATEGORIES.map(c => `
                            <button class="category-option ${c.id === currentCat ? 'selected' : ''}"
                                    onclick="moveToCategory('${itemId}', '${c.id}')">
                                <span class="cat-emoji">${c.emoji}</span>
                                <span class="cat-name">${c.name}</span>
                                ${c.id === currentCat ? '<span class="check"></span>' : ''}
                            </button>
                        `).join('')}
                    </div>
                    <button class="cancel-btn" onclick="closeCategoryPicker()">Cancel</button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function closeCategoryPicker() {
            document.getElementById('categoryPickerModal')?.remove();
        }

        async function moveToCategory(itemId, newCategory) {
            const listId = lists['shopping'];
            if (!listId) return;

            try {
                const itemRef = db.collection('lists').doc(listId).collection('items').doc(itemId);
                const doc = await itemRef.get();

                if (doc.exists) {
                    const text = doc.data().text;
                    await itemRef.update({ category: newCategory });

                    // Save user preference for this item
                    userCategoryPrefs[text.toLowerCase()] = {
                        corrected: text,
                        category: newCategory
                    };
                    saveUserCategoryPrefs();

                    const cat = SHOPPING_CATEGORIES.find(c => c.id === newCategory);
                    showToast(`Moved to ${cat?.emoji} ${cat?.name}`, 1500);
                }
            } catch (error) {
                console.error('[Category] Move error:', error);
                showToast('Failed to move item');
            }

            closeCategoryPicker();
        }

        async function toggleItem(itemId, triggerConfetti = true) {
            const listId = lists[currentTab];
            if (!listId) return;

            const itemRef = db.collection('lists').doc(listId).collection('items').doc(itemId);

            try {
                const doc = await itemRef.get();
                if (doc.exists) {
                    const wasNotDone = !doc.data().done;
                    const willBeDone = wasNotDone;

                    // Find the card element (could be .item-card, .task-item, or .shopping-item)
                    const card = document.querySelector(`.item-card[data-id="${itemId}"]`) ||
                                 document.querySelector(`.task-item[data-id="${itemId}"]`) ||
                                 document.querySelector(`.shopping-item[data-id="${itemId}"]`);

                    if (willBeDone) {
                        // Item is being CHECKED - start fade out and schedule deletion
                        if (card) {
                            card.classList.add('completing-swipe');
                            setTimeout(() => card.classList.remove('completing-swipe'), 400);

                            // Trigger confetti celebration
                            if (triggerConfetti) {
                                const rect = card.getBoundingClientRect();
                                confetti(rect.left + rect.width / 2, rect.top + rect.height / 2);
                            }

                            // Start fade-out animation after a brief moment
                            setTimeout(() => {
                                if (card) card.classList.add('fading-out');
                            }, 500);
                        }

                        // Schedule auto-delete after 2 seconds
                        const timeoutId = setTimeout(async () => {
                            pendingDeletions.delete(itemId);
                            try {
                                await db.collection('lists').doc(listId).collection('items').doc(itemId).delete();
                            } catch (err) {
                                console.error('Error auto-deleting item:', err);
                            }
                        }, 2000); // 2s to match 1.5s animation

                        pendingDeletions.set(itemId, timeoutId);

                    } else {
                        // Item is being UNCHECKED - cancel pending deletion (rescue!)
                        if (pendingDeletions.has(itemId)) {
                            clearTimeout(pendingDeletions.get(itemId));
                            pendingDeletions.delete(itemId);
                        }

                        if (card) {
                            card.classList.remove('fading-out');
                        }
                    }

                    await itemRef.update({ done: willBeDone });
                }
            } catch (error) {
                console.error('Error toggling item:', error);
            }
        }

        async function deleteItem(itemId, animate = false) {
            const listId = lists[currentTab];
            if (!listId) return;

            if (animate) {
                const card = document.querySelector(`.item-card[data-id="${itemId}"]`);
                if (card) {
                    card.classList.add('deleting');
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }

            try {
                await db.collection('lists').doc(listId).collection('items').doc(itemId).delete();
            } catch (error) {
                console.error('Error deleting item:', error);
            }
        }

        // Cycle priority: none  high  medium  none
        // With 3-second delay before re-sorting to allow multiple clicks
        async function cyclePriority(itemId) {
            const listId = lists[currentTab];
            if (!listId) return;

            const itemRef = db.collection('lists').doc(listId).collection('items').doc(itemId);

            try {
                const doc = await itemRef.get();
                if (doc.exists) {
                    const currentPriority = doc.data().priority || 'none';
                    let newPriority;

                    if (currentPriority === 'none') newPriority = 'high';
                    else if (currentPriority === 'high') newPriority = 'medium';
                    else newPriority = 'none';

                    // Clear existing timeout if user clicks again within 3 seconds
                    if (pendingPriorityChanges.has(itemId)) {
                        clearTimeout(pendingPriorityChanges.get(itemId).timeoutId);
                    } else {
                        // First click - store the current sort position
                        const card = document.querySelector(`.item-card[data-id="${itemId}"]`);
                        const currentIndex = card ? Array.from(card.parentElement.children).indexOf(card.parentElement) : 0;
                        pendingPriorityChanges.set(itemId, {
                            timeoutId: null,
                            originalIndex: currentIndex,
                            originalPriority: currentPriority
                        });
                    }

                    // Set new timeout to allow re-sort after 3 seconds
                    const timeoutId = setTimeout(() => {
                        pendingPriorityChanges.delete(itemId);
                        // Trigger a re-render to apply new sort order
                        if (unsubscribeItems) {
                            // The onSnapshot will naturally re-render, just remove from pending
                            console.log('[Priority] Re-sort delay complete for', itemId);
                        }
                    }, 3000);

                    pendingPriorityChanges.set(itemId, {
                        ...pendingPriorityChanges.get(itemId),
                        timeoutId: timeoutId
                    });

                    await itemRef.update({ priority: newPriority });

                    // Haptic feedback
                    if (navigator.vibrate) navigator.vibrate(20);
                }
            } catch (error) {
                console.error('Error cycling priority:', error);
            }
        }

        // Clear all completed items
        async function clearCompletedItems() {
            const listId = lists[currentTab];
            if (!listId) return;

            const count = completedCounts[currentTab];
            if (count === 0) return;

            if (!confirm(`Clear ${count} completed item${count !== 1 ? 's' : ''}?`)) {
                return;
            }

            try {
                const itemsRef = db.collection('lists').doc(listId).collection('items');
                const snapshot = await itemsRef.where('done', '==', true).get();

                const batch = db.batch();
                snapshot.forEach(doc => batch.delete(doc.ref));
                await batch.commit();

                showToast(`Cleared ${count} item${count !== 1 ? 's' : ''}`);
            } catch (error) {
                console.error('Error clearing completed:', error);
                showToast('Error clearing items');
            }
        }

        // Clear completed from both lists (profile action)
        async function clearAllCompleted() {
            let totalCleared = 0;

            for (const type of ['tasks', 'shopping']) {
                const listId = lists[type];
                if (!listId) continue;

                try {
                    const itemsRef = db.collection('lists').doc(listId).collection('items');
                    const snapshot = await itemsRef.where('done', '==', true).get();

                    if (!snapshot.empty) {
                        const batch = db.batch();
                        snapshot.forEach(doc => batch.delete(doc.ref));
                        await batch.commit();
                        totalCleared += snapshot.size;
                    }
                } catch (error) {
                    console.error(`Error clearing ${type}:`, error);
                }
            }

            if (totalCleared > 0) {
                showToast(`Cleared ${totalCleared} item${totalCleared !== 1 ? 's' : ''}`);
            } else {
                showToast('No completed items to clear');
            }
        }

        // =====================================================
        // CONFETTI CELEBRATION
        // =====================================================
        function confetti(x, y) {
            const colors = ['#8b5cf6', '#ec4899', '#f97316', '#14b8a6', '#eab308'];
            const particleCount = 18;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'confetti-particle';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.setProperty('--x', (Math.random() - 0.5) * 200 + 'px');
                particle.style.setProperty('--y', (Math.random() * -100 - 50) + 'px');
                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 800);
            }
        }

        // =====================================================
        // SWIPE GESTURES
        // =====================================================
        function initSwipeHandlers() {
            const itemList = document.getElementById('itemList');
            const cards = itemList.querySelectorAll('.item-card');

            cards.forEach(card => {
                let startX = 0;
                let currentX = 0;
                let isDragging = false;
                const threshold = 0.4; // 40% of card width

                const handleStart = (clientX) => {
                    startX = clientX;
                    currentX = clientX;
                    isDragging = true;
                    card.classList.add('swiping');
                    card.classList.remove('snapping');
                };

                const handleMove = (clientX) => {
                    if (!isDragging) return;
                    currentX = clientX;
                    const deltaX = currentX - startX;
                    card.style.transform = `translateX(${deltaX}px)`;
                };

                const handleEnd = async () => {
                    if (!isDragging) return;
                    isDragging = false;
                    card.classList.remove('swiping');

                    const deltaX = currentX - startX;
                    const cardWidth = card.offsetWidth;
                    const itemId = card.dataset.id;

                    // Swipe right (complete)
                    if (deltaX > cardWidth * threshold) {
                        card.classList.add('snapping');
                        card.style.transform = 'translateX(0)';
                        await toggleItem(itemId, true);
                    }
                    // Swipe left (delete)
                    else if (deltaX < -cardWidth * threshold) {
                        await deleteItem(itemId, true);
                    }
                    // Snap back
                    else {
                        card.classList.add('snapping');
                        card.style.transform = 'translateX(0)';
                    }
                };

                // Touch events
                card.addEventListener('touchstart', (e) => {
                    handleStart(e.touches[0].clientX);
                }, { passive: true });

                card.addEventListener('touchmove', (e) => {
                    handleMove(e.touches[0].clientX);
                }, { passive: true });

                card.addEventListener('touchend', handleEnd);

                // Mouse events (desktop fallback)
                card.addEventListener('mousedown', (e) => {
                    if (e.target.closest('[data-action]')) return; // Ignore button clicks
                    handleStart(e.clientX);
                });

                card.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        handleMove(e.clientX);
                    }
                });

                card.addEventListener('mouseup', handleEnd);
                card.addEventListener('mouseleave', () => {
                    if (isDragging) {
                        isDragging = false;
                        card.classList.remove('swiping');
                        card.classList.add('snapping');
                        card.style.transform = 'translateX(0)';
                    }
                });
            });
        }

        // =====================================================
        // PULL TO REFRESH
        // =====================================================
        let pullStartY = 0;
        let isPulling = false;
        let pullIndicator;

        function initPullToRefresh() {
            const content = document.getElementById('listContent');
            pullIndicator = document.getElementById('pullIndicator');

            content.addEventListener('touchstart', (e) => {
                if (content.scrollTop === 0) {
                    pullStartY = e.touches[0].clientY;
                    isPulling = true;
                }
            }, { passive: true });

            content.addEventListener('touchmove', (e) => {
                if (!isPulling) return;
                const deltaY = e.touches[0].clientY - pullStartY;

                if (deltaY > 0 && deltaY < 180) {
                    pullIndicator.style.height = Math.min(deltaY * 0.5, 70) + 'px';
                    pullIndicator.style.opacity = Math.min(deltaY / 120, 1);
                }
            }, { passive: true });

            content.addEventListener('touchend', async () => {
                if (!isPulling) return;

                // Increased threshold to 120px to prevent accidental triggers
                const pullDistance = parseInt(pullIndicator.style.height) || 0;
                if (pullDistance > 60) { // 60px visible = 120px pull
                    // Show refreshing state
                    pullIndicator.classList.add('refreshing');
                    pullIndicator.style.height = '50px';
                    pullIndicator.style.opacity = '1';

                    // Refresh data (re-subscribe to items)
                    await new Promise(resolve => setTimeout(resolve, 300)); // Min feedback time
                    subscribeToItems();

                    // Hide after a moment
                    setTimeout(() => {
                        pullIndicator.classList.remove('refreshing');
                        pullIndicator.style.height = '0';
                        pullIndicator.style.opacity = '0';
                    }, 500);
                } else {
                    pullIndicator.style.height = '0';
                    pullIndicator.style.opacity = '0';
                }

                isPulling = false;
            });
        }

        // =====================================================
        // HOUSEHOLD MEMBERS (v5.1.0)
        // =====================================================
        function renderCollaborators(data) {
            // In household model, everyone can invite and remove
            inviteSection.style.display = 'block';

            // Get other household members (not self)
            const members = SharingModule.getCollaborators(data);

            if (members.length === 0) {
                collaboratorList.innerHTML = '<li class="no-collaborators">Just you for now</li>';
                return;
            }

            const html = members.map(member => {
                const displayName = member.displayName || member.email?.split('@')[0] || 'Unknown';
                const initial = displayName[0].toUpperCase();

                return `
                    <li class="collaborator-item">
                        <div class="collaborator-info">
                            <div class="collaborator-avatar">${escapeHtml(initial)}</div>
                            <div>
                                <div class="collaborator-email">${escapeHtml(displayName)}</div>
                                <div class="collaborator-role">${escapeHtml(member.email || '')}</div>
                            </div>
                        </div>
                        <button class="remove-collaborator" data-id="${member.id}">Remove</button>
                    </li>
                `;
            }).join('');

            collaboratorList.innerHTML = html;
        }

        function showShareMessage(message, type) {
            shareMessage.textContent = message;
            shareMessage.className = `share-message ${type}`;
            setTimeout(() => {
                shareMessage.className = 'share-message';
            }, 4000);
        }

        // =====================================================
        // AUTH EVENT LISTENERS
        // =====================================================
        document.querySelectorAll('.auth-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.auth-form').forEach(f => f.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab + 'Form').classList.add('active');
                authError.classList.remove('show');
            });
        });

        document.getElementById('loginBtn').addEventListener('click', async () => {
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;

            if (!email || !password) {
                showError('Please enter email and password');
                return;
            }

            try {
                await auth.signInWithEmailAndPassword(email, password);
            } catch (error) {
                showError(error.message);
            }
        });

        document.getElementById('signupBtn').addEventListener('click', async () => {
            const email = document.getElementById('signupEmail').value.trim();
            const password = document.getElementById('signupPassword').value;

            if (!email || !password) {
                showError('Please enter email and password');
                return;
            }

            if (password.length < 6) {
                showError('Password must be at least 6 characters');
                return;
            }

            try {
                await auth.createUserWithEmailAndPassword(email, password);
            } catch (error) {
                showError(error.message);
            }
        });

        document.getElementById('googleBtn').addEventListener('click', async () => {
            const provider = new firebase.auth.GoogleAuthProvider();
            try {
                await auth.signInWithPopup(provider);
            } catch (error) {
                showError(error.message);
            }
        });

        document.getElementById('logoutBtn').addEventListener('click', () => {
            auth.signOut();
        });

        document.getElementById('loginPassword').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') document.getElementById('loginBtn').click();
        });

        document.getElementById('signupPassword').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') document.getElementById('signupBtn').click();
        });

        // =====================================================
        // AUTH STATE OBSERVER
        // =====================================================
        auth.onAuthStateChanged(async (user) => {
            currentUser = user;

            if (user) {
                authContainer.style.display = 'none';
                appContainer.classList.add('active');

                await SharingModule.saveUserProfile(user);

                // Load user profile and check onboarding status
                const onboardingComplete = await loadUserProfile();
                updateProfileUI();

                // Initialize event handlers BEFORE showing onboarding
                initPullToRefresh();
                initOnboarding();
                initProfileHandlers();

                // Show onboarding for new users
                if (!onboardingComplete) {
                    console.log('[Onboarding] New user detected, showing onboarding');
                    showOnboarding();
                }

                // Initialize household and lists (v5.1.0 clean model)
                await initializeLists();

                switchTab('tasks');
            } else {
                authContainer.style.display = 'block';
                appContainer.classList.remove('active');
                hideOnboarding();
                lists = { tasks: null, shopping: null };
                listData = { tasks: null, shopping: null };
                currentTab = 'tasks';

                // Reset profile
                userProfile = {
                    displayName: '',
                    avatar: '&#128512;',
                    personality: 'subtle'
                };

                if (unsubscribeItems) {
                    unsubscribeItems();
                    unsubscribeItems = null;
                }
                if (unsubscribeList) {
                    unsubscribeList();
                    unsubscribeList = null;
                }
            }
        });

        // =====================================================
        // NAV EVENT LISTENERS
        // =====================================================
        document.querySelectorAll('.nav-item').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });

        // =====================================================
        // ITEM EVENT LISTENERS
        // =====================================================
        console.log('[Init] Setting up event listeners...');

        document.getElementById('addBtn')?.addEventListener('click', addItem);
        console.log('[Init] Add button listener attached');

        itemInput?.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addItem();
        });
        console.log('[Init] Item input listener attached');

        document.getElementById('itemList').addEventListener('click', (e) => {
            // Handle clear completed button
            if (e.target.closest('#clearCompletedBtn')) {
                clearCompletedItems();
                return;
            }

            // Handle flat list (.item-card), shopping (.shopping-item), and tasks (.task-item)
            const card = e.target.closest('.item-card') || e.target.closest('.shopping-item') || e.target.closest('.task-item');
            if (!card) return;

            const itemId = card.dataset.id;
            const action = e.target.closest('[data-action]')?.dataset.action;

            if (action === 'delete') {
                deleteItem(itemId, true); // Animate deletion
            } else if (action === 'priority') {
                cyclePriority(itemId); // Cycle priority
            } else if (action === 'toggle' || e.target.closest('.item-content') || e.target.closest('.item-checkbox')) {
                toggleItem(itemId, true); // Trigger confetti
            }
        });

        // =====================================================
        // SHARE MODAL EVENT LISTENERS
        // =====================================================
        shareBtn.addEventListener('click', () => {
            const data = listData[currentTab];
            if (data) {
                renderCollaborators(data);
            }
            shareModal.classList.add('active');
            inviteEmail.value = '';
            shareMessage.className = 'share-message';
        });

        document.getElementById('manageSharingBtn').addEventListener('click', () => {
            // Switch to tasks tab and open share modal
            switchTab('tasks');
            setTimeout(() => {
                const data = listData[currentTab];
                if (data) {
                    renderCollaborators(data);
                }
                shareModal.classList.add('active');
            }, 100);
        });

        document.getElementById('clearAllCompletedBtn').addEventListener('click', async () => {
            if (!confirm('Clear all completed items from both Tasks and Shopping lists?')) {
                return;
            }
            await clearAllCompleted();
        });

        modalClose.addEventListener('click', () => {
            shareModal.classList.remove('active');
        });

        shareModal.addEventListener('click', (e) => {
            if (e.target === shareModal) {
                shareModal.classList.remove('active');
            }
        });

        console.log('[Init] Invite button element:', inviteBtn);
        inviteBtn?.addEventListener('click', async () => {
            console.log('[Invite] Button clicked');
            const email = inviteEmail.value.trim().toLowerCase();

            if (!email) {
                showShareMessage('Please enter an email address.', 'error');
                return;
            }

            if (!email.includes('@') || !email.includes('.')) {
                showShareMessage('Please enter a valid email.', 'error');
                return;
            }

            const listId = lists[currentTab];
            console.log('[Invite] List ID:', listId);
            if (!listId) {
                showShareMessage('No list selected. Please try again.', 'error');
                return;
            }

            inviteBtn.disabled = true;
            inviteBtn.textContent = '...';

            try {
                const member = await SharingModule.addCollaborator(listId, email);
                const name = member.displayName || member.email?.split('@')[0] || 'New member';
                showShareMessage(`${name} joined your household!`, 'success');
                inviteEmail.value = '';

                // Refresh household data
                if (currentHousehold) {
                    currentHousehold = await HouseholdModule.getHousehold(currentHousehold.id);
                }
                renderCollaborators({});
            } catch (error) {
                showShareMessage(error.message, 'error');
            } finally {
                inviteBtn.disabled = false;
                inviteBtn.textContent = 'Invite';
            }
        });

        inviteEmail.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') inviteBtn.click();
        });

        collaboratorList.addEventListener('click', async (e) => {
            const removeBtn = e.target.closest('.remove-collaborator');
            if (!removeBtn) return;

            const collaboratorId = removeBtn.dataset.id;
            const listId = lists[currentTab];

            if (!listId || !collaboratorId) return;

            removeBtn.disabled = true;
            removeBtn.textContent = '...';

            try {
                await SharingModule.removeCollaborator(listId, collaboratorId);
                // Refresh household data
                if (currentHousehold) {
                    currentHousehold = await HouseholdModule.getHousehold(currentHousehold.id);
                }
                renderCollaborators({});
                showShareMessage('Member removed from household.', 'success');
            } catch (error) {
                showShareMessage(error.message, 'error');
                removeBtn.disabled = false;
                removeBtn.textContent = 'Remove';
            }
        });

        console.log('[Init] All event listeners attached successfully');
    </script>
</body>
</html>
