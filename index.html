<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#FDFCF4">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Mysa">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    <title>Mysa</title>
    <style>
        :root {
            /* NEW WARM DESIGN - Cream & Sage Theme */
            --bg-app: #FDFCF4;
            --bg-primary: #FDFCF4;
            --bg-secondary: #F5F3ED;
            --bg-card: #FFFFFF;
            --surface-card: #FFFFFF;

            /* Accent colors - Warm palette */
            --color-sage: #C4E7D6;
            --color-lavender: #E8DEF8;
            --color-peach: #FFD8CA;
            --color-slate: #303030;
            --color-blue: #D0E4FF;
            --accent-primary: #303030;
            --accent-secondary: #303030;
            --accent-success: #146C2E;
            --accent-check: #146C2E;
            --accent-danger: #B3261E;
            --accent-orange: #FF8A65;

            /* Text */
            --text-primary: #1A1C1E;
            --text-secondary: #444746;
            --text-tertiary: #747775;
            --text-muted: #747775;
            --text-on-dark: #F2F0F4;

            /* Radius - More rounded */
            --radius-xl: 28px;
            --radius-lg: 20px;
            --radius-md: 12px;
            --radius-sm: 8px;
            --radius-pill: 100px;

            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;

            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.08);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
            --shadow-float: 0 8px 24px rgba(0,0,0,0.12);

            /* Legacy support */
            --gradient-header: linear-gradient(135deg, #303030 0%, #505050 100%);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            overscroll-behavior: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-app);
            min-height: 100vh;
            color: var(--text-primary);
        }

        /* Disable text selection on UI elements */
        .nav-item, .btn, .priority-dot, .item-checkbox, .add-btn, .auth-btn {
            -webkit-user-select: none;
            user-select: none;
        }

        /* Container */
        .container {
            max-width: 480px;
            margin: 0 auto;
            min-height: 100vh;
            background: var(--bg-app);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Header - Warm minimal design */
        .header {
            background: var(--bg-app);
            padding: var(--space-lg);
            padding-top: calc(var(--space-lg) + env(safe-area-inset-top));
            color: var(--text-primary);
            position: relative;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left h1 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 2px;
            color: var(--text-primary);
        }

        .header-subtitle {
            font-size: 14px;
            color: var(--text-tertiary);
            font-weight: 500;
        }

        .share-btn {
            background: var(--surface-card);
            border: none;
            color: var(--text-secondary);
            width: 48px;
            height: 48px;
            border-radius: var(--radius-pill);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }

        .share-btn:hover {
            background: var(--bg-secondary);
            transform: scale(1.05);
        }

        .share-btn:active {
            transform: scale(0.98);
        }

        .share-btn.has-collaborators {
            background: var(--color-sage);
            color: var(--accent-check);
        }

        /* Auth Styles */
        .auth-container {
            padding: 30px 20px;
            flex: 1;
        }

        .auth-container h2 {
            text-align: center;
            margin-bottom: 25px;
            color: var(--text-primary);
            font-size: 24px;
        }

        .auth-tabs {
            display: flex;
            margin-bottom: 20px;
            gap: 10px;
        }

        .auth-tab {
            flex: 1;
            padding: 12px;
            border: none;
            background: var(--bg-secondary);
            border-radius: var(--radius-pill);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .auth-tab.active {
            background: var(--color-slate);
            color: white;
        }

        .auth-form {
            display: none;
        }

        .auth-form.active {
            display: block;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .form-group input {
            width: 100%;
            padding: 14px 16px;
            font-size: 16px;
            border: 2px solid #e5e7eb;
            border-radius: var(--radius-md);
            outline: none;
            transition: border-color 0.2s ease;
            background: var(--bg-card);
        }

        .form-group input:focus {
            border-color: var(--accent-primary);
        }

        .auth-btn {
            width: 100%;
            padding: 14px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: var(--radius-pill);
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 8px;
        }

        .auth-btn.primary {
            background: var(--color-slate);
            color: white;
        }

        .auth-btn.primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .auth-btn.google {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 2px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .auth-btn.google:hover {
            background: var(--bg-secondary);
        }

        .google-icon {
            width: 20px;
            height: 20px;
        }

        .divider {
            text-align: center;
            color: var(--text-muted);
            margin: 20px 0;
            position: relative;
        }

        .divider::before,
        .divider::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40%;
            height: 1px;
            background: #e5e7eb;
        }

        .divider::before { left: 0; }
        .divider::after { right: 0; }

        .error-message {
            background: #fef2f2;
            color: var(--accent-danger);
            padding: 12px 16px;
            border-radius: 12px;
            margin-bottom: 16px;
            font-size: 14px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        /* App Container */
        .app-container {
            display: none;
            flex: 1;
            flex-direction: column;
        }

        .app-container.active {
            display: flex;
        }

        /* Content Area */
        .content {
            flex: 1;
            padding: 16px;
            padding-bottom: calc(180px + env(safe-area-inset-bottom));
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* Pull to Refresh */
        .pull-indicator {
            height: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 14px;
            transition: opacity 0.2s ease;
            opacity: 0;
        }

        .pull-indicator.refreshing {
            height: 50px;
            opacity: 1;
        }

        .pull-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid var(--bg-secondary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Item Cards */
        .items-list {
            list-style: none;
        }

        /* Swipe Container */
        .swipe-container {
            position: relative;
            margin-bottom: 12px;
            border-radius: var(--radius-lg);
            overflow: hidden;
        }

        .swipe-reveal {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
            display: flex;
            align-items: center;
            font-size: 24px;
            color: white;
            pointer-events: none;
        }

        .swipe-reveal-complete {
            left: 0;
            background: #f0fdf4;
            color: var(--accent-success);
            padding-left: 20px;
            justify-content: flex-start;
        }

        .swipe-reveal-delete {
            right: 0;
            background: #fef2f2;
            color: var(--accent-danger);
            padding-right: 20px;
            justify-content: flex-end;
        }

        .item-card {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: 16px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            box-shadow: var(--shadow-md);
            position: relative;
            touch-action: pan-y;
            user-select: none;
            will-change: transform;
        }

        .item-card.swiping {
            transition: none !important;
        }

        .item-card.snapping {
            transition: transform 0.2s ease !important;
        }

        .item-card.deleting {
            transition: transform 0.3s ease, opacity 0.3s ease !important;
            transform: translateX(-100%) !important;
            opacity: 0 !important;
        }

        .item-card.completing-swipe {
            animation: complete-flash-swipe 0.4s ease;
        }

        @keyframes complete-flash-swipe {
            0% { background-color: var(--bg-card); }
            50% { background-color: #d1fae5; transform: scale(1.02); }
            100% { background-color: var(--bg-card); transform: scale(1); }
        }

        .item-checkbox {
            width: 24px;
            height: 24px;
            border: 2px solid #d1d5db;
            border-radius: var(--radius-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .item-checkbox:hover {
            border-color: var(--accent-success);
        }

        .item-card.done .item-checkbox {
            background: var(--color-sage);
            border-color: var(--color-sage);
            transform: scale(1.05);
        }

        .item-checkbox-icon {
            color: var(--accent-check);
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .item-card.done .item-checkbox-icon {
            opacity: 1;
        }

        /* Priority Button (right side) */
        .priority-btn {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            margin: -8px -8px -8px 0;
            flex-shrink: 0;
        }

        .priority-btn:active .priority-dot {
            transform: scale(1.3);
        }

        .priority-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            transition: transform 0.15s ease, background-color 0.2s ease;
        }

        .priority-dot.priority-high {
            background: #fca5a5;
        }

        .priority-dot.priority-medium {
            background: #fcd34d;
        }

        .priority-dot.priority-none {
            background: #e5e7eb;
        }

        /* Edit Item Modal */
        .edit-item-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 20px;
        }

        .edit-item-modal {
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            padding: 24px;
            width: 100%;
            max-width: 360px;
            box-shadow: var(--shadow-float);
        }

        .edit-modal-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .edit-modal-icon {
            font-size: 40px;
            display: block;
            margin-bottom: 8px;
        }

        .edit-modal-header h3 {
            margin: 0;
            font-size: 20px;
            color: #1f2937;
        }

        .edit-modal-field {
            margin-bottom: 20px;
        }

        .edit-modal-field label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .edit-modal-field input,
        .edit-modal-field select {
            width: 100%;
            padding: 14px 16px;
            font-size: 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            background: white;
            color: #1f2937;
            box-sizing: border-box;
        }

        .edit-modal-field input:focus,
        .edit-modal-field select:focus {
            outline: none;
            border-color: var(--color-slate);
        }

        .edit-modal-field select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236b7280' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 16px center;
            padding-right: 40px;
        }

        .edit-modal-buttons {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .edit-modal-buttons button {
            flex: 1;
            padding: 14px 20px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: var(--radius-pill);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .edit-modal-buttons button:active {
            transform: scale(0.98);
        }

        .edit-modal-cancel {
            background: var(--bg-secondary);
            color: var(--text-secondary);
        }

        .edit-modal-save {
            background: var(--color-slate);
            color: white;
        }

        .item-content {
            flex: 1;
            min-width: 0;
        }

        .item-text {
            font-size: 16px;
            font-weight: 500;
            color: var(--text-primary);
            word-break: break-word;
            transition: all 0.2s ease;
        }

        .item-card.done .item-text {
            text-decoration: line-through;
            opacity: 0.5;
        }

        .item-meta {
            display: none !important; /* Hidden - cleaner look */
        }


        /* Enhanced Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            text-align: center;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .empty-state h3 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .empty-state p {
            font-size: 14px;
            color: var(--text-muted);
            max-width: 250px;
        }

        /* Loading Skeletons */
        .skeleton-container {
            display: none;
        }

        .skeleton-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: var(--bg-card);
            border-radius: 12px;
            margin-bottom: 12px;
        }

        .skeleton-checkbox {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-shimmer 1.5s infinite;
        }

        .skeleton-content {
            flex: 1;
        }

        .skeleton-title {
            height: 16px;
            width: 65%;
            border-radius: 4px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-shimmer 1.5s infinite;
            margin-bottom: 8px;
        }

        .skeleton-subtitle {
            height: 12px;
            width: 35%;
            border-radius: 4px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-shimmer 1.5s infinite;
        }

        @keyframes skeleton-shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        /* Confetti */
        .confetti-particle {
            position: fixed;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            animation: confetti-fall 0.8s ease-out forwards;
        }

        @keyframes confetti-fall {
            0% {
                transform: translate(0, 0) rotate(0deg) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--x), calc(var(--y) + 200px)) rotate(720deg) scale(0);
                opacity: 0;
            }
        }

        .loading-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }

        /* Add Input */
        .add-input-container {
            position: fixed;
            bottom: calc(96px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 32px);
            max-width: 448px;
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow-float);
            display: flex;
            padding: 10px;
            gap: 10px;
            z-index: 100;
        }

        .add-input {
            flex: 1;
            border: none;
            outline: none;
            padding: 14px 18px;
            font-size: 16px;
            background: var(--bg-secondary);
            border-radius: var(--radius-pill);
        }

        .add-input::placeholder {
            color: var(--text-muted);
        }

        .add-btn {
            background: var(--color-slate);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: var(--radius-pill);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }

        .add-btn:hover {
            opacity: 0.9;
            transform: scale(1.02);
        }

        /* Category Picker in Add Bar */
        .add-input-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            background: var(--bg-secondary);
            border-radius: var(--radius-pill);
            padding: 0 4px 0 0;
        }

        .add-input-wrapper .add-input {
            background: none;
            border-radius: 0;
        }

        .category-picker-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: white;
            border-radius: var(--radius-pill);
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-sm);
            transition: transform 0.2s;
            flex-shrink: 0;
        }

        .category-picker-btn:active {
            transform: scale(0.95);
        }

        /* Category Picker Modal */
        .add-category-picker-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            z-index: 9999;
        }

        .add-category-picker-modal {
            background: var(--bg-card);
            border-radius: var(--radius-xl) var(--radius-xl) 0 0;
            padding: 20px;
            width: 100%;
            max-width: 500px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .add-category-picker-modal h3 {
            text-align: center;
            margin: 0 0 16px 0;
            font-size: 18px;
            color: #1f2937;
        }

        .add-category-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .add-category-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
        }

        .add-category-option:active {
            background: #f3f4f6;
        }

        .add-category-option.selected {
            border-color: #8b5cf6;
            background: #f3e8ff;
        }

        .add-category-option .cat-emoji {
            font-size: 24px;
            width: 32px;
            text-align: center;
        }

        .add-category-option .cat-name {
            flex: 1;
            font-weight: 600;
            font-size: 15px;
            color: #1f2937;
        }

        .add-category-option .cat-desc {
            font-size: 12px;
            color: #6b7280;
        }

        .add-category-option .check {
            color: #8b5cf6;
            font-weight: bold;
            font-size: 18px;
        }

        .add-category-picker-modal .cancel-btn {
            width: 100%;
            margin-top: 16px;
            padding: 16px;
            border: none;
            border-radius: 12px;
            background: #f3f4f6;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        /* Task Action Menu */
        .task-action-menu-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            z-index: 9999;
        }

        .task-action-menu {
            background: white;
            border-radius: 20px 20px 0 0;
            padding: 20px;
            width: 100%;
            max-width: 500px;
        }

        .task-action-header {
            text-align: center;
            padding-bottom: 16px;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 16px;
        }

        .task-action-text {
            font-size: 16px;
            color: #374151;
            font-style: italic;
        }

        .task-action-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .task-action-btn {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px;
            border: none;
            border-radius: 12px;
            background: #f9fafb;
            cursor: pointer;
            text-align: left;
            transition: background 0.2s;
        }

        .task-action-btn:active {
            background: #f3f4f6;
        }

        .task-action-btn .action-icon {
            font-size: 24px;
        }

        .task-action-btn .action-label {
            flex: 1;
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
        }

        .task-action-btn .action-desc {
            font-size: 12px;
            color: #6b7280;
        }

        .task-action-btn.fuckit {
            background: #fef3c7;
        }

        .task-action-btn.fuckit:active {
            background: #fde68a;
        }

        .task-action-btn.delete {
            background: #fee2e2;
        }

        .task-action-btn.delete:active {
            background: #fecaca;
        }

        /* Fuck It Bucket section styling */
        .fuckit-section {
            margin-top: 24px;
            opacity: 0.85;
        }

        .fuckit-header {
            background: linear-gradient(135deg, #fef3c7, #fde68a) !important;
        }

        .fuckit-item {
            background: #fffbeb !important;
        }

        .fuckit-item .item-text {
            text-decoration: line-through;
            color: #9ca3af !important;
        }

        .restore-btn {
            background: none;
            border: none;
            font-size: 18px;
            padding: 8px;
            cursor: pointer;
        }

        /* Old task prompt */
        .old-task-prompt-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 20px;
        }

        .old-task-prompt {
            background: white;
            border-radius: 20px;
            padding: 24px;
            text-align: center;
            max-width: 340px;
            width: 100%;
        }

        .old-task-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .old-task-prompt h3 {
            margin: 0 0 16px 0;
            font-size: 20px;
        }

        .old-task-text {
            font-size: 16px;
            color: #374151;
            font-style: italic;
            margin-bottom: 8px;
        }

        .old-task-age {
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 24px;
        }

        .old-task-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .old-task-actions button {
            padding: 14px 20px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
        }

        .btn-keep {
            background: #10b981;
            color: white;
        }

        .btn-fuckit {
            background: #fef3c7;
            color: #92400e;
        }

        /* Bottom Navigation - Floating Pill Style */
        .bottom-nav {
            position: fixed;
            bottom: calc(16px + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 32px);
            max-width: 400px;
            height: 64px;
            background: var(--bg-card);
            box-shadow: var(--shadow-float);
            border-radius: var(--radius-pill);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 200;
        }

        .nav-item {
            background: none;
            border: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 20px;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.2s ease;
        }

        .nav-item:active {
            opacity: 0.7;
        }

        .nav-item.active {
            color: var(--accent-primary);
        }

        /* Clear Completed Button */
        .clear-completed-btn {
            display: none;
            width: 100%;
            padding: 12px;
            margin-top: 16px;
            background: var(--bg-secondary);
            border: 1px dashed #d1d5db;
            border-radius: 12px;
            color: var(--text-muted);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .clear-completed-btn:hover {
            background: #f3f4f6;
            color: var(--text-secondary);
        }

        .clear-completed-btn.visible {
            display: block;
        }

        /* Offline Indicator */
        .offline-indicator {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #fbbf24;
            color: #78350f;
            text-align: center;
            padding: 8px;
            font-size: 13px;
            font-weight: 500;
            z-index: 9999;
            transform: translateY(-100%);
            transition: transform 0.3s ease;
        }

        .offline-indicator.visible {
            transform: translateY(0);
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: var(--text-primary);
            color: white;
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 14px;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 9999;
            pointer-events: none;
        }

        .toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .nav-icon {
            font-size: 24px;
        }

        .nav-label {
            font-size: 12px;
            font-weight: 500;
        }

        /* Profile Tab */
        .profile-content {
            padding: 20px 16px;
            padding-bottom: calc(140px + env(safe-area-inset-bottom));
            display: none;
            overflow-y: auto;
            height: 100%;
        }

        .profile-content.active {
            display: block;
        }

        .profile-header {
            text-align: center;
            padding: 20px 0 30px;
        }

        .profile-avatar {
            width: 80px;
            height: 80px;
            background: var(--gradient-header);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
            font-size: 32px;
            color: white;
        }

        .profile-email {
            font-size: 16px;
            color: var(--text-primary);
            font-weight: 500;
        }

        .profile-menu {
            list-style: none;
        }

        .profile-menu-item {
            background: var(--bg-card);
            border-radius: 12px;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .profile-menu-btn {
            width: 100%;
            padding: 16px 20px;
            background: none;
            border: none;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            font-size: 16px;
            color: var(--text-primary);
            transition: background 0.2s ease;
        }

        .profile-menu-btn:hover {
            background: var(--bg-secondary);
        }

        .profile-menu-btn.danger {
            color: var(--accent-danger);
        }

        .profile-menu-icon {
            font-size: 20px;
        }

        /* Share Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .share-modal {
            background: var(--bg-card);
            border-radius: var(--radius-xl);
            width: 100%;
            max-width: 400px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-float);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
        }

        .invite-section {
            margin-bottom: 24px;
        }

        .invite-section label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .invite-input-group {
            display: flex;
            gap: 8px;
        }

        .invite-input-group input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: var(--radius-md);
            font-size: 16px;
            outline: none;
        }

        .invite-input-group input:focus {
            border-color: var(--accent-primary);
        }

        .invite-btn {
            background: var(--color-slate);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: var(--radius-pill);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
        }

        .invite-btn:disabled {
            opacity: 0.5;
        }

        .share-message {
            margin-top: 12px;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        .share-message.success {
            display: block;
            background: #d1fae5;
            color: #065f46;
        }

        .share-message.error {
            display: block;
            background: #fef2f2;
            color: var(--accent-danger);
        }

        .collaborators-section h3 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .collaborator-list {
            list-style: none;
        }

        .collaborator-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #f3f4f6;
        }

        .collaborator-item:last-child {
            border-bottom: none;
        }

        .collaborator-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .collaborator-avatar {
            width: 40px;
            height: 40px;
            background: var(--bg-secondary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .collaborator-email {
            font-size: 14px;
            font-weight: 500;
        }

        .collaborator-role {
            font-size: 12px;
            color: var(--text-muted);
        }

        .remove-collaborator {
            background: none;
            border: none;
            color: var(--accent-danger);
            font-size: 13px;
            cursor: pointer;
            padding: 6px 12px;
        }

        .owner-badge {
            background: var(--bg-secondary);
            color: var(--text-muted);
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 20px;
        }

        .no-collaborators {
            color: var(--text-muted);
            font-size: 14px;
            text-align: center;
            padding: 20px;
        }

        /* Hide elements based on state */
        .hidden {
            display: none !important;
        }

        /* Responsive */
        @media (max-width: 480px) {
            .invite-input-group {
                flex-direction: column;
            }

            .invite-btn {
                width: 100%;
            }
        }

        /* =====================================================
           ONBOARDING STYLES
           ===================================================== */
        .onboarding-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            z-index: 10000;
            display: none;
            flex-direction: column;
        }

        .onboarding-overlay.active {
            display: flex;
        }

        .onboarding-screen {
            flex: 1;
            display: none;
            flex-direction: column;
            padding: 40px 24px;
            padding-top: calc(60px + env(safe-area-inset-top));
            padding-bottom: calc(120px + env(safe-area-inset-bottom));
            overflow-y: auto;
        }

        .onboarding-screen.active {
            display: flex;
        }

        .onboarding-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .onboarding-icon {
            font-size: 64px;
            margin-bottom: 24px;
        }

        .onboarding-title {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 12px;
        }

        .onboarding-subtitle {
            font-size: 16px;
            color: var(--text-secondary);
            line-height: 1.5;
            max-width: 300px;
            margin: 0 auto;
        }

        .onboarding-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .onboarding-input {
            width: 100%;
            max-width: 320px;
            padding: 16px 20px;
            font-size: 18px;
            border: 2px solid #e5e7eb;
            border-radius: 16px;
            outline: none;
            text-align: center;
            transition: border-color 0.2s ease;
        }

        .onboarding-input:focus {
            border-color: var(--accent-primary);
        }

        /* Avatar Picker */
        .avatar-picker {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            max-width: 320px;
            margin: 0 auto;
        }

        .avatar-option {
            width: 64px;
            height: 64px;
            font-size: 36px;
            border: 3px solid transparent;
            border-radius: 50%;
            background: var(--bg-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .avatar-option:hover {
            transform: scale(1.1);
        }

        .avatar-option.selected {
            border-color: var(--accent-primary);
            background: #f3e8ff;
            transform: scale(1.1);
        }

        /* Personality Picker */
        .personality-options {
            width: 100%;
            max-width: 320px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .personality-option {
            padding: 16px 20px;
            border: 2px solid #e5e7eb;
            border-radius: 16px;
            background: var(--bg-card);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .personality-option:hover {
            border-color: #d1d5db;
        }

        .personality-option.selected {
            border-color: var(--accent-primary);
            background: #f3e8ff;
        }

        .personality-option-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .personality-option-desc {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Onboarding Footer */
        .onboarding-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 20px 24px;
            padding-bottom: calc(20px + env(safe-area-inset-bottom));
            background: var(--bg-primary);
        }

        .onboarding-btn {
            width: 100%;
            padding: 16px;
            font-size: 18px;
            font-weight: 600;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .onboarding-btn.primary {
            background: var(--gradient-header);
            color: white;
        }

        .onboarding-btn.primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .onboarding-btn.primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .onboarding-btn.secondary {
            background: transparent;
            color: var(--text-secondary);
            margin-top: 8px;
        }

        .onboarding-progress {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 16px;
        }

        .progress-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #e5e7eb;
            transition: all 0.2s ease;
        }

        .progress-dot.active {
            background: var(--accent-primary);
            width: 24px;
            border-radius: 4px;
        }

        .progress-dot.completed {
            background: var(--accent-success);
        }

        /* =====================================================
           PERSONALITY MESSAGES FOOTER
           ===================================================== */
        .personality-footer {
            text-align: center;
            padding: 16px 20px;
            color: var(--text-muted);
            font-size: 13px;
            font-style: italic;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .personality-message {
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* =====================================================
           ENHANCED PROFILE PAGE
           ===================================================== */
        .profile-avatar-large {
            width: 100px;
            height: 100px;
            background: var(--gradient-header);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
            font-size: 48px;
            cursor: pointer;
            transition: transform 0.2s ease;
            position: relative;
        }

        .profile-avatar-large:hover {
            transform: scale(1.05);
        }

        .profile-avatar-edit {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 32px;
            height: 32px;
            background: var(--accent-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: white;
            border: 3px solid var(--bg-primary);
        }

        .profile-display-name {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .profile-section-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 24px 0 12px;
            padding-left: 4px;
        }

        /* Avatar Edit Modal */
        .avatar-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            padding: 20px;
        }

        .avatar-modal.active {
            display: flex;
        }

        .avatar-modal-content {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 24px;
            width: 100%;
            max-width: 340px;
        }

        .avatar-modal-title {
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 20px;
        }

        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .avatar-grid-item {
            width: 48px;
            height: 48px;
            font-size: 28px;
            border: 2px solid transparent;
            border-radius: 50%;
            background: var(--bg-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .avatar-grid-item:hover {
            transform: scale(1.1);
        }

        .avatar-grid-item.selected {
            border-color: var(--accent-primary);
            background: #f3e8ff;
        }

        /* =====================================================
           SHOPPING CATEGORIES
           ===================================================== */
        .category-section {
            margin-bottom: 12px;
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow-md);
        }

        .category-section.all-done {
            opacity: 0.6;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            background: var(--bg-secondary);
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }

        .category-header:active {
            background: #EBE9E3;
        }

        .category-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .category-emoji {
            font-size: 20px;
        }

        .category-name {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
        }

        .category-count {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .category-toggle {
            color: var(--text-muted);
            font-size: 12px;
            transition: transform 0.2s;
        }

        .category-items {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.2s ease;
        }

        .category-items.collapsed {
            max-height: 0;
            opacity: 0;
        }

        /* Shared item styles for both Tasks and Shopping - USE !important to override generic styles */
        .task-item,
        .shopping-item {
            display: flex !important;
            flex-direction: row !important;
            align-items: center !important;
            padding: 12px 16px !important;
            background: white;
            border-top: 1px solid #f3f4f6;
            gap: 12px;
            width: 100%;
            box-sizing: border-box;
        }

        .task-item:first-child,
        .shopping-item:first-child {
            border-top: none;
        }

        .task-item:active,
        .shopping-item:active {
            background: #f9fafb;
        }

        .task-item.done,
        .shopping-item.done {
            background: #fafafa;
        }

        .task-item.done .item-text,
        .shopping-item.done .item-text {
            text-decoration: line-through;
            color: #9ca3af;
        }

        .task-item > .item-checkbox,
        .shopping-item > .item-checkbox {
            width: 24px !important;
            height: 24px !important;
            min-width: 24px !important;
            border: 2px solid #d1d5db !important;
            border-radius: 50% !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 14px;
            color: white;
            cursor: pointer;
            flex-shrink: 0 !important;
            margin: 0 !important;
        }

        .task-item > .item-checkbox.checked,
        .shopping-item > .item-checkbox.checked {
            background: #10b981 !important;
            border-color: #10b981 !important;
        }

        .task-item > .item-content,
        .shopping-item > .item-content {
            flex: 1 !important;
            min-width: 0 !important;
            display: flex !important;
            flex-direction: column !important;
        }

        .task-item .item-text,
        .shopping-item .item-text {
            display: block;
            font-size: 15px;
            font-weight: 500;
            color: #1f2937;
            word-break: break-word;
        }

        .task-item .item-meta,
        .shopping-item .item-meta {
            display: none !important; /* Hidden - cleaner look */
        }

        .task-item > .priority-btn,
        .shopping-item > .priority-btn {
            flex-shrink: 0 !important;
            margin-left: 0 !important;
        }

        /* Fuck It Bucket item override */
        .task-item.fuckit-item {
            background: #fefce8;
            border-top-color: #fef08a;
        }

        /* Auto-delete fade animation for completed items */
        .fading-out {
            animation: fadeOutAndSlide 1.5s ease forwards;
            pointer-events: none; /* Disable interactions except... */
        }

        .fading-out .item-checkbox {
            pointer-events: auto !important; /* Keep checkbox tappable to rescue */
            cursor: pointer !important;
        }

        @keyframes fadeOutAndSlide {
            0% {
                opacity: 1;
                transform: translateX(0);
                max-height: 100px;
            }
            70% {
                opacity: 0.4;
                transform: translateX(0);
                max-height: 100px;
            }
            100% {
                opacity: 0;
                transform: translateX(30px);
                max-height: 0;
                padding-top: 0;
                padding-bottom: 0;
                margin: 0;
                border: none;
            }
        }

        /* =====================================================
           AUTOCORRECT MODAL
           ===================================================== */
        .autocorrect-modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 20px;
        }

        .autocorrect-modal {
            background: white;
            border-radius: 20px;
            padding: 24px;
            width: 100%;
            max-width: 340px;
            animation: modalSlideUp 0.3s ease;
        }

        @keyframes modalSlideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .autocorrect-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .autocorrect-icon {
            font-size: 40px;
            display: block;
            margin-bottom: 8px;
        }

        .autocorrect-header h3 {
            margin: 0;
            font-size: 20px;
            color: var(--text-primary);
        }

        .autocorrect-suggestion {
            background: #f9fafb;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .autocorrect-suggestion .label {
            font-size: 12px;
            color: var(--text-muted);
            display: block;
            margin-bottom: 4px;
        }

        .autocorrect-suggestion .value {
            font-size: 18px;
            font-weight: 600;
        }

        .autocorrect-suggestion .original .value {
            text-decoration: line-through;
            color: var(--text-muted);
        }

        .autocorrect-suggestion .corrected .value {
            color: var(--accent-success);
        }

        .autocorrect-suggestion .arrow {
            text-align: center;
            font-size: 20px;
            color: var(--text-muted);
            margin: 8px 0;
        }

        .autocorrect-category {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #f3f4f6;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .autocorrect-category .label {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .autocorrect-category .value {
            font-size: 15px;
            font-weight: 600;
        }

        .autocorrect-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .autocorrect-actions button {
            padding: 14px 20px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-accept {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .btn-accept:active {
            transform: scale(0.98);
        }

        .btn-keep {
            background: #f3f4f6;
            color: var(--text-secondary);
        }

        /* =====================================================
           CATEGORY PICKER MODAL
           ===================================================== */
        .category-picker-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            z-index: 9999;
        }

        .category-picker-modal {
            background: white;
            border-radius: 20px 20px 0 0;
            padding: 20px;
            padding-bottom: calc(20px + env(safe-area-inset-bottom));
            width: 100%;
            max-width: 500px;
            max-height: 70vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .category-picker-modal h3 {
            text-align: center;
            margin: 0 0 16px;
            font-size: 18px;
        }

        .category-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .category-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 14px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .category-option:active {
            background: #f3f4f6;
        }

        .category-option.selected {
            border-color: var(--accent-primary);
            background: #f3e8ff;
        }

        .category-option .cat-emoji {
            font-size: 20px;
        }

        .category-option .cat-name {
            flex: 1;
            font-weight: 500;
            font-size: 14px;
        }

        .category-option .check {
            color: var(--accent-primary);
            font-weight: bold;
        }

        .cancel-btn {
            width: 100%;
            margin-top: 16px;
            padding: 16px;
            border: none;
            border-radius: 12px;
            background: #f3f4f6;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
        }

        /* Add button spinner */
        .btn-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
    </style>
</head>
<body>
    <!-- Onboarding Overlay -->
    <div class="onboarding-overlay" id="onboardingOverlay">
        <!-- Screen 1: Welcome -->
        <div class="onboarding-screen active" data-screen="1">
            <div class="onboarding-header">
                <div class="onboarding-icon">&#127968;</div>
                <h1 class="onboarding-title">Welcome to Mysa</h1>
                <p class="onboarding-subtitle">Your cozy corner for family lists. Tasks, shopping, and good vibes - all in one place.</p>
            </div>
            <div class="onboarding-content">
                <!-- Empty - just intro screen -->
            </div>
            <div class="onboarding-footer">
                <div class="onboarding-progress">
                    <div class="progress-dot active"></div>
                    <div class="progress-dot"></div>
                    <div class="progress-dot"></div>
                    <div class="progress-dot"></div>
                    <div class="progress-dot"></div>
                </div>
                <button class="onboarding-btn primary" id="onboardingNext1">Let's get started</button>
            </div>
        </div>

        <!-- Screen 2: Name -->
        <div class="onboarding-screen" data-screen="2">
            <div class="onboarding-header">
                <div class="onboarding-icon">&#128075;</div>
                <h1 class="onboarding-title">What's your name?</h1>
                <p class="onboarding-subtitle">This is how you'll appear to your family members.</p>
            </div>
            <div class="onboarding-content">
                <input type="text" class="onboarding-input" id="onboardingName" placeholder="Your name" maxlength="20" autocomplete="off">
            </div>
            <div class="onboarding-footer">
                <div class="onboarding-progress">
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot active"></div>
                    <div class="progress-dot"></div>
                    <div class="progress-dot"></div>
                    <div class="progress-dot"></div>
                </div>
                <button class="onboarding-btn primary" id="onboardingNext2" disabled>Continue</button>
                <button class="onboarding-btn secondary" id="onboardingSkip2">Skip for now</button>
            </div>
        </div>

        <!-- Screen 3: Avatar -->
        <div class="onboarding-screen" data-screen="3">
            <div class="onboarding-header">
                <div class="onboarding-icon">&#128513;</div>
                <h1 class="onboarding-title">Pick your avatar</h1>
                <p class="onboarding-subtitle">Choose an emoji that represents you!</p>
            </div>
            <div class="onboarding-content">
                <div class="avatar-picker" id="avatarPicker">
                    <div class="avatar-option" data-avatar="&#128512;">&#128512;</div>
                    <div class="avatar-option" data-avatar="&#128522;">&#128522;</div>
                    <div class="avatar-option" data-avatar="&#128526;">&#128526;</div>
                    <div class="avatar-option" data-avatar="&#129299;">&#129299;</div>
                    <div class="avatar-option" data-avatar="&#128536;">&#128536;</div>
                    <div class="avatar-option" data-avatar="&#128525;">&#128525;</div>
                    <div class="avatar-option" data-avatar="&#129303;">&#129303;</div>
                    <div class="avatar-option" data-avatar="&#128571;">&#128571;</div>
                    <div class="avatar-option" data-avatar="&#128055;">&#128055;</div>
                    <div class="avatar-option" data-avatar="&#128049;">&#128049;</div>
                    <div class="avatar-option" data-avatar="&#129412;">&#129412;</div>
                    <div class="avatar-option" data-avatar="&#128038;">&#128038;</div>
                </div>
            </div>
            <div class="onboarding-footer">
                <div class="onboarding-progress">
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot active"></div>
                    <div class="progress-dot"></div>
                    <div class="progress-dot"></div>
                </div>
                <button class="onboarding-btn primary" id="onboardingNext3">Continue</button>
                <button class="onboarding-btn secondary" id="onboardingSkip3">Skip for now</button>
            </div>
        </div>

        <!-- Screen 4: Personality -->
        <div class="onboarding-screen" data-screen="4">
            <div class="onboarding-header">
                <div class="onboarding-icon">&#127881;</div>
                <h1 class="onboarding-title">Set the vibe</h1>
                <p class="onboarding-subtitle">How playful should Mysa be?</p>
            </div>
            <div class="onboarding-content">
                <div class="personality-options" id="personalityPicker">
                    <div class="personality-option" data-personality="off">
                        <div class="personality-option-title">&#128566; Zen Mode</div>
                        <div class="personality-option-desc">Just the basics. No funny business.</div>
                    </div>
                    <div class="personality-option selected" data-personality="subtle">
                        <div class="personality-option-title">&#128578; Subtle</div>
                        <div class="personality-option-desc">Occasional encouragement and gentle humor.</div>
                    </div>
                    <div class="personality-option" data-personality="fun">
                        <div class="personality-option-title">&#129395; Full Fun</div>
                        <div class="personality-option-desc">Maximum silliness! Jokes, puns, and celebration.</div>
                    </div>
                </div>
            </div>
            <div class="onboarding-footer">
                <div class="onboarding-progress">
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot active"></div>
                    <div class="progress-dot"></div>
                </div>
                <button class="onboarding-btn primary" id="onboardingNext4">Continue</button>
            </div>
        </div>

        <!-- Screen 5: Ready -->
        <div class="onboarding-screen" data-screen="5">
            <div class="onboarding-header">
                <div class="onboarding-icon">&#127881;</div>
                <h1 class="onboarding-title">You're all set!</h1>
                <p class="onboarding-subtitle">Time to get organized. Your family is going to love this.</p>
            </div>
            <div class="onboarding-content">
                <div style="font-size: 80px; text-align: center;" id="finalAvatarPreview">&#128512;</div>
                <div style="font-size: 24px; font-weight: 600; text-align: center; margin-top: 16px;" id="finalNamePreview">Friend</div>
            </div>
            <div class="onboarding-footer">
                <div class="onboarding-progress">
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot completed"></div>
                    <div class="progress-dot active"></div>
                </div>
                <button class="onboarding-btn primary" id="onboardingFinish">Start using Mysa</button>
            </div>
        </div>
    </div>

    <!-- Avatar Edit Modal -->
    <div class="avatar-modal" id="avatarModal">
        <div class="avatar-modal-content">
            <h3 class="avatar-modal-title">Choose your avatar</h3>
            <div class="avatar-grid" id="avatarGrid">
                <div class="avatar-grid-item" data-avatar="&#128512;">&#128512;</div>
                <div class="avatar-grid-item" data-avatar="&#128522;">&#128522;</div>
                <div class="avatar-grid-item" data-avatar="&#128526;">&#128526;</div>
                <div class="avatar-grid-item" data-avatar="&#129299;">&#129299;</div>
                <div class="avatar-grid-item" data-avatar="&#128536;">&#128536;</div>
                <div class="avatar-grid-item" data-avatar="&#128525;">&#128525;</div>
                <div class="avatar-grid-item" data-avatar="&#129303;">&#129303;</div>
                <div class="avatar-grid-item" data-avatar="&#128571;">&#128571;</div>
                <div class="avatar-grid-item" data-avatar="&#128055;">&#128055;</div>
                <div class="avatar-grid-item" data-avatar="&#128049;">&#128049;</div>
                <div class="avatar-grid-item" data-avatar="&#129412;">&#129412;</div>
                <div class="avatar-grid-item" data-avatar="&#128038;">&#128038;</div>
                <div class="avatar-grid-item" data-avatar="&#129409;">&#129409;</div>
                <div class="avatar-grid-item" data-avatar="&#128029;">&#128029;</div>
                <div class="avatar-grid-item" data-avatar="&#127803;">&#127803;</div>
            </div>
            <button class="onboarding-btn primary" id="avatarModalClose">Done</button>
        </div>
    </div>

    <!-- Offline Indicator -->
    <div class="offline-indicator" id="offlineIndicator">You are offline</div>

    <!-- Toast Notifications -->
    <div class="toast" id="toast"></div>

    <div class="container">
        <!-- Header -->
        <div class="header" id="mainHeader">
            <div class="header-content">
                <div class="header-left">
                    <h1 id="pageTitle">Mysa</h1>
                    <div class="header-subtitle" id="headerSubtitle"></div>
                </div>
                <button class="share-btn hidden" id="shareBtn" title="Share">
                    <span>&#128101;</span>
                </button>
            </div>
        </div>

        <!-- Auth Section -->
        <div class="auth-container" id="authContainer">
            <h2>Welcome</h2>
            <div class="auth-tabs">
                <button class="auth-tab active" data-tab="login">Login</button>
                <button class="auth-tab" data-tab="signup">Sign Up</button>
            </div>

            <div class="error-message" id="authError"></div>

            <div class="auth-form active" id="loginForm">
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" id="loginEmail" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="loginPassword" placeholder="Enter your password">
                </div>
                <button class="auth-btn primary" id="loginBtn">Login</button>
            </div>

            <div class="auth-form" id="signupForm">
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" id="signupEmail" placeholder="Enter your email">
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" id="signupPassword" placeholder="Create a password (6+ chars)">
                </div>
                <button class="auth-btn primary" id="signupBtn">Sign Up</button>
            </div>

            <div class="divider">or</div>

            <button class="auth-btn google" id="googleBtn">
                <svg class="google-icon" viewBox="0 0 24 24">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                </svg>
                Continue with Google
            </button>
        </div>

        <!-- App Section -->
        <div class="app-container" id="appContainer">
            <!-- Tasks/Shopping Content -->
            <div class="content" id="listContent">
                <!-- Pull to Refresh Indicator -->
                <div class="pull-indicator" id="pullIndicator">
                    <div class="pull-spinner"></div>
                </div>

                <!-- Loading Skeletons -->
                <div class="skeleton-container" id="skeletonContainer">
                    <div class="skeleton-card">
                        <div class="skeleton-checkbox"></div>
                        <div class="skeleton-content">
                            <div class="skeleton-title"></div>
                            <div class="skeleton-subtitle"></div>
                        </div>
                    </div>
                    <div class="skeleton-card">
                        <div class="skeleton-checkbox"></div>
                        <div class="skeleton-content">
                            <div class="skeleton-title"></div>
                            <div class="skeleton-subtitle"></div>
                        </div>
                    </div>
                    <div class="skeleton-card">
                        <div class="skeleton-checkbox"></div>
                        <div class="skeleton-content">
                            <div class="skeleton-title"></div>
                            <div class="skeleton-subtitle"></div>
                        </div>
                    </div>
                </div>

                <ul class="items-list" id="itemList"></ul>
            </div>

            <!-- Profile Content -->
            <div class="profile-content" id="profileContent">
                <div class="profile-header">
                    <div class="profile-avatar-large" id="profileAvatarLarge" title="Tap to change avatar">
                        <span id="profileAvatarEmoji">&#128512;</span>
                        <div class="profile-avatar-edit">&#9998;</div>
                    </div>
                    <div class="profile-display-name" id="profileDisplayName">Friend</div>
                    <div class="profile-email" id="profileEmail"></div>
                </div>

                <div class="profile-section-title">Settings</div>
                <ul class="profile-menu">
                    <li class="profile-menu-item">
                        <button class="profile-menu-btn" id="editNameBtn">
                            <span class="profile-menu-icon">&#9998;</span>
                            Edit Display Name
                        </button>
                    </li>
                    <li class="profile-menu-item">
                        <button class="profile-menu-btn" id="personalitySettingBtn">
                            <span class="profile-menu-icon">&#127881;</span>
                            <span id="personalitySettingLabel">Personality: Subtle</span>
                        </button>
                    </li>
                    <li class="profile-menu-item">
                        <button class="profile-menu-btn" id="apiKeySettingBtn">
                            <span class="profile-menu-icon">&#128273;</span>
                            <span id="apiKeySettingLabel">Claude API Key</span>
                        </button>
                    </li>
                </ul>

                <div class="profile-section-title">Lists</div>
                <ul class="profile-menu">
                    <li class="profile-menu-item">
                        <button class="profile-menu-btn" id="manageSharingBtn">
                            <span class="profile-menu-icon">&#128101;</span>
                            Manage Sharing
                        </button>
                    </li>
                    <li class="profile-menu-item">
                        <button class="profile-menu-btn" id="clearAllCompletedBtn">
                            <span class="profile-menu-icon">&#128465;</span>
                            Clear All Completed
                        </button>
                    </li>
                </ul>

                <div class="profile-section-title">Account</div>
                <ul class="profile-menu">
                    <li class="profile-menu-item">
                        <button class="profile-menu-btn danger" id="logoutBtn">
                            <span class="profile-menu-icon">&#128682;</span>
                            Logout
                        </button>
                    </li>
                </ul>

                <div class="personality-footer" id="personalityFooter">
                    <!-- Rotating funny messages will appear here -->
                </div>

                <div class="profile-version" style="text-align: center; padding: 10px 20px; color: #9ca3af; font-size: 12px;">
                    <div>Mysa v4.8.0</div>
                    <div style="margin-top: 4px;">Made with &#10084;&#65039;</div>
                </div>
            </div>

            <!-- Add Input (floating) -->
            <div class="add-input-container" id="addInputContainer">
                <div class="add-input-wrapper" id="addInputWrapper">
                    <input type="text" class="add-input" id="itemInput" placeholder="Add a task...">
                    <button class="category-picker-btn" id="taskCategoryPickerBtn" onclick="showTaskCategoryPicker()" style="display: flex;">
                        <span id="selectedTaskCategoryEmoji"></span>
                    </button>
                    <button class="category-picker-btn" id="categoryPickerBtn" onclick="showAddCategoryPicker()" style="display: none;">
                        <span id="selectedCategoryEmoji"></span>
                    </button>
                </div>
                <button class="add-btn" id="addBtn">Add</button>
            </div>

            <!-- Bottom Navigation -->
            <nav class="bottom-nav">
                <button data-tab="tasks" class="nav-item active">
                    <span class="nav-icon">&#128203;</span>
                    <span class="nav-label">Tasks</span>
                </button>
                <button data-tab="shopping" class="nav-item">
                    <span class="nav-icon">&#128722;</span>
                    <span class="nav-label">Shopping</span>
                </button>
                <button data-tab="profile" class="nav-item">
                    <span class="nav-icon">&#128100;</span>
                    <span class="nav-label">Profile</span>
                </button>
            </nav>
        </div>
    </div>

    <!-- Edit Item Modal -->
    <div class="edit-item-modal-overlay" id="editItemModal" style="display: none;">
        <div class="edit-item-modal">
            <div class="edit-modal-header">
                <span class="edit-modal-icon"></span>
                <h3>Edit Item</h3>
            </div>

            <div class="edit-modal-field">
                <label for="editItemText">Item name:</label>
                <input type="text" id="editItemText" placeholder="Enter item name" />
            </div>

            <div class="edit-modal-field">
                <label for="editItemCategory">Category:</label>
                <select id="editItemCategory">
                    <option value="produce"> Produce</option>
                    <option value="dairy_eggs"> Dairy & Eggs</option>
                    <option value="meat_seafood"> Meat & Seafood</option>
                    <option value="bakery"> Bakery & Bread</option>
                    <option value="pantry"> Pantry Staples</option>
                    <option value="frozen"> Frozen</option>
                    <option value="beverages"> Beverages</option>
                    <option value="snacks"> Snacks</option>
                    <option value="household"> Household</option>
                    <option value="personal_care"> Personal Care</option>
                    <option value="baby"> Baby</option>
                    <option value="pet"> Pet</option>
                    <option value="other"> Other</option>
                </select>
            </div>

            <div class="edit-modal-buttons">
                <button class="edit-modal-cancel" onclick="closeEditItemModal()">Cancel</button>
                <button class="edit-modal-save" onclick="saveEditedItem()">Save</button>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div class="modal-overlay" id="shareModal">
        <div class="share-modal">
            <div class="modal-header">
                <h2>Share List</h2>
                <button class="modal-close" id="modalClose">&times;</button>
            </div>
            <div class="modal-body">
                <div class="invite-section" id="inviteSection">
                    <label>Invite by email</label>
                    <div class="invite-input-group">
                        <input type="email" id="inviteEmail" placeholder="Enter email address">
                        <button class="invite-btn" id="inviteBtn">Invite</button>
                    </div>
                    <div class="share-message" id="shareMessage"></div>
                </div>
                <div class="collaborators-section">
                    <h3>Collaborators</h3>
                    <ul class="collaborator-list" id="collaboratorList">
                        <li class="no-collaborators">No collaborators yet</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBpibQqkud3uVUuG2AXabVhzot64h35Qr0",
            authDomain: "shoppingapp-f08f4.firebaseapp.com",
            projectId: "shoppingapp-f08f4",
            storageBucket: "shoppingapp-f08f4.firebasestorage.app",
            messagingSenderId: "54382196312",
            appId: "1:54382196312:web:b46aa2e5648a816783554d"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        // App Version
        const APP_VERSION = '4.8.0';
        console.log(`[App] Mysa Version ${APP_VERSION}`);

        // =====================================================
        // CLAUDE API CONFIGURATION
        // =====================================================
        const CLAUDE_API_URL = 'https://api.anthropic.com/v1/messages';
        const CLAUDE_MODEL = 'claude-3-haiku-20240307';

        // Get/Set Claude API Key from localStorage
        function getClaudeApiKey() {
            return localStorage.getItem('claudeApiKey') || '';
        }
        function setClaudeApiKey(key) {
            localStorage.setItem('claudeApiKey', key);
        }

        // User preferences cache (for category corrections)
        const userCategoryPrefs = JSON.parse(localStorage.getItem('userCategoryPrefs') || '{}');
        function saveUserCategoryPrefs() {
            localStorage.setItem('userCategoryPrefs', JSON.stringify(userCategoryPrefs));
        }

        // =====================================================
        // SHOPPING CATEGORIES
        // =====================================================
        const SHOPPING_CATEGORIES = [
            { id: 'produce', name: 'Produce', emoji: '' },
            { id: 'dairy_eggs', name: 'Dairy & Eggs', emoji: '' },
            { id: 'meat_seafood', name: 'Meat & Seafood', emoji: '' },
            { id: 'bakery', name: 'Bakery & Bread', emoji: '' },
            { id: 'pantry', name: 'Pantry Staples', emoji: '' },
            { id: 'frozen', name: 'Frozen', emoji: '' },
            { id: 'beverages', name: 'Beverages', emoji: '' },
            { id: 'snacks', name: 'Snacks', emoji: '' },
            { id: 'household', name: 'Household', emoji: '' },
            { id: 'personal_care', name: 'Personal Care', emoji: '' },
            { id: 'baby', name: 'Baby', emoji: '' },
            { id: 'pet', name: 'Pet', emoji: '' },
            { id: 'other', name: 'Other', emoji: '' }
        ];

        // =====================================================
        // TASK CATEGORIES
        // =====================================================
        const TASK_CATEGORIES = [
            { id: 'home', name: 'Home', emoji: '' },
            { id: 'kids', name: 'Kids', emoji: '' },
            { id: 'projects', name: 'Projects', emoji: '' },
            { id: 'calls_bookings', name: 'Calls & Bookings', emoji: '' },
            { id: 'other', name: 'Other', emoji: '' },
            { id: 'fuckit', name: 'Fuck It Bucket', emoji: '' }
        ];

        const CATEGORY_KEYWORDS = {
            produce: [
                'apple', 'apples', 'banana', 'bananas', 'orange', 'oranges', 'lemon', 'lemons', 'lime', 'limes',
                'grape', 'grapes', 'strawberry', 'strawberries', 'blueberry', 'blueberries', 'raspberry', 'raspberries',
                'mango', 'mangoes', 'pineapple', 'watermelon', 'melon', 'peach', 'peaches', 'pear', 'pears', 'plum', 'plums',
                'avocado', 'avocados', 'tomato', 'tomatoes', 'potato', 'potatoes', 'onion', 'onions', 'garlic',
                'carrot', 'carrots', 'broccoli', 'cauliflower', 'spinach', 'lettuce', 'kale', 'cabbage',
                'cucumber', 'cucumbers', 'pepper', 'peppers', 'bell pepper', 'jalapeno', 'celery', 'corn',
                'mushroom', 'mushrooms', 'zucchini', 'squash', 'eggplant', 'asparagus', 'green beans',
                'salad', 'herbs', 'basil', 'cilantro', 'parsley', 'mint', 'ginger', 'beet', 'beets',
                'sweet potato', 'yam', 'radish', 'turnip', 'artichoke', 'leek', 'scallion', 'shallot',
                'fruit', 'fruits', 'vegetable', 'vegetables', 'veggies', 'greens', 'pomelo', 'clementine', 'tangerine'
            ],
            dairy_eggs: [
                'milk', 'eggs', 'egg', 'cheese', 'butter', 'yogurt', 'yoghurt', 'cream', 'sour cream',
                'cream cheese', 'cottage cheese', 'mozzarella', 'cheddar', 'parmesan', 'feta', 'brie',
                'half and half', 'half & half', 'whipping cream', 'heavy cream', 'oat milk', 'almond milk',
                'soy milk', 'coconut milk', 'lactose free', 'dairy', 'creamer', 'ghee', 'margarine'
            ],
            meat_seafood: [
                'chicken', 'beef', 'pork', 'steak', 'ground beef', 'ground turkey', 'turkey', 'lamb',
                'bacon', 'ham', 'sausage', 'sausages', 'hot dog', 'hot dogs', 'salami', 'pepperoni',
                'fish', 'salmon', 'tuna', 'shrimp', 'prawns', 'crab', 'lobster', 'scallops', 'mussels',
                'tilapia', 'cod', 'halibut', 'trout', 'sardines', 'anchovies', 'seafood',
                'ribs', 'roast', 'chops', 'tenderloin', 'brisket', 'wings', 'thighs', 'drumsticks',
                'deli meat', 'lunch meat', 'meat', 'poultry'
            ],
            bakery: [
                'bread', 'bagel', 'bagels', 'muffin', 'muffins', 'croissant', 'croissants', 'donut', 'donuts',
                'roll', 'rolls', 'bun', 'buns', 'tortilla', 'tortillas', 'pita', 'naan', 'baguette',
                'english muffin', 'ciabatta', 'sourdough', 'whole wheat', 'white bread', 'rye bread',
                'cake', 'cupcake', 'pie', 'pastry', 'pastries', 'danish', 'scone', 'biscuit', 'biscuits',
                'brownies', 'brioche'
            ],
            pantry: [
                'rice', 'pasta', 'spaghetti', 'noodles', 'macaroni', 'penne', 'linguine', 'fettuccine',
                'cereal', 'oatmeal', 'oats', 'granola', 'flour', 'sugar', 'salt',
                'oil', 'olive oil', 'vegetable oil', 'coconut oil', 'vinegar', 'balsamic',
                'canned', 'beans', 'black beans', 'kidney beans', 'chickpeas', 'lentils',
                'tomato sauce', 'pasta sauce', 'marinara', 'salsa', 'ketchup', 'mustard', 'mayo', 'mayonnaise',
                'soy sauce', 'hot sauce', 'bbq sauce', 'honey', 'maple syrup', 'jam', 'jelly', 'peanut butter',
                'nutella', 'almond butter', 'broth', 'stock', 'soup', 'canned soup',
                'tuna can', 'canned tuna', 'canned chicken', 'spam',
                'spice', 'spices', 'seasoning', 'cinnamon', 'cumin', 'paprika', 'oregano', 'thyme',
                'baking soda', 'baking powder', 'yeast', 'vanilla', 'cocoa', 'chocolate chips',
                'quinoa', 'couscous', 'barley', 'breadcrumbs', 'croutons', 'stuffing'
            ],
            frozen: [
                'frozen', 'ice cream', 'gelato', 'sorbet', 'popsicle', 'frozen pizza', 'pizza rolls',
                'frozen vegetables', 'frozen fruit', 'frozen berries', 'frozen dinner', 'tv dinner',
                'frozen chicken', 'frozen fish', 'fish sticks', 'chicken nuggets', 'frozen fries',
                'waffles', 'frozen waffles', 'frozen breakfast', 'burritos', 'frozen burritos',
                'ice', 'ice cubes', 'peas frozen', 'corn frozen', 'edamame'
            ],
            beverages: [
                'water', 'sparkling water', 'soda', 'coke', 'pepsi', 'sprite', 'fanta',
                'juice', 'orange juice', 'apple juice', 'grape juice', 'cranberry juice',
                'coffee', 'tea', 'green tea', 'black tea', 'herbal tea', 'iced tea',
                'energy drink', 'red bull', 'monster', 'gatorade', 'powerade', 'sports drink',
                'beer', 'wine', 'liquor', 'vodka', 'whiskey', 'rum', 'gin', 'tequila',
                'lemonade', 'smoothie', 'kombucha', 'coconut water', 'tonic water',
                'drink', 'drinks', 'beverage', 'beverages', 'seltzer', 'la croix'
            ],
            snacks: [
                'chips', 'crisps', 'pretzels', 'popcorn', 'crackers', 'goldfish',
                'nuts', 'almonds', 'peanuts', 'cashews', 'walnuts', 'pistachios', 'trail mix',
                'chocolate', 'candy', 'gummy', 'gummies', 'm&ms', 'skittles', 'twix', 'snickers',
                'granola bar', 'protein bar', 'energy bar', 'cliff bar', 'kind bar',
                'cookies', 'oreos', 'chips ahoy', 'fruit snacks', 'dried fruit', 'jerky', 'beef jerky',
                'cheese puffs', 'cheetos', 'doritos', 'lays', 'pringles', 'ruffles', 'tostitos',
                'dip', 'hummus', 'guacamole', 'snack', 'snacks', 'munchies'
            ],
            household: [
                'paper towel', 'paper towels', 'toilet paper', 'tissues', 'kleenex', 'napkins',
                'trash bags', 'garbage bags', 'ziploc', 'plastic wrap', 'aluminum foil', 'foil',
                'dish soap', 'dishwasher', 'detergent', 'laundry detergent', 'tide', 'tide pods',
                'fabric softener', 'dryer sheets', 'bleach', 'cleaner', 'cleaning', 'wipes', 'clorox',
                'sponge', 'sponges', 'scrubber', 'mop', 'broom', 'dustpan',
                'light bulb', 'batteries', 'aa batteries', 'aaa batteries',
                'candle', 'candles', 'air freshener', 'febreze',
                'household', 'cleaning supplies', 'laundry', 'lysol', 'windex', 'pledge'
            ],
            personal_care: [
                'shampoo', 'conditioner', 'body wash', 'soap', 'bar soap', 'hand soap',
                'toothpaste', 'toothbrush', 'mouthwash', 'floss', 'dental',
                'deodorant', 'antiperspirant', 'lotion', 'moisturizer', 'sunscreen', 'sunblock',
                'razor', 'razors', 'shaving cream', 'aftershave',
                'makeup', 'mascara', 'lipstick', 'foundation', 'concealer', 'eyeliner',
                'hair gel', 'hair spray', 'mousse', 'hair dye',
                'cotton balls', 'cotton swabs', 'q-tips', 'band-aid', 'bandages', 'first aid',
                'medicine', 'advil', 'tylenol', 'ibuprofen', 'aspirin', 'vitamins', 'supplements',
                'tampons', 'pads', 'feminine', 'personal care', 'hygiene'
            ],
            baby: [
                'diaper', 'diapers', 'baby wipes', 'baby food', 'formula', 'baby formula',
                'baby cereal', 'baby snacks', 'baby bottle', 'pacifier', 'sippy cup',
                'baby shampoo', 'baby lotion', 'baby powder', 'diaper cream', 'rash cream',
                'baby', 'infant', 'toddler', 'newborn', 'nursing', 'breast pump'
            ],
            pet: [
                'dog food', 'cat food', 'pet food', 'kibble', 'wet food',
                'dog treats', 'cat treats', 'pet treats', 'milk bone',
                'cat litter', 'litter', 'kitty litter',
                'dog toy', 'cat toy', 'pet toy', 'chew toy',
                'leash', 'collar', 'pet bed', 'dog bed', 'cat bed',
                'flea', 'tick', 'heartworm', 'pet shampoo',
                'pet', 'puppy', 'kitten', 'fish food', 'bird food'
            ]
        };

        // Category cache for AI results
        const categoryCache = {};

        // Load category cache from localStorage
        function loadCategoryCache() {
            try {
                const cached = localStorage.getItem('categoryCache');
                if (cached) {
                    Object.assign(categoryCache, JSON.parse(cached));
                    console.log('[Category] Loaded cache with', Object.keys(categoryCache).length, 'items');
                }
            } catch (e) {
                console.error('[Category] Error loading cache:', e);
            }
        }

        // Save category cache to localStorage
        function saveCategoryCache() {
            try {
                localStorage.setItem('categoryCache', JSON.stringify(categoryCache));
            } catch (e) {
                console.error('[Category] Error saving cache:', e);
            }
        }

        // Keyword matching
        function matchKeywords(text) {
            const normalized = text.toLowerCase().trim();
            for (const [category, keywords] of Object.entries(CATEGORY_KEYWORDS)) {
                for (const keyword of keywords) {
                    // Exact match or contains
                    if (normalized === keyword || normalized.includes(keyword) || keyword.includes(normalized)) {
                        return category;
                    }
                }
            }
            return null;
        }


        // AI categorization with spelling correction (Claude Haiku)
        async function callClaudeForCategorization(itemText) {
            console.log(`[AI] Calling Claude for: "${itemText}"`);

            const apiKey = getClaudeApiKey();
            if (!apiKey) {
                console.log('[AI] No API key configured, using fallback');
                return null;
            }

            const categoryList = SHOPPING_CATEGORIES.map(c => `${c.id} (${c.name})`).join(', ');

            try {
                const response = await fetch(CLAUDE_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: CLAUDE_MODEL,
                        max_tokens: 200,
                        messages: [{
                            role: 'user',
                            content: `You are a multilingual grocery shopping assistant. You understand ALL languages including Danish, Norwegian, Swedish, German, Spanish, French, and more.

Item entered by user: "${itemText}"

IMPORTANT: Users may enter items in ANY language. Recognize the language and categorize correctly.

Common Danish examples:
- "mlk" = milk = dairy_eggs
- "g" = eggs = dairy_eggs
- "brd" = bread = bakery
- "kylling" = chicken = meat_seafood
- "ost" = cheese = dairy_eggs
- "smr" = butter = dairy_eggs
- "frugt" = fruit = produce
- "grntsager" = vegetables = produce
- "kaffe" = coffee = beverages
- "te" = tea = beverages
- "l" = beer = beverages
- "vin" = wine = beverages
- "slik" = candy = snacks
- "chips" = chips = snacks
- "rengring" = cleaning = household
- "Ovnrens" = oven cleaner = household
- "Glas keramisk" = glass ceramic cleaner = household
- "Glad keramisk" = ceramic cleaner = household
- "Vel ultra" = dish soap = household
- "Ajax" = cleaning product = household
- "Zewa" = paper towels = household
- "toiletpapir" = toilet paper = household
- "shampoo" = shampoo = personal_care
- "tandpasta" = toothpaste = personal_care
- "bleer" = diapers = baby
- "hundemad" = dog food = pet
- "kattemad" = cat food = pet

Tasks:
1. Identify the language (might be English, Danish, or any other)
2. Understand what the item is
3. Check spelling in the ORIGINAL language. If misspelled, correct it in the same language.
4. Categorize into ONE of: ${categoryList}
5. Rate confidence: high, medium, or low

Respond ONLY with valid JSON:
{
  "original": "${itemText}",
  "corrected": "corrected spelling in ORIGINAL language, or same if correct",
  "category": "category_id",
  "confidence": "high/medium/low"
}`
                        }]
                    })
                });

                if (!response.ok) {
                    console.error('[AI] API error:', response.status);
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();
                const content = data.content[0].text;

                // Parse JSON from response
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);
                    // Validate category
                    if (!SHOPPING_CATEGORIES.find(c => c.id === result.category)) {
                        result.category = 'other';
                    }
                    console.log('[AI] Result:', result);
                    return result;
                }

                throw new Error('No JSON in response');

            } catch (error) {
                console.error('[AI] Error:', error);
                return {
                    original: itemText,
                    corrected: itemText,
                    category: 'other',
                    confidence: 'low'
                };
            }
        }

        // Smart categorization with user preferences and caching
        async function smartCategorize(itemText) {
            const normalized = itemText.toLowerCase().trim();

            // 1. Check user preferences first (highest priority - user corrections)
            if (userCategoryPrefs[normalized]) {
                console.log(`[AI] User preference hit: "${itemText}"  ${userCategoryPrefs[normalized].category}`);
                return {
                    original: itemText,
                    corrected: userCategoryPrefs[normalized].corrected || itemText,
                    category: userCategoryPrefs[normalized].category,
                    confidence: 'high',
                    source: 'user_preference'
                };
            }

            // 2. Check AI cache
            if (categoryCache[normalized] && typeof categoryCache[normalized] === 'object') {
                console.log(`[AI] Cache hit: "${itemText}"  ${categoryCache[normalized].category}`);
                return { ...categoryCache[normalized], source: 'cache' };
            }

            // 3. Try keyword matching for known items (no spelling check needed)
            const keywordMatch = matchKeywords(normalized);
            if (keywordMatch) {
                console.log(`[AI] Keyword match: "${itemText}"  ${keywordMatch}`);
                const result = {
                    original: itemText,
                    corrected: itemText,
                    category: keywordMatch,
                    confidence: 'high',
                    source: 'keyword'
                };
                categoryCache[normalized] = result;
                saveCategoryCache();
                return result;
            }

            // 4. Call AI for unknown items (includes spelling correction)
            if (navigator.onLine) {
                const result = await callClaudeForCategorization(itemText);
                result.source = 'ai';
                categoryCache[normalized] = result;
                saveCategoryCache();
                return result;
            }

            // 5. Offline fallback
            return {
                original: itemText,
                corrected: itemText,
                category: 'other',
                confidence: 'low',
                source: 'fallback'
            };
        }

        // Legacy function for compatibility
        async function categorizeItem(itemText) {
            const result = await smartCategorize(itemText);
            return result.category;
        }

        // Collapsed sections state
        function getCollapsedSections() {
            try {
                return JSON.parse(localStorage.getItem('collapsedSections') || '{}');
            } catch (e) {
                return {};
            }
        }

        function setCollapsedSections(sections) {
            localStorage.setItem('collapsedSections', JSON.stringify(sections));
        }

        function toggleSection(categoryId) {
            const sections = getCollapsedSections();
            sections[categoryId] = !sections[categoryId];
            setCollapsedSections(sections);

            const section = document.querySelector(`[data-category="${categoryId}"]`);
            if (!section) return;

            const items = section.querySelector('.category-items');
            const toggle = section.querySelector('.category-toggle');

            if (sections[categoryId]) {
                items.classList.add('collapsed');
                toggle.textContent = '';
            } else {
                items.classList.remove('collapsed');
                toggle.textContent = '';
            }
        }

        // Initialize category cache on load
        loadCategoryCache();

        // =====================================================
        // USER PROFILE STATE
        // =====================================================
        let userProfile = {
            displayName: '',
            avatar: '&#128512;',
            personality: 'subtle' // 'off', 'subtle', 'fun'
        };

        // =====================================================
        // PERSONALITY MESSAGES (50+ messages)
        // =====================================================
        const PERSONALITY_MESSAGES = {
            subtle: [
                "You're doing great today!",
                "One task at a time...",
                "Progress, not perfection",
                "Small steps, big results",
                "You've got this!",
                "Keep up the momentum",
                "Every checkmark counts",
                "Steady wins the race",
                "Making it happen!",
                "Look at you go!",
                "Crushing it quietly",
                "Organized and thriving",
                "Today is your day",
                "Making progress!",
                "Step by step..."
            ],
            fun: [
                "Your list is judging you... kindly!",
                "Plot twist: You're the main character!",
                "This list won't complete itself... or will it?",
                "Pro tip: Checking things off feels AMAZING",
                "Your future self thanks you!",
                "Is it a list? Is it a lifestyle? Yes!",
                "Groceries fear you!",
                "Tasks tremble at your approach!",
                "Level up! Adulting unlocked!",
                "Achievement: Actually using a list app",
                "You're basically a productivity ninja",
                "Legend has it, this list gets done",
                "Breaking news: You're crushing it!",
                "Studies show: You're awesome",
                "This list is 100% organic, free-range tasks",
                "Warning: Productivity levels off the charts!",
                "Certified list-making professional",
                "Plot armor: ACTIVATED",
                "Mood: Unstoppable",
                "Your shopping cart called. It believes in you.",
                "Tasks? More like suggestions you'll destroy!",
                "Running errands like a boss!",
                "Somewhere, Marie Kondo is smiling",
                "This list sparks joy!",
                "Error 404: Laziness not found",
                "Loading motivation... 100% complete!",
                "Buffering... just kidding, let's GO!",
                "Today's vibe: Getting stuff DONE",
                "Spoiler: You finish everything",
                "Queue dramatic productivity music",
                "Permission granted to feel proud",
                "Official excuse to buy snacks",
                "Shopping: It's basically self-care",
                "List status: Looking good!",
                "Your dedication is showing!",
                "The milk will remember this kindness"
            ]
        };

        function getPersonalityMessage() {
            if (userProfile.personality === 'off') return '';
            const messages = PERSONALITY_MESSAGES[userProfile.personality] || PERSONALITY_MESSAGES.subtle;
            return messages[Math.floor(Math.random() * messages.length)];
        }

        function updatePersonalityFooter() {
            const footer = document.getElementById('personalityFooter');
            if (!footer) return;

            const message = getPersonalityMessage();
            if (message) {
                footer.innerHTML = `<span class="personality-message">"${message}"</span>`;
            } else {
                footer.innerHTML = '';
            }
        }

        // Update message every 30 seconds if on profile tab
        setInterval(() => {
            if (currentTab === 'profile') {
                updatePersonalityFooter();
            }
        }, 30000);

        // =====================================================
        // TOAST NOTIFICATIONS
        // =====================================================
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('visible');
            setTimeout(() => toast.classList.remove('visible'), duration);
        }

        // =====================================================
        // ONBOARDING SYSTEM
        // =====================================================
        let onboardingData = {
            name: '',
            avatar: '&#128512;',
            personality: 'subtle'
        };

        function showOnboarding() {
            document.getElementById('onboardingOverlay').classList.add('active');
            goToOnboardingScreen(1);
        }

        function hideOnboarding() {
            document.getElementById('onboardingOverlay').classList.remove('active');
        }

        function goToOnboardingScreen(screenNum) {
            document.querySelectorAll('.onboarding-screen').forEach(s => s.classList.remove('active'));
            const screen = document.querySelector(`.onboarding-screen[data-screen="${screenNum}"]`);
            if (screen) screen.classList.add('active');

            // Update progress dots
            document.querySelectorAll('.progress-dot').forEach((dot, idx) => {
                dot.classList.remove('active', 'completed');
                if (idx + 1 < screenNum) dot.classList.add('completed');
                if (idx + 1 === screenNum) dot.classList.add('active');
            });

            // Focus name input on screen 2
            if (screenNum === 2) {
                setTimeout(() => document.getElementById('onboardingName')?.focus(), 300);
            }

            // Update final preview on screen 5
            if (screenNum === 5) {
                document.getElementById('finalAvatarPreview').innerHTML = onboardingData.avatar;
                document.getElementById('finalNamePreview').textContent = onboardingData.name || 'Friend';
            }
        }

        async function completeOnboarding() {
            // Save profile to Firestore
            try {
                await db.collection('users').doc(currentUser.uid).set({
                    displayName: onboardingData.name || '',
                    avatar: onboardingData.avatar,
                    personality: onboardingData.personality,
                    onboardingComplete: true,
                    onboardingDate: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });

                // Update local state
                userProfile = {
                    displayName: onboardingData.name,
                    avatar: onboardingData.avatar,
                    personality: onboardingData.personality
                };

                updateProfileUI();
                hideOnboarding();
                showToast('Welcome to Mysa!');
            } catch (error) {
                console.error('[Onboarding] Error saving:', error);
                showToast('Error saving profile');
            }
        }

        // Initialize onboarding event listeners
        function initOnboarding() {
            // Screen 1: Welcome -> Name
            document.getElementById('onboardingNext1')?.addEventListener('click', () => {
                goToOnboardingScreen(2);
            });

            // Screen 2: Name
            const nameInput = document.getElementById('onboardingName');
            const nameNextBtn = document.getElementById('onboardingNext2');

            nameInput?.addEventListener('input', () => {
                onboardingData.name = nameInput.value.trim();
                nameNextBtn.disabled = onboardingData.name.length === 0;
            });

            nameNextBtn?.addEventListener('click', () => {
                goToOnboardingScreen(3);
            });

            document.getElementById('onboardingSkip2')?.addEventListener('click', () => {
                onboardingData.name = '';
                goToOnboardingScreen(3);
            });

            // Screen 3: Avatar
            document.getElementById('avatarPicker')?.addEventListener('click', (e) => {
                const option = e.target.closest('.avatar-option');
                if (!option) return;

                document.querySelectorAll('#avatarPicker .avatar-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                onboardingData.avatar = option.dataset.avatar;
            });

            document.getElementById('onboardingNext3')?.addEventListener('click', () => {
                goToOnboardingScreen(4);
            });

            document.getElementById('onboardingSkip3')?.addEventListener('click', () => {
                goToOnboardingScreen(4);
            });

            // Screen 4: Personality
            document.getElementById('personalityPicker')?.addEventListener('click', (e) => {
                const option = e.target.closest('.personality-option');
                if (!option) return;

                document.querySelectorAll('.personality-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                onboardingData.personality = option.dataset.personality;
            });

            document.getElementById('onboardingNext4')?.addEventListener('click', () => {
                goToOnboardingScreen(5);
            });

            // Screen 5: Finish
            document.getElementById('onboardingFinish')?.addEventListener('click', () => {
                completeOnboarding();
            });
        }

        // =====================================================
        // PROFILE MANAGEMENT
        // =====================================================
        function updateProfileUI() {
            const avatarEl = document.getElementById('profileAvatarEmoji');
            const nameEl = document.getElementById('profileDisplayName');
            const emailEl = document.getElementById('profileEmail');
            const personalityLabel = document.getElementById('personalitySettingLabel');

            if (avatarEl) avatarEl.innerHTML = userProfile.avatar || '&#128512;';
            if (nameEl) nameEl.textContent = userProfile.displayName || currentUser?.email?.split('@')[0] || 'Friend';
            if (emailEl) emailEl.textContent = currentUser?.email || '';

            const personalityLabels = {
                'off': 'Personality: Zen Mode',
                'subtle': 'Personality: Subtle',
                'fun': 'Personality: Full Fun'
            };
            if (personalityLabel) {
                personalityLabel.textContent = personalityLabels[userProfile.personality] || personalityLabels.subtle;
            }

            updatePersonalityFooter();
        }

        async function loadUserProfile() {
            try {
                console.log('[Profile] Loading profile for:', currentUser.uid);
                const doc = await db.collection('users').doc(currentUser.uid).get();
                if (doc.exists) {
                    const data = doc.data();
                    console.log('[Profile] Loaded from Firestore:', data);
                    userProfile = {
                        displayName: data.displayName || '',
                        avatar: data.avatar || '&#128512;',
                        personality: data.personality || 'subtle'
                    };
                    console.log('[Profile] userProfile set to:', userProfile);
                    return data.onboardingComplete || false;
                } else {
                    console.log('[Profile] No existing profile document');
                }
            } catch (error) {
                console.error('[Profile] Error loading:', error);
            }
            return false;
        }

        async function updateUserProfile(updates) {
            try {
                await db.collection('users').doc(currentUser.uid).set(updates, { merge: true });
                Object.assign(userProfile, updates);
                updateProfileUI();
                showToast('Profile updated!');
            } catch (error) {
                console.error('[Profile] Error updating:', error);
                showToast('Error updating profile');
            }
        }

        async function showEditNamePrompt() {
            const currentName = userProfile.displayName || '';
            const newName = prompt('Enter your display name:', currentName);

            console.log('[Profile] Edit name dialog - current:', currentName, 'new:', newName);

            if (newName === null) {
                console.log('[Profile] User cancelled');
                return;
            }

            const trimmedName = newName.trim();
            if (trimmedName === '') {
                showToast('Name cannot be empty');
                return;
            }

            if (trimmedName === currentName) {
                console.log('[Profile] Name unchanged');
                return;
            }

            console.log('[Profile] Saving new display name:', trimmedName);

            try {
                // Save to Firestore
                await db.collection('users').doc(currentUser.uid).set({
                    displayName: trimmedName
                }, { merge: true });

                console.log('[Profile] SUCCESS - Display name saved to Firestore');

                // Verify it saved
                const verify = await db.collection('users').doc(currentUser.uid).get();
                console.log('[Profile] Verification - Firestore now has:', verify.data());

                // Update local state
                userProfile.displayName = trimmedName;

                // Update UI
                updateProfileUI();
                updateHeader();

                // Clear name cache so other items refresh
                delete userNameCache[currentUser.uid];

                showToast('Name saved!');

            } catch (error) {
                console.error('[Profile] FAILED to save:', error);
                showToast('Failed to save. Try again.');
            }
        }

        function cyclePersonality() {
            const order = ['off', 'subtle', 'fun'];
            const currentIdx = order.indexOf(userProfile.personality);
            const nextIdx = (currentIdx + 1) % order.length;
            updateUserProfile({ personality: order[nextIdx] });
        }

        // API Key prompt
        function showApiKeyPrompt() {
            const currentKey = getClaudeApiKey();
            const maskedKey = currentKey ? `${currentKey.substring(0, 12)}...${currentKey.substring(currentKey.length - 4)}` : '(not set)';

            const newKey = prompt(
                `Claude API Key for Smart Categorization\n\nCurrent: ${maskedKey}\n\nEnter your Claude API key (or leave empty to disable AI features):`,
                currentKey
            );

            if (newKey === null) return; // Cancelled

            setClaudeApiKey(newKey.trim());

            if (newKey.trim()) {
                showToast('API key saved!');
            } else {
                showToast('API key cleared');
            }
        }

        // =====================================================
        // EDIT ITEM MODAL
        // =====================================================
        let currentEditingItemId = null;

        function showEditItemModal(itemId, itemText, itemCategory) {
            currentEditingItemId = itemId;

            // Populate fields
            document.getElementById('editItemText').value = itemText;
            document.getElementById('editItemCategory').value = itemCategory || 'other';

            // Show modal
            document.getElementById('editItemModal').style.display = 'flex';

            // Focus on text input
            setTimeout(() => {
                document.getElementById('editItemText').focus();
                document.getElementById('editItemText').select();
            }, 100);
        }

        function closeEditItemModal() {
            document.getElementById('editItemModal').style.display = 'none';
            currentEditingItemId = null;
        }

        async function saveEditedItem() {
            if (!currentEditingItemId) return;

            const newText = document.getElementById('editItemText').value.trim();
            const newCategory = document.getElementById('editItemCategory').value;

            if (!newText) {
                showToast('Please enter an item name');
                return;
            }

            try {
                // Update Firestore
                await db.collection('lists').doc(lists.shopping)
                    .collection('items').doc(currentEditingItemId)
                    .update({
                        text: newText,
                        category: newCategory
                    });

                // Save user preference for future items
                userCategoryPrefs[newText.toLowerCase().trim()] = {
                    corrected: newText,
                    category: newCategory
                };
                saveUserCategoryPrefs();

                // Also update AI cache so this exact text uses this category
                categoryCache[newText.toLowerCase().trim()] = {
                    original: newText,
                    corrected: newText,
                    category: newCategory,
                    confidence: 'high'
                };
                saveCategoryCache();

                closeEditItemModal();

                const cat = SHOPPING_CATEGORIES.find(c => c.id === newCategory);
                showToast(`Moved to ${cat.emoji} ${cat.name}`);

            } catch (error) {
                console.error('[Edit] Error saving:', error);
                showToast('Failed to save changes');
            }
        }

        // Close edit modal when clicking outside
        document.getElementById('editItemModal')?.addEventListener('click', (e) => {
            if (e.target.classList.contains('edit-item-modal-overlay')) {
                closeEditItemModal();
            }
        });

        // Avatar modal
        function showAvatarModal() {
            const modal = document.getElementById('avatarModal');
            modal?.classList.add('active');

            // Mark current avatar as selected
            const currentAvatar = userProfile.avatar;
            document.querySelectorAll('#avatarGrid .avatar-grid-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.avatar === currentAvatar);
            });
        }

        function hideAvatarModal() {
            document.getElementById('avatarModal')?.classList.remove('active');
        }

        function initProfileHandlers() {
            // Avatar click to open modal
            document.getElementById('profileAvatarLarge')?.addEventListener('click', showAvatarModal);

            // Avatar grid selection
            document.getElementById('avatarGrid')?.addEventListener('click', (e) => {
                const item = e.target.closest('.avatar-grid-item');
                if (!item) return;

                document.querySelectorAll('#avatarGrid .avatar-grid-item').forEach(i => i.classList.remove('selected'));
                item.classList.add('selected');
                updateUserProfile({ avatar: item.dataset.avatar });
            });

            // Close avatar modal
            document.getElementById('avatarModalClose')?.addEventListener('click', hideAvatarModal);
            document.getElementById('avatarModal')?.addEventListener('click', (e) => {
                if (e.target.id === 'avatarModal') hideAvatarModal();
            });

            // Edit name button
            document.getElementById('editNameBtn')?.addEventListener('click', showEditNamePrompt);

            // Personality setting button
            document.getElementById('personalitySettingBtn')?.addEventListener('click', cyclePersonality);

            // API key setting button
            document.getElementById('apiKeySettingBtn')?.addEventListener('click', showApiKeyPrompt);
        }

        // =====================================================
        // OFFLINE/ONLINE HANDLERS
        // =====================================================
        window.addEventListener('online', () => {
            document.getElementById('offlineIndicator').classList.remove('visible');
            showToast('Back online!');
        });

        window.addEventListener('offline', () => {
            document.getElementById('offlineIndicator').classList.add('visible');
        });

        // Check initial state
        if (!navigator.onLine) {
            document.getElementById('offlineIndicator').classList.add('visible');
        }

        // State
        let currentUser = null;
        let currentTab = 'tasks'; // 'tasks', 'shopping', or 'profile'
        let lists = { tasks: null, shopping: null }; // List IDs
        let listData = { tasks: null, shopping: null }; // Full list documents
        let itemCounts = { tasks: 0, shopping: 0 };
        let completedCounts = { tasks: 0, shopping: 0 };
        let unsubscribeItems = null;
        let unsubscribeList = null;
        const pendingDeletions = new Map(); // itemId -> timeoutId for auto-delete

        // DOM Elements
        const authContainer = document.getElementById('authContainer');
        const appContainer = document.getElementById('appContainer');
        const pageTitle = document.getElementById('pageTitle');
        const headerSubtitle = document.getElementById('headerSubtitle');
        const authError = document.getElementById('authError');
        const shareBtn = document.getElementById('shareBtn');
        const shareModal = document.getElementById('shareModal');
        const modalClose = document.getElementById('modalClose');
        const inviteEmail = document.getElementById('inviteEmail');
        const inviteBtn = document.getElementById('inviteBtn');
        const inviteSection = document.getElementById('inviteSection');
        const shareMessage = document.getElementById('shareMessage');
        const collaboratorList = document.getElementById('collaboratorList');
        const listContent = document.getElementById('listContent');
        const profileContent = document.getElementById('profileContent');
        const addInputContainer = document.getElementById('addInputContainer');
        const itemInput = document.getElementById('itemInput');

        // =====================================================
        // SHARING MODULE
        // =====================================================
        const SharingModule = {
            async findUserByEmail(email) {
                const usersRef = db.collection('users');
                const snapshot = await usersRef.where('email', '==', email.toLowerCase()).limit(1).get();
                if (!snapshot.empty) {
                    const doc = snapshot.docs[0];
                    return { id: doc.id, ...doc.data() };
                }
                return null;
            },

            async saveUserProfile(user) {
                const userRef = db.collection('users').doc(user.uid);

                // Check if user document already exists
                const existingDoc = await userRef.get();

                if (existingDoc.exists) {
                    // EXISTING USER - DO NOT overwrite displayName!
                    // Only update email (if changed) and lastLogin
                    console.log('[Profile] Existing user, preserving displayName');
                    await userRef.set({
                        email: user.email.toLowerCase(),
                        lastLogin: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                } else {
                    // NEW USER - create profile with Google name as default
                    console.log('[Profile] New user, setting initial displayName');
                    await userRef.set({
                        email: user.email.toLowerCase(),
                        displayName: user.displayName || user.email.split('@')[0],
                        lastLogin: firebase.firestore.FieldValue.serverTimestamp(),
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
            },

            async addCollaborator(listId, collaboratorEmail) {
                const collaborator = await this.findUserByEmail(collaboratorEmail);

                if (!collaborator) {
                    throw new Error('User not found. They need to sign up first.');
                }

                if (collaborator.id === currentUser.uid) {
                    throw new Error('You cannot share a list with yourself.');
                }

                const listRef = db.collection('lists').doc(listId);
                const listDoc = await listRef.get();

                if (!listDoc.exists) {
                    throw new Error('List not found.');
                }

                const data = listDoc.data();

                if (data.ownerId !== currentUser.uid) {
                    throw new Error('Only the owner can share this list.');
                }

                if (data.sharedWith && data.sharedWith.includes(collaborator.id)) {
                    throw new Error('Already shared with this user.');
                }

                const collaboratorData = {
                    email: collaborator.email,
                    displayName: collaborator.displayName || null,
                    addedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    addedBy: currentUser.uid,
                    role: 'collaborator'
                };

                // Share the current list
                await listRef.update({
                    sharedWith: firebase.firestore.FieldValue.arrayUnion(collaborator.id),
                    [`collaborators.${collaborator.id}`]: collaboratorData
                });

                // ALSO share the OTHER list (tasks <-> shopping are linked)
                const otherType = data.type === 'tasks' ? 'shopping' : 'tasks';
                const otherListId = lists[otherType];

                if (otherListId) {
                    const otherListRef = db.collection('lists').doc(otherListId);
                    const otherListDoc = await otherListRef.get();

                    if (otherListDoc.exists && otherListDoc.data().ownerId === currentUser.uid) {
                        const otherData = otherListDoc.data();
                        // Only add if not already shared
                        if (!otherData.sharedWith || !otherData.sharedWith.includes(collaborator.id)) {
                            await otherListRef.update({
                                sharedWith: firebase.firestore.FieldValue.arrayUnion(collaborator.id),
                                [`collaborators.${collaborator.id}`]: collaboratorData
                            });
                            console.log(`[Sharing] Also shared ${otherType} list with ${collaborator.email}`);
                        }
                    }
                }

                console.log(`[Sharing] Shared ${data.type} list with ${collaborator.email}`);
                return collaborator;
            },

            async removeCollaborator(listId, collaboratorId) {
                const listRef = db.collection('lists').doc(listId);
                const listDoc = await listRef.get();

                if (!listDoc.exists) {
                    throw new Error('List not found.');
                }

                const data = listDoc.data();

                if (data.ownerId !== currentUser.uid) {
                    throw new Error('Only the owner can remove collaborators.');
                }

                // Remove from current list
                await listRef.update({
                    sharedWith: firebase.firestore.FieldValue.arrayRemove(collaboratorId),
                    [`collaborators.${collaboratorId}`]: firebase.firestore.FieldValue.delete()
                });

                // ALSO remove from the OTHER list (tasks <-> shopping are linked)
                const otherType = data.type === 'tasks' ? 'shopping' : 'tasks';
                const otherListId = lists[otherType];

                if (otherListId) {
                    const otherListRef = db.collection('lists').doc(otherListId);
                    const otherListDoc = await otherListRef.get();

                    if (otherListDoc.exists && otherListDoc.data().ownerId === currentUser.uid) {
                        await otherListRef.update({
                            sharedWith: firebase.firestore.FieldValue.arrayRemove(collaboratorId),
                            [`collaborators.${collaboratorId}`]: firebase.firestore.FieldValue.delete()
                        });
                        console.log(`[Sharing] Also removed from ${otherType} list`);
                    }
                }
            },

            isOwner(listDoc) {
                return listDoc && listDoc.ownerId === currentUser.uid;
            },

            isShared(listDoc) {
                return listDoc && listDoc.sharedWith && listDoc.sharedWith.length > 0;
            },

            getCollaborators(listDoc) {
                if (!listDoc || !listDoc.collaborators) return [];
                return Object.entries(listDoc.collaborators).map(([id, data]) => ({
                    id,
                    ...data
                }));
            }
        };

        // =====================================================
        // UTILITY FUNCTIONS
        // =====================================================
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Escape text for use in onclick attributes
        function escapeForAttr(text) {
            if (!text) return '';
            return text.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, ' ');
        }

        function showError(message) {
            authError.textContent = message;
            authError.classList.add('show');
            setTimeout(() => authError.classList.remove('show'), 5000);
        }

        function truncateEmail(email) {
            if (!email) return '';
            const parts = email.split('@');
            const name = parts[0];
            return name.length > 12 ? name.substring(0, 12) + '...' : name;
        }

        // User name cache for display names
        const userNameCache = {};

        async function getDisplayName(userId, fallbackEmail) {
            // If it's current user
            if (userId === currentUser?.uid) {
                return 'You';
            }

            // Check cache first
            if (userNameCache[userId]) {
                return userNameCache[userId];
            }

            // Fetch from Firestore users collection
            try {
                console.log('[Profile] Fetching display name for user:', userId);
                const userDoc = await db.collection('users').doc(userId).get();
                if (userDoc.exists) {
                    const data = userDoc.data();
                    const name = data.displayName || fallbackEmail?.split('@')[0] || 'Someone';
                    console.log('[Profile] Found display name:', name, 'for user:', userId);
                    userNameCache[userId] = name;
                    return name;
                } else {
                    console.log('[Profile] No user document found for:', userId);
                }
            } catch (e) {
                console.error('[Profile] Error fetching user:', e);
            }

            // Fallback to email prefix
            const name = fallbackEmail?.split('@')[0] || 'Someone';
            if (userId) userNameCache[userId] = name;
            return name;
        }

        function getAddedByText(item) {
            // Compare by UID (primary) or email (fallback for old items)
            if (item.createdBy === currentUser?.uid) {
                return 'added by You';
            }
            // Fallback: compare emails (case-insensitive) for old items without UID
            if (item.createdByEmail && currentUser?.email &&
                item.createdByEmail.toLowerCase() === currentUser.email.toLowerCase()) {
                return 'added by You';
            }
            // Return placeholder with email prefix or cached name - will be updated async
            if (item.createdByEmail) {
                // Check cache for immediate display
                if (item.createdBy && userNameCache[item.createdBy]) {
                    return `added by ${userNameCache[item.createdBy]}`;
                }
                const name = item.createdByEmail.split('@')[0];
                return `added by ${name}`;
            }
            return '';
        }

        // Update display names asynchronously after render
        async function updateItemDisplayNames() {
            const metaElements = document.querySelectorAll('.item-meta[data-creator-id]');

            for (const el of metaElements) {
                const creatorId = el.dataset.creatorId;
                const creatorEmail = el.dataset.creatorEmail;

                if (!creatorId || creatorId === currentUser?.uid) continue;

                // Fetch display name
                const displayName = await getDisplayName(creatorId, creatorEmail);

                // Update the element if it still exists
                if (el.isConnected) {
                    el.textContent = `added by ${displayName}`;
                }
            }
        }

        // =====================================================
        // UI UPDATE FUNCTIONS
        // =====================================================
        function updateHeader() {
            if (currentTab === 'profile') {
                pageTitle.textContent = 'Profile';
                headerSubtitle.textContent = '';
                shareBtn.classList.add('hidden');
            } else {
                const title = currentTab === 'tasks' ? 'Tasks' : 'Shopping';
                pageTitle.textContent = title;

                // Use display name if available, otherwise email
                const displayName = userProfile.displayName || truncateEmail(currentUser?.email);
                const total = itemCounts[currentTab] || 0;
                const completed = completedCounts[currentTab] || 0;
                const remaining = total - completed;

                let countText;
                if (total === 0) {
                    countText = 'No items';
                } else if (completed > 0) {
                    countText = `${remaining} remaining`;
                } else {
                    countText = `${total} item${total !== 1 ? 's' : ''}`;
                }

                headerSubtitle.textContent = `${displayName}  ${countText}`;

                shareBtn.classList.remove('hidden');

                // Update share button state
                const data = listData[currentTab];
                if (data && (SharingModule.isShared(data) || !SharingModule.isOwner(data))) {
                    shareBtn.classList.add('has-collaborators');
                } else {
                    shareBtn.classList.remove('has-collaborators');
                }
            }
        }

        function updatePlaceholder() {
            const placeholder = currentTab === 'tasks' ? 'Add a task...' : 'Add an item...';
            itemInput.placeholder = placeholder;

            // Show/hide category picker buttons based on tab
            const shoppingCategoryBtn = document.getElementById('categoryPickerBtn');
            const taskCategoryBtn = document.getElementById('taskCategoryPickerBtn');

            if (shoppingCategoryBtn) {
                shoppingCategoryBtn.style.display = currentTab === 'shopping' ? 'flex' : 'none';
            }
            if (taskCategoryBtn) {
                taskCategoryBtn.style.display = currentTab === 'tasks' ? 'flex' : 'none';
            }
        }

        // =====================================================
        // NAVIGATION
        // =====================================================
        function switchTab(tab) {
            currentTab = tab;

            // Update nav buttons
            document.querySelectorAll('.nav-item').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });

            // Show/hide content
            if (tab === 'profile') {
                listContent.classList.add('hidden');
                profileContent.classList.add('active');
                addInputContainer.classList.add('hidden');
                updatePersonalityFooter(); // Refresh personality message
            } else {
                listContent.classList.remove('hidden');
                profileContent.classList.remove('active');
                addInputContainer.classList.remove('hidden');
                subscribeToItems();
            }

            updateHeader();
            updatePlaceholder();
        }

        // =====================================================
        // SHOPPING LIST MIGRATION (one-time merge of duplicates)
        // =====================================================
        async function migrateShoppingLists() {
            console.log('[Migration] Checking for duplicate shopping lists...');

            // Check if already migrated
            const userDoc = await db.collection('users').doc(currentUser.uid).get();
            if (userDoc.data()?.shoppingMigrated) {
                console.log('[Migration] Already migrated, skipping');
                return;
            }

            const listsRef = db.collection('lists');

            // Get all shopping lists user can access
            const ownedSnapshot = await listsRef
                .where('type', '==', 'shopping')
                .where('ownerId', '==', currentUser.uid)
                .get();

            const sharedSnapshot = await listsRef
                .where('type', '==', 'shopping')
                .where('sharedWith', 'array-contains', currentUser.uid)
                .get();

            const ownedLists = ownedSnapshot.docs;
            const sharedLists = sharedSnapshot.docs;
            const allLists = [...sharedLists, ...ownedLists];

            // Remove duplicates by ID
            const uniqueLists = allLists.filter((doc, index, self) =>
                index === self.findIndex(d => d.id === doc.id)
            );

            console.log('[Migration] Found lists:', uniqueLists.length, 'owned:', ownedLists.length, 'shared:', sharedLists.length);

            if (uniqueLists.length <= 1) {
                await markMigrationComplete();
                return;
            }

            // Use shared list as master (so both users see same list), or first owned
            const masterList = sharedLists[0] || ownedLists[0];
            console.log('[Migration] Master list:', masterList.id, 'owner:', masterList.data().ownerEmail);

            // Merge all items into master list
            for (const list of uniqueLists) {
                if (list.id === masterList.id) continue;

                console.log('[Migration] Merging list:', list.id, 'into master');

                const items = await list.ref.collection('items').get();
                console.log('[Migration] Moving', items.docs.length, 'items');

                for (const item of items.docs) {
                    // Add item to master list
                    await masterList.ref.collection('items').add(item.data());
                    // Delete from old list
                    await item.ref.delete();
                }

                // Delete the duplicate list
                await list.ref.delete();
                console.log('[Migration] Deleted duplicate list:', list.id);
            }

            await markMigrationComplete();
            console.log('[Migration] Complete!');
        }

        async function markMigrationComplete() {
            await db.collection('users').doc(currentUser.uid).set({
                shoppingMigrated: true,
                migrationDate: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true });
        }

        // =====================================================
        // PWA VISIBILITY REFRESH
        // =====================================================
        async function refreshCurrentList() {
            if (!lists[currentTab] || currentTab === 'profile') return;
            console.log('[PWA] Refreshing current list...');

            const listId = lists[currentTab];
            const itemsRef = db.collection('lists').doc(listId).collection('items');

            try {
                const snapshot = await itemsRef.get();
                renderItems(snapshot);
            } catch (error) {
                console.error('[PWA] Refresh error:', error);
            }
        }

        // Refresh when app becomes visible (PWA returning from background)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible' && currentUser) {
                console.log('[PWA] App became visible, refreshing...');
                refreshCurrentList();
            }
        });

        window.addEventListener('focus', () => {
            if (currentUser) {
                console.log('[PWA] Window focused, refreshing...');
                refreshCurrentList();
            }
        });

        // =====================================================
        // LIST INITIALIZATION
        // =====================================================
        async function initializeLists() {
            const listsRef = db.collection('lists');

            console.log('[Init] Initializing lists for user:', currentUser.email);

            // Helper function to find or create a list
            async function findOrCreateList(type) {
                // FIRST: Check if user has a SHARED list (prioritize collaboration)
                let sharedQuery = await listsRef
                    .where('sharedWith', 'array-contains', currentUser.uid)
                    .where('type', '==', type)
                    .limit(1)
                    .get();

                if (!sharedQuery.empty) {
                    const doc = sharedQuery.docs[0];
                    console.log(`[Init] Found SHARED ${type} list:`, doc.id, 'owner:', doc.data().ownerEmail);
                    return doc.id;
                }

                // SECOND: Check if user OWNS a list
                let ownedQuery = await listsRef
                    .where('ownerId', '==', currentUser.uid)
                    .where('type', '==', type)
                    .limit(1)
                    .get();

                if (!ownedQuery.empty) {
                    const doc = ownedQuery.docs[0];
                    console.log(`[Init] Found OWNED ${type} list:`, doc.id, 'sharedWith:', doc.data().sharedWith);
                    return doc.id;
                }

                // THIRD: Create new list
                console.log(`[Init] Creating NEW ${type} list for:`, currentUser.email);
                const docRef = await listsRef.add({
                    type: type,
                    name: type === 'tasks' ? 'Tasks' : 'Shopping',
                    ownerId: currentUser.uid,
                    ownerEmail: currentUser.email,
                    sharedWith: [],
                    collaborators: {},
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                return docRef.id;
            }

            // Initialize both lists
            lists.tasks = await findOrCreateList('tasks');
            lists.shopping = await findOrCreateList('shopping');

            console.log('[Init] Final lists:', { tasks: lists.tasks, shopping: lists.shopping });
        }

        // =====================================================
        // ITEMS RENDERING
        // =====================================================
        function renderItems(snapshot, isUserAction = false) {
            const listEl = document.getElementById('itemList');
            hideSkeletons();

            if (snapshot.empty) {
                const isTasksTab = currentTab === 'tasks';
                const icon = isTasksTab ? '&#10024;' : '&#128722;';
                const title = isTasksTab ? 'All done!' : 'Shopping list is empty';
                const subtitle = isTasksTab
                    ? 'No tasks right now. Enjoy your free time!'
                    : 'Add items and they\'ll be auto-organized!';

                listEl.innerHTML = `
                    <li class="empty-state">
                        <div class="empty-state-icon">${icon}</div>
                        <h3>${title}</h3>
                        <p>${subtitle}</p>
                    </li>
                `;
                itemCounts[currentTab] = 0;
                completedCounts[currentTab] = 0;
                updateHeader();
                return;
            }

            const items = [];
            snapshot.forEach(doc => {
                items.push({ id: doc.id, ...doc.data() });
            });

            const completedCount = items.filter(i => i.done).length;
            itemCounts[currentTab] = items.length;
            completedCounts[currentTab] = completedCount;
            updateHeader();

            // Use category view for both tabs
            if (currentTab === 'shopping') {
                renderShoppingWithCategories(listEl, items, completedCount);
            } else {
                renderTasksWithCategories(listEl, items, completedCount);
                // Check for old tasks that might need attention
                checkOldTasks(items);
            }

            // Update display names asynchronously
            updateItemDisplayNames();

            // Initialize swipe handlers for new items
            initSwipeHandlers();
        }

        // Render tasks with category sections
        function renderTasksWithCategories(listEl, items, completedCount) {
            // Group items by category
            const grouped = {};
            TASK_CATEGORIES.forEach(cat => {
                grouped[cat.id] = [];
            });

            items.forEach(item => {
                const cat = item.category || 'other';
                if (grouped[cat]) {
                    grouped[cat].push(item);
                } else {
                    grouped['other'].push(item);
                }
            });

            // Sort items within each category by: incomplete first, then priority, then date
            const priorityOrder = { high: 0, medium: 1, none: 2, undefined: 2 };
            for (const catItems of Object.values(grouped)) {
                catItems.sort((a, b) => {
                    if (a.done !== b.done) return a.done ? 1 : -1;
                    const aPriority = priorityOrder[a.priority] ?? 2;
                    const bPriority = priorityOrder[b.priority] ?? 2;
                    if (aPriority !== bPriority) return aPriority - bPriority;
                    const aTime = a.createdAt?.toMillis() || 0;
                    const bTime = b.createdAt?.toMillis() || 0;
                    return aTime - bTime;
                });
            }

            const taskCollapsed = JSON.parse(localStorage.getItem('taskCollapsedSections') || '{}');

            const getPriorityClass = (priority) => {
                if (priority === 'high') return 'priority-high';
                if (priority === 'medium') return 'priority-medium';
                return 'priority-none';
            };

            let html = '';
            let hasItems = false;

            // Render regular categories (not fuckit)
            const regularCategories = TASK_CATEGORIES.filter(c => c.id !== 'fuckit');

            regularCategories.forEach(category => {
                const categoryItems = grouped[category.id];
                if (categoryItems.length === 0) return;
                hasItems = true;

                const doneCount = categoryItems.filter(i => i.done).length;
                const remaining = categoryItems.length - doneCount;
                const isCollapsed = taskCollapsed[category.id] || false;
                const allDone = remaining === 0;

                html += `
                    <li class="category-section ${allDone ? 'all-done' : ''}" data-category="${category.id}">
                        <div class="category-header" onclick="toggleTaskSection('${category.id}')">
                            <div class="category-info">
                                <span class="category-emoji">${category.emoji}</span>
                                <span class="category-name">${category.name}</span>
                                <span class="category-count">${allDone ? '' : remaining + ' left'}</span>
                            </div>
                            <span class="category-toggle">${isCollapsed ? '' : ''}</span>
                        </div>
                        <div class="category-items ${isCollapsed ? 'collapsed' : ''}">
                            ${categoryItems.map(item => `
                                <div class="task-item ${item.done ? 'done' : ''}" data-id="${item.id}"
                                     ontouchstart="startTaskLongPress(event, '${item.id}', '${escapeForAttr(item.text)}', '${item.category || 'other'}')"
                                     ontouchend="cancelTaskLongPress()" ontouchmove="cancelTaskLongPress()">
                                    <div class="item-checkbox ${item.done ? 'checked' : ''}" data-action="toggle">
                                        ${item.done ? '' : ''}
                                    </div>
                                    <div class="item-content">
                                        <span class="item-text">${escapeHtml(item.text)}</span>
                                    </div>
                                    <button class="priority-btn" data-action="priority" title="Change priority">
                                        <span class="priority-dot ${getPriorityClass(item.priority)}"></span>
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    </li>
                `;
            });

            // Render Fuck It Bucket separately at the bottom (if has items)
            const fuckitItems = grouped['fuckit'];
            if (fuckitItems.length > 0) {
                const isCollapsed = taskCollapsed['fuckit'] || false;
                html += `
                    <li class="category-section fuckit-section" data-category="fuckit">
                        <div class="category-header fuckit-header" onclick="toggleTaskSection('fuckit')">
                            <div class="category-info">
                                <span class="category-emoji"></span>
                                <span class="category-name">Fuck It Bucket</span>
                                <span class="category-count">${fuckitItems.length} released</span>
                            </div>
                            <span class="category-toggle">${isCollapsed ? '' : ''}</span>
                        </div>
                        <div class="category-items ${isCollapsed ? 'collapsed' : ''}">
                            ${fuckitItems.map(item => `
                                <div class="task-item fuckit-item" data-id="${item.id}">
                                    <div class="item-content">
                                        <span class="item-text">${escapeHtml(item.text)}</span>
                                        <span class="item-meta">let go ${formatTimeAgo(item.fuckitAt)}</span>
                                    </div>
                                    <button class="restore-btn" onclick="restoreFromFuckit('${item.id}')" title="Restore task"></button>
                                </div>
                            `).join('')}
                        </div>
                    </li>
                `;
            }

            // Clear completed button removed - items auto-delete after 3 seconds

            // Add personality message footer
            const message = getPersonalityMessage();
            if (message && (hasItems || fuckitItems.length > 0)) {
                html += `
                    <li class="personality-footer">
                        <span class="personality-message">"${message}"</span>
                    </li>
                `;
            }

            listEl.innerHTML = html;
        }

        function toggleTaskSection(catId) {
            const collapsed = JSON.parse(localStorage.getItem('taskCollapsedSections') || '{}');
            collapsed[catId] = !collapsed[catId];
            localStorage.setItem('taskCollapsedSections', JSON.stringify(collapsed));

            const section = document.querySelector(`[data-category="${catId}"]`);
            if (!section) return;
            const items = section.querySelector('.category-items');
            const toggle = section.querySelector('.category-toggle');
            items?.classList.toggle('collapsed');
            if (toggle) toggle.textContent = collapsed[catId] ? '' : '';
        }

        function formatTimeAgo(timestamp) {
            if (!timestamp) return 'recently';
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            const now = new Date();
            const diffDays = Math.floor((now - date) / (1000 * 60 * 60 * 24));

            if (diffDays === 0) return 'today';
            if (diffDays === 1) return 'yesterday';
            if (diffDays < 7) return `${diffDays} days ago`;
            if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
            return `${Math.floor(diffDays / 30)} months ago`;
        }

        // Render shopping list with category sections
        function renderShoppingWithCategories(listEl, items, completedCount) {
            // Group items by category
            const grouped = {};
            SHOPPING_CATEGORIES.forEach(cat => {
                grouped[cat.id] = [];
            });

            items.forEach(item => {
                const cat = item.category || 'other';
                if (grouped[cat]) {
                    grouped[cat].push(item);
                } else {
                    grouped['other'].push(item);
                }
            });

            // Sort items within each category by: incomplete first, then priority, then date
            const priorityOrder = { high: 0, medium: 1, none: 2, undefined: 2 };
            for (const catItems of Object.values(grouped)) {
                catItems.sort((a, b) => {
                    if (a.done !== b.done) return a.done ? 1 : -1;
                    const aPriority = priorityOrder[a.priority] ?? 2;
                    const bPriority = priorityOrder[b.priority] ?? 2;
                    if (aPriority !== bPriority) return aPriority - bPriority;
                    const aTime = a.createdAt?.toMillis() || 0;
                    const bTime = b.createdAt?.toMillis() || 0;
                    return aTime - bTime;
                });
            }

            const collapsedSections = getCollapsedSections();

            const getPriorityClass = (priority) => {
                if (priority === 'high') return 'priority-high';
                if (priority === 'medium') return 'priority-medium';
                return 'priority-none';
            };

            let html = '';

            // Render each category that has items
            SHOPPING_CATEGORIES.forEach(category => {
                const categoryItems = grouped[category.id];
                if (categoryItems.length === 0) return;

                const doneCount = categoryItems.filter(i => i.done).length;
                const totalCount = categoryItems.length;
                const isCollapsed = collapsedSections[category.id] || false;
                const allDone = doneCount === totalCount;

                html += `
                    <li class="category-section ${allDone ? 'all-done' : ''}" data-category="${category.id}">
                        <div class="category-header" onclick="toggleSection('${category.id}')">
                            <div class="category-info">
                                <span class="category-emoji">${category.emoji}</span>
                                <span class="category-name">${category.name}</span>
                                <span class="category-count">(${doneCount}/${totalCount})</span>
                            </div>
                            <span class="category-toggle">${isCollapsed ? '' : ''}</span>
                        </div>
                        <div class="category-items ${isCollapsed ? 'collapsed' : ''}">
                            ${categoryItems.map(item => `
                                <div class="shopping-item ${item.done ? 'done' : ''}" data-id="${item.id}"
                                     ontouchstart="startLongPress(event, '${item.id}', '${escapeForAttr(item.text)}', '${item.category || 'other'}')"
                                     ontouchend="cancelLongPress()" ontouchmove="cancelLongPress()">
                                    <div class="item-checkbox ${item.done ? 'checked' : ''}" data-action="toggle">
                                        ${item.done ? '' : ''}
                                    </div>
                                    <div class="item-content">
                                        <span class="item-text">${escapeHtml(item.text)}</span>
                                    </div>
                                    <button class="priority-btn" data-action="priority" title="Change priority">
                                        <span class="priority-dot ${getPriorityClass(item.priority)}"></span>
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    </li>
                `;
            });

            // Clear completed button removed - items auto-delete after 3 seconds

            // Add personality message footer
            const message = getPersonalityMessage();
            if (message && items.length > 0) {
                html += `
                    <li class="personality-footer">
                        <span class="personality-message">"${message}"</span>
                    </li>
                `;
            }

            listEl.innerHTML = html;
        }

        // =====================================================
        // LOADING SKELETONS
        // =====================================================
        let loadingTimer = null;

        function showSkeletons() {
            document.getElementById('itemList').innerHTML = '';
            loadingTimer = setTimeout(() => {
                document.getElementById('skeletonContainer').style.display = 'block';
            }, 200); // Only show if loading > 200ms
        }

        function hideSkeletons() {
            clearTimeout(loadingTimer);
            document.getElementById('skeletonContainer').style.display = 'none';
        }

        // =====================================================
        // SUBSCRIBE TO ITEMS
        // =====================================================
        function subscribeToItems() {
            if (unsubscribeItems) unsubscribeItems();
            if (unsubscribeList) unsubscribeList();

            const listId = lists[currentTab];
            if (!listId) return;

            const listRef = db.collection('lists').doc(listId);
            const itemsRef = listRef.collection('items');

            showSkeletons();

            // Subscribe to list document
            unsubscribeList = listRef.onSnapshot(doc => {
                if (doc.exists) {
                    listData[currentTab] = { id: doc.id, ...doc.data() };
                    updateHeader();
                }
            });

            // Subscribe to items
            unsubscribeItems = itemsRef.onSnapshot(snapshot => {
                renderItems(snapshot);
            }, error => {
                console.error('Error:', error);
                hideSkeletons();
                document.getElementById('itemList').innerHTML =
                    '<li class="empty-state"><h3>Oops!</h3><p>Error loading. Please refresh.</p></li>';
            });
        }

        // =====================================================
        // ITEM ACTIONS
        // =====================================================
        async function addItem() {
            const text = itemInput.value.trim();
            if (!text || !currentUser) return;

            const listId = lists[currentTab];
            if (!listId) return;

            // For tasks tab, use category-based add
            if (currentTab !== 'shopping') {
                try {
                    await db.collection('lists').doc(listId).collection('items').add({
                        text: text,
                        done: false,
                        category: selectedTaskCategory,
                        priority: 'none',
                        createdBy: currentUser.uid,
                        createdByEmail: currentUser.email,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    const cat = TASK_CATEGORIES.find(c => c.id === selectedTaskCategory);
                    showToast(`${cat?.emoji || ''} Added to ${cat?.name || 'Other'}`, 1500);

                    itemInput.value = '';
                } catch (error) {
                    console.error('Error adding item:', error);
                    showToast('Failed to add item');
                }
                return;
            }

            // For shopping tab, use smart categorization with autocorrect
            itemInput.disabled = true;
            const addBtn = document.getElementById('addBtn');
            addBtn.innerHTML = '<span class="btn-spinner"></span>';
            addBtn.disabled = true;

            try {
                // Check if user manually selected a category
                if (selectedAddCategory !== 'auto') {
                    // User manually selected category - skip AI
                    await saveShoppingItem(text, selectedAddCategory);
                    itemInput.value = '';

                    // Save user preference for future items
                    userCategoryPrefs[text.toLowerCase().trim()] = {
                        corrected: text,
                        category: selectedAddCategory
                    };
                    saveUserCategoryPrefs();

                    // Reset to auto-detect for next item
                    selectedAddCategory = 'auto';
                    document.getElementById('selectedCategoryEmoji').textContent = '';
                } else {
                    // Use AI categorization
                    const result = await smartCategorize(text);
                    console.log('[Add] Smart categorize result:', result);

                    const needsCorrection = result.corrected.toLowerCase() !== result.original.toLowerCase();
                    const shouldAskUser = needsCorrection && result.confidence !== 'high';

                    if (shouldAskUser) {
                        // Show autocorrect modal for user confirmation
                        showAutocorrectModal(result, async (accepted, finalText, finalCategory) => {
                            await saveShoppingItem(finalText, finalCategory);
                            if (accepted && finalText !== text) {
                                // Save user's preference for future
                                userCategoryPrefs[text.toLowerCase()] = {
                                    corrected: finalText,
                                    category: finalCategory
                                };
                                saveUserCategoryPrefs();
                            }
                        });
                        itemInput.value = '';
                    } else {
                        // Auto-add (high confidence or no correction needed)
                        const finalText = needsCorrection ? result.corrected : text;
                        await saveShoppingItem(finalText, result.category);
                        itemInput.value = '';

                        if (needsCorrection) {
                            showToast(`Auto-corrected to "${finalText}"`, 2000);
                        }
                    }
                }

            } catch (error) {
                console.error('Error adding item:', error);
                showToast('Failed to add item');
            } finally {
                itemInput.disabled = false;
                addBtn.innerHTML = 'Add';
                addBtn.disabled = false;
                itemInput.focus();
            }
        }

        // Save shopping item to Firestore
        async function saveShoppingItem(text, category) {
            const listId = lists['shopping'];
            if (!listId) return;

            const cat = SHOPPING_CATEGORIES.find(c => c.id === category);

            await db.collection('lists').doc(listId).collection('items').add({
                text: text,
                done: false,
                category: category,
                priority: 'none',
                createdBy: currentUser.uid,
                createdByEmail: currentUser.email,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            showToast(`${cat?.emoji || ''} Added to ${cat?.name || 'Other'}`, 1500);
        }

        // =====================================================
        // AUTOCORRECT MODAL
        // =====================================================
        let autocorrectCallback = null;
        let autocorrectResult = null;

        function showAutocorrectModal(result, callback) {
            autocorrectCallback = callback;
            autocorrectResult = result;

            const cat = SHOPPING_CATEGORIES.find(c => c.id === result.category);

            const modal = document.createElement('div');
            modal.className = 'autocorrect-modal-overlay';
            modal.id = 'autocorrectModal';
            modal.innerHTML = `
                <div class="autocorrect-modal">
                    <div class="autocorrect-header">
                        <span class="autocorrect-icon"></span>
                        <h3>Did you mean?</h3>
                    </div>
                    <div class="autocorrect-suggestion">
                        <div class="original">
                            <span class="label">You typed:</span>
                            <span class="value">"${escapeHtml(result.original)}"</span>
                        </div>
                        <div class="arrow"></div>
                        <div class="corrected">
                            <span class="label">Suggested:</span>
                            <span class="value">"${escapeHtml(result.corrected)}"</span>
                        </div>
                    </div>
                    <div class="autocorrect-category">
                        <span class="label">Category:</span>
                        <span class="value">${cat?.emoji || ''} ${cat?.name || 'Other'}</span>
                    </div>
                    <div class="autocorrect-actions">
                        <button class="btn-accept" onclick="acceptCorrection()"> Yes, use "${escapeHtml(result.corrected)}"</button>
                        <button class="btn-keep" onclick="keepOriginal()">Keep "${escapeHtml(result.original)}"</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function acceptCorrection() {
            if (autocorrectCallback && autocorrectResult) {
                autocorrectCallback(true, autocorrectResult.corrected, autocorrectResult.category);
            }
            closeAutocorrectModal();
        }

        function keepOriginal() {
            if (autocorrectCallback && autocorrectResult) {
                autocorrectCallback(false, autocorrectResult.original, autocorrectResult.category);
            }
            closeAutocorrectModal();
        }

        function closeAutocorrectModal() {
            document.getElementById('autocorrectModal')?.remove();
            autocorrectCallback = null;
            autocorrectResult = null;
        }

        // =====================================================
        // LONG-PRESS CATEGORY PICKER
        // =====================================================
        let longPressTimer = null;

        function startLongPress(event, itemId, itemText, category) {
            longPressTimer = setTimeout(() => {
                if (navigator.vibrate) navigator.vibrate(30);
                showEditItemModal(itemId, itemText, category);
            }, 500);
        }

        function cancelLongPress() {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
        }

        // =====================================================
        // ADD BAR CATEGORY PICKER
        // =====================================================
        let selectedAddCategory = 'auto'; // 'auto' means AI will detect

        function showAddCategoryPicker() {
            const modal = document.createElement('div');
            modal.className = 'add-category-picker-overlay';
            modal.id = 'addCategoryPickerModal';
            modal.onclick = (e) => {
                if (e.target === modal) closeAddCategoryPicker();
            };

            modal.innerHTML = `
                <div class="add-category-picker-modal">
                    <h3>Select Category</h3>
                    <div class="add-category-options">
                        <button class="add-category-option ${selectedAddCategory === 'auto' ? 'selected' : ''}" onclick="selectAddCategory('auto', '')">
                            <span class="cat-emoji"></span>
                            <span class="cat-name">Auto-detect</span>
                            <span class="cat-desc">AI will categorize</span>
                            ${selectedAddCategory === 'auto' ? '<span class="check"></span>' : ''}
                        </button>
                        ${SHOPPING_CATEGORIES.map(cat => `
                            <button class="add-category-option ${selectedAddCategory === cat.id ? 'selected' : ''}" onclick="selectAddCategory('${cat.id}', '${cat.emoji}')">
                                <span class="cat-emoji">${cat.emoji}</span>
                                <span class="cat-name">${cat.name}</span>
                                ${selectedAddCategory === cat.id ? '<span class="check"></span>' : ''}
                            </button>
                        `).join('')}
                    </div>
                    <button class="cancel-btn" onclick="closeAddCategoryPicker()">Cancel</button>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function closeAddCategoryPicker() {
            document.getElementById('addCategoryPickerModal')?.remove();
        }

        function selectAddCategory(categoryId, emoji) {
            selectedAddCategory = categoryId;
            document.getElementById('selectedCategoryEmoji').textContent = emoji;
            closeAddCategoryPicker();
        }

        // =====================================================
        // TASK CATEGORY PICKER (for add bar)
        // =====================================================
        let selectedTaskCategory = 'home'; // Default to Home

        function showTaskCategoryPicker() {
            const modal = document.createElement('div');
            modal.className = 'add-category-picker-overlay';
            modal.id = 'taskCategoryPickerModal';
            modal.onclick = (e) => {
                if (e.target === modal) closeTaskCategoryPicker();
            };

            // Exclude 'fuckit' from add picker - that's only for moving tasks TO
            const addableCategories = TASK_CATEGORIES.filter(c => c.id !== 'fuckit');

            modal.innerHTML = `
                <div class="add-category-picker-modal">
                    <h3>Select Category</h3>
                    <div class="add-category-options">
                        ${addableCategories.map(cat => `
                            <button class="add-category-option ${selectedTaskCategory === cat.id ? 'selected' : ''}"
                                    onclick="selectTaskCategory('${cat.id}', '${cat.emoji}')">
                                <span class="cat-emoji">${cat.emoji}</span>
                                <span class="cat-name">${cat.name}</span>
                                ${selectedTaskCategory === cat.id ? '<span class="check"></span>' : ''}
                            </button>
                        `).join('')}
                    </div>
                    <button class="cancel-btn" onclick="closeTaskCategoryPicker()">Cancel</button>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function closeTaskCategoryPicker() {
            document.getElementById('taskCategoryPickerModal')?.remove();
        }

        function selectTaskCategory(categoryId, emoji) {
            selectedTaskCategory = categoryId;
            document.getElementById('selectedTaskCategoryEmoji').textContent = emoji;
            closeTaskCategoryPicker();
        }

        // =====================================================
        // TASK LONG-PRESS ACTION MENU
        // =====================================================
        let taskLongPressTimer = null;

        function startTaskLongPress(e, itemId, itemText, itemCategory) {
            taskLongPressTimer = setTimeout(() => {
                if (navigator.vibrate) navigator.vibrate(30);
                showTaskActionMenu(itemId, itemText, itemCategory);
            }, 500);
        }

        function cancelTaskLongPress() {
            if (taskLongPressTimer) {
                clearTimeout(taskLongPressTimer);
                taskLongPressTimer = null;
            }
        }

        function showTaskActionMenu(itemId, itemText, itemCategory) {
            const modal = document.createElement('div');
            modal.className = 'task-action-menu-overlay';
            modal.id = 'taskActionMenuModal';
            modal.onclick = (e) => {
                if (e.target === modal) closeTaskActionMenu();
            };

            modal.innerHTML = `
                <div class="task-action-menu">
                    <div class="task-action-header">
                        <span class="task-action-text">"${escapeHtml(itemText)}"</span>
                    </div>
                    <div class="task-action-options">
                        <button class="task-action-btn edit" onclick="editTaskFromMenu('${itemId}', '${escapeForAttr(itemText)}', '${itemCategory}')">
                            <span class="action-icon"></span>
                            <span class="action-label">Edit Task</span>
                        </button>
                        <button class="task-action-btn fuckit" onclick="moveToFuckitBucket('${itemId}')">
                            <span class="action-icon"></span>
                            <span class="action-label">Fuck It - Not Doing This</span>
                            <span class="action-desc">Let it go guilt-free</span>
                        </button>
                        <button class="task-action-btn delete" onclick="deleteTaskFromMenu('${itemId}')">
                            <span class="action-icon"></span>
                            <span class="action-label">Delete</span>
                        </button>
                    </div>
                    <button class="cancel-btn" onclick="closeTaskActionMenu()">Cancel</button>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function closeTaskActionMenu() {
            document.getElementById('taskActionMenuModal')?.remove();
        }

        function editTaskFromMenu(itemId, itemText, itemCategory) {
            closeTaskActionMenu();
            showEditTaskModal(itemId, itemText, itemCategory);
        }

        async function moveToFuckitBucket(itemId) {
            const listId = lists['tasks'];
            if (!listId) return;

            try {
                await db.collection('lists').doc(listId).collection('items').doc(itemId).update({
                    category: 'fuckit',
                    done: false, // Reset done status
                    fuckitAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                closeTaskActionMenu();

                // Celebration message!
                const messages = [
                    " Freedom! You've released yourself from this task!",
                    " Into the bucket it goes! Zero guilt!",
                    " Letting go is a superpower. Well done!",
                    " One less thing to pretend you'll do!",
                    " Ahhhh... feel that weight lift off!",
                    " The Fuck It Bucket welcomes another!"
                ];
                const msg = messages[Math.floor(Math.random() * messages.length)];
                showToast(msg, 3000);

            } catch (error) {
                console.error('[Fuckit] Error:', error);
                showToast('Failed to move task');
            }
        }

        async function restoreFromFuckit(itemId) {
            const listId = lists['tasks'];
            if (!listId) return;

            try {
                await db.collection('lists').doc(listId).collection('items').doc(itemId).update({
                    category: 'other',
                    fuckitAt: null
                });
                showToast('Task restored! Back to work ');
            } catch (error) {
                console.error('[Restore] Error:', error);
                showToast('Failed to restore');
            }
        }

        async function deleteTaskFromMenu(itemId) {
            if (!confirm('Delete this task permanently?')) return;

            const listId = lists['tasks'];
            if (!listId) return;

            try {
                await db.collection('lists').doc(listId).collection('items').doc(itemId).delete();
                closeTaskActionMenu();
                showToast('Task deleted');
            } catch (error) {
                console.error('[Delete] Error:', error);
                showToast('Failed to delete');
            }
        }

        // =====================================================
        // EDIT TASK MODAL
        // =====================================================
        let currentEditingTaskId = null;

        function showEditTaskModal(itemId, itemText, itemCategory) {
            currentEditingTaskId = itemId;

            const modal = document.createElement('div');
            modal.className = 'edit-item-modal-overlay';
            modal.id = 'editTaskModal';
            modal.onclick = (e) => {
                if (e.target === modal) closeEditTaskModal();
            };

            const categoryOptions = TASK_CATEGORIES
                .filter(c => c.id !== 'fuckit')
                .map(c => `<option value="${c.id}" ${c.id === itemCategory ? 'selected' : ''}>${c.emoji} ${c.name}</option>`)
                .join('');

            modal.innerHTML = `
                <div class="edit-item-modal">
                    <div class="edit-modal-header">
                        <span class="edit-modal-icon"></span>
                        <h3>Edit Task</h3>
                    </div>
                    <div class="edit-modal-field">
                        <label>Task:</label>
                        <input type="text" id="editTaskText" value="${escapeHtml(itemText)}" />
                    </div>
                    <div class="edit-modal-field">
                        <label>Category:</label>
                        <select id="editTaskCategory">${categoryOptions}</select>
                    </div>
                    <div class="edit-modal-buttons">
                        <button class="edit-modal-cancel" onclick="closeEditTaskModal()">Cancel</button>
                        <button class="edit-modal-save" onclick="saveEditedTask()">Save</button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            setTimeout(() => {
                document.getElementById('editTaskText')?.focus();
                document.getElementById('editTaskText')?.select();
            }, 100);
        }

        function closeEditTaskModal() {
            document.getElementById('editTaskModal')?.remove();
            currentEditingTaskId = null;
        }

        async function saveEditedTask() {
            if (!currentEditingTaskId) return;

            const newText = document.getElementById('editTaskText').value.trim();
            const newCategory = document.getElementById('editTaskCategory').value;

            if (!newText) {
                showToast('Please enter a task');
                return;
            }

            const listId = lists['tasks'];
            if (!listId) return;

            try {
                await db.collection('lists').doc(listId).collection('items').doc(currentEditingTaskId).update({
                    text: newText,
                    category: newCategory
                });

                closeEditTaskModal();

                const cat = TASK_CATEGORIES.find(c => c.id === newCategory);
                showToast(` Updated! ${cat?.emoji || ''} ${cat?.name || 'Other'}`);

            } catch (error) {
                console.error('[Edit] Error:', error);
                showToast('Failed to save');
            }
        }

        // =====================================================
        // OLD TASK PROMPT (30+ days)
        // =====================================================
        function checkOldTasks(items) {
            const now = new Date();
            const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);

            // Find old incomplete tasks not in fuckit bucket
            const oldTasks = items.filter(item => {
                if (item.done || item.category === 'fuckit') return false;
                if (!item.createdAt) return false;
                const createdDate = item.createdAt.toDate ? item.createdAt.toDate() : new Date(item.createdAt);
                return createdDate < thirtyDaysAgo;
            });

            // Check if we've already prompted for these recently
            const prompted = JSON.parse(localStorage.getItem('oldTasksPrompted') || '{}');
            const today = new Date().toDateString();

            if (prompted.date === today) return; // Only prompt once per day

            // Find one task to prompt about
            const taskToPrompt = oldTasks.find(t => !prompted.ids?.includes(t.id));

            if (taskToPrompt) {
                const createdDate = taskToPrompt.createdAt.toDate ? taskToPrompt.createdAt.toDate() : new Date(taskToPrompt.createdAt);
                const daysOld = Math.floor((now - createdDate) / (1000 * 60 * 60 * 24));

                setTimeout(() => {
                    showOldTaskPrompt(taskToPrompt, daysOld);
                }, 2000); // Delay so it doesn't interrupt loading

                // Mark as prompted
                prompted.date = today;
                prompted.ids = [...(prompted.ids || []), taskToPrompt.id];
                localStorage.setItem('oldTasksPrompted', JSON.stringify(prompted));
            }
        }

        function showOldTaskPrompt(task, daysOld) {
            const modal = document.createElement('div');
            modal.className = 'old-task-prompt-overlay';
            modal.id = 'oldTaskPromptModal';
            modal.onclick = (e) => {
                if (e.target === modal) closeOldTaskPrompt();
            };

            modal.innerHTML = `
                <div class="old-task-prompt">
                    <div class="old-task-icon"></div>
                    <h3>Still happening?</h3>
                    <p class="old-task-text">"${escapeHtml(task.text)}"</p>
                    <p class="old-task-age">This task is <strong>${daysOld} days old</strong></p>
                    <div class="old-task-actions">
                        <button class="btn-keep" onclick="keepOldTask('${task.id}')">
                             Yes, I'll do it
                        </button>
                        <button class="btn-fuckit" onclick="fuckitOldTask('${task.id}')">
                             Fuck it, let it go
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function closeOldTaskPrompt() {
            document.getElementById('oldTaskPromptModal')?.remove();
        }

        function keepOldTask(itemId) {
            closeOldTaskPrompt();
            showToast("Alright, it stays! You've got this ");
        }

        async function fuckitOldTask(itemId) {
            closeOldTaskPrompt();
            await moveToFuckitBucket(itemId);
        }

        function showCategoryPicker(itemId, currentCat) {
            const modal = document.createElement('div');
            modal.className = 'category-picker-overlay';
            modal.id = 'categoryPickerModal';
            modal.onclick = (e) => { if (e.target === modal) closeCategoryPicker(); };
            modal.innerHTML = `
                <div class="category-picker-modal">
                    <h3>Move to category</h3>
                    <div class="category-options">
                        ${SHOPPING_CATEGORIES.map(c => `
                            <button class="category-option ${c.id === currentCat ? 'selected' : ''}"
                                    onclick="moveToCategory('${itemId}', '${c.id}')">
                                <span class="cat-emoji">${c.emoji}</span>
                                <span class="cat-name">${c.name}</span>
                                ${c.id === currentCat ? '<span class="check"></span>' : ''}
                            </button>
                        `).join('')}
                    </div>
                    <button class="cancel-btn" onclick="closeCategoryPicker()">Cancel</button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function closeCategoryPicker() {
            document.getElementById('categoryPickerModal')?.remove();
        }

        async function moveToCategory(itemId, newCategory) {
            const listId = lists['shopping'];
            if (!listId) return;

            try {
                const itemRef = db.collection('lists').doc(listId).collection('items').doc(itemId);
                const doc = await itemRef.get();

                if (doc.exists) {
                    const text = doc.data().text;
                    await itemRef.update({ category: newCategory });

                    // Save user preference for this item
                    userCategoryPrefs[text.toLowerCase()] = {
                        corrected: text,
                        category: newCategory
                    };
                    saveUserCategoryPrefs();

                    const cat = SHOPPING_CATEGORIES.find(c => c.id === newCategory);
                    showToast(`Moved to ${cat?.emoji} ${cat?.name}`, 1500);
                }
            } catch (error) {
                console.error('[Category] Move error:', error);
                showToast('Failed to move item');
            }

            closeCategoryPicker();
        }

        async function toggleItem(itemId, triggerConfetti = true) {
            const listId = lists[currentTab];
            if (!listId) return;

            const itemRef = db.collection('lists').doc(listId).collection('items').doc(itemId);

            try {
                const doc = await itemRef.get();
                if (doc.exists) {
                    const wasNotDone = !doc.data().done;
                    const willBeDone = wasNotDone;

                    // Find the card element (could be .item-card, .task-item, or .shopping-item)
                    const card = document.querySelector(`.item-card[data-id="${itemId}"]`) ||
                                 document.querySelector(`.task-item[data-id="${itemId}"]`) ||
                                 document.querySelector(`.shopping-item[data-id="${itemId}"]`);

                    if (willBeDone) {
                        // Item is being CHECKED - start fade out and schedule deletion
                        if (card) {
                            card.classList.add('completing-swipe');
                            setTimeout(() => card.classList.remove('completing-swipe'), 400);

                            // Trigger confetti celebration
                            if (triggerConfetti) {
                                const rect = card.getBoundingClientRect();
                                confetti(rect.left + rect.width / 2, rect.top + rect.height / 2);
                            }

                            // Start fade-out animation after a brief moment
                            setTimeout(() => {
                                if (card) card.classList.add('fading-out');
                            }, 500);
                        }

                        // Schedule auto-delete after 2 seconds
                        const timeoutId = setTimeout(async () => {
                            pendingDeletions.delete(itemId);
                            try {
                                await db.collection('lists').doc(listId).collection('items').doc(itemId).delete();
                            } catch (err) {
                                console.error('Error auto-deleting item:', err);
                            }
                        }, 2000); // 2s to match 1.5s animation

                        pendingDeletions.set(itemId, timeoutId);

                    } else {
                        // Item is being UNCHECKED - cancel pending deletion (rescue!)
                        if (pendingDeletions.has(itemId)) {
                            clearTimeout(pendingDeletions.get(itemId));
                            pendingDeletions.delete(itemId);
                        }

                        if (card) {
                            card.classList.remove('fading-out');
                        }
                    }

                    await itemRef.update({ done: willBeDone });
                }
            } catch (error) {
                console.error('Error toggling item:', error);
            }
        }

        async function deleteItem(itemId, animate = false) {
            const listId = lists[currentTab];
            if (!listId) return;

            if (animate) {
                const card = document.querySelector(`.item-card[data-id="${itemId}"]`);
                if (card) {
                    card.classList.add('deleting');
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }

            try {
                await db.collection('lists').doc(listId).collection('items').doc(itemId).delete();
            } catch (error) {
                console.error('Error deleting item:', error);
            }
        }

        // Cycle priority: none  high  medium  none
        async function cyclePriority(itemId) {
            const listId = lists[currentTab];
            if (!listId) return;

            const itemRef = db.collection('lists').doc(listId).collection('items').doc(itemId);

            try {
                const doc = await itemRef.get();
                if (doc.exists) {
                    const currentPriority = doc.data().priority || 'none';
                    let newPriority;

                    if (currentPriority === 'none') newPriority = 'high';
                    else if (currentPriority === 'high') newPriority = 'medium';
                    else newPriority = 'none';

                    await itemRef.update({ priority: newPriority });

                    // Haptic feedback
                    if (navigator.vibrate) navigator.vibrate(20);
                }
            } catch (error) {
                console.error('Error cycling priority:', error);
            }
        }

        // Clear all completed items
        async function clearCompletedItems() {
            const listId = lists[currentTab];
            if (!listId) return;

            const count = completedCounts[currentTab];
            if (count === 0) return;

            if (!confirm(`Clear ${count} completed item${count !== 1 ? 's' : ''}?`)) {
                return;
            }

            try {
                const itemsRef = db.collection('lists').doc(listId).collection('items');
                const snapshot = await itemsRef.where('done', '==', true).get();

                const batch = db.batch();
                snapshot.forEach(doc => batch.delete(doc.ref));
                await batch.commit();

                showToast(`Cleared ${count} item${count !== 1 ? 's' : ''}`);
            } catch (error) {
                console.error('Error clearing completed:', error);
                showToast('Error clearing items');
            }
        }

        // Clear completed from both lists (profile action)
        async function clearAllCompleted() {
            let totalCleared = 0;

            for (const type of ['tasks', 'shopping']) {
                const listId = lists[type];
                if (!listId) continue;

                try {
                    const itemsRef = db.collection('lists').doc(listId).collection('items');
                    const snapshot = await itemsRef.where('done', '==', true).get();

                    if (!snapshot.empty) {
                        const batch = db.batch();
                        snapshot.forEach(doc => batch.delete(doc.ref));
                        await batch.commit();
                        totalCleared += snapshot.size;
                    }
                } catch (error) {
                    console.error(`Error clearing ${type}:`, error);
                }
            }

            if (totalCleared > 0) {
                showToast(`Cleared ${totalCleared} item${totalCleared !== 1 ? 's' : ''}`);
            } else {
                showToast('No completed items to clear');
            }
        }

        // =====================================================
        // CONFETTI CELEBRATION
        // =====================================================
        function confetti(x, y) {
            const colors = ['#8b5cf6', '#ec4899', '#f97316', '#14b8a6', '#eab308'];
            const particleCount = 18;

            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'confetti-particle';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.setProperty('--x', (Math.random() - 0.5) * 200 + 'px');
                particle.style.setProperty('--y', (Math.random() * -100 - 50) + 'px');
                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 800);
            }
        }

        // =====================================================
        // SWIPE GESTURES
        // =====================================================
        function initSwipeHandlers() {
            const itemList = document.getElementById('itemList');
            const cards = itemList.querySelectorAll('.item-card');

            cards.forEach(card => {
                let startX = 0;
                let currentX = 0;
                let isDragging = false;
                const threshold = 0.4; // 40% of card width

                const handleStart = (clientX) => {
                    startX = clientX;
                    currentX = clientX;
                    isDragging = true;
                    card.classList.add('swiping');
                    card.classList.remove('snapping');
                };

                const handleMove = (clientX) => {
                    if (!isDragging) return;
                    currentX = clientX;
                    const deltaX = currentX - startX;
                    card.style.transform = `translateX(${deltaX}px)`;
                };

                const handleEnd = async () => {
                    if (!isDragging) return;
                    isDragging = false;
                    card.classList.remove('swiping');

                    const deltaX = currentX - startX;
                    const cardWidth = card.offsetWidth;
                    const itemId = card.dataset.id;

                    // Swipe right (complete)
                    if (deltaX > cardWidth * threshold) {
                        card.classList.add('snapping');
                        card.style.transform = 'translateX(0)';
                        await toggleItem(itemId, true);
                    }
                    // Swipe left (delete)
                    else if (deltaX < -cardWidth * threshold) {
                        await deleteItem(itemId, true);
                    }
                    // Snap back
                    else {
                        card.classList.add('snapping');
                        card.style.transform = 'translateX(0)';
                    }
                };

                // Touch events
                card.addEventListener('touchstart', (e) => {
                    handleStart(e.touches[0].clientX);
                }, { passive: true });

                card.addEventListener('touchmove', (e) => {
                    handleMove(e.touches[0].clientX);
                }, { passive: true });

                card.addEventListener('touchend', handleEnd);

                // Mouse events (desktop fallback)
                card.addEventListener('mousedown', (e) => {
                    if (e.target.closest('[data-action]')) return; // Ignore button clicks
                    handleStart(e.clientX);
                });

                card.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        handleMove(e.clientX);
                    }
                });

                card.addEventListener('mouseup', handleEnd);
                card.addEventListener('mouseleave', () => {
                    if (isDragging) {
                        isDragging = false;
                        card.classList.remove('swiping');
                        card.classList.add('snapping');
                        card.style.transform = 'translateX(0)';
                    }
                });
            });
        }

        // =====================================================
        // PULL TO REFRESH
        // =====================================================
        let pullStartY = 0;
        let isPulling = false;
        let pullIndicator;

        function initPullToRefresh() {
            const content = document.getElementById('listContent');
            pullIndicator = document.getElementById('pullIndicator');

            content.addEventListener('touchstart', (e) => {
                if (content.scrollTop === 0) {
                    pullStartY = e.touches[0].clientY;
                    isPulling = true;
                }
            }, { passive: true });

            content.addEventListener('touchmove', (e) => {
                if (!isPulling) return;
                const deltaY = e.touches[0].clientY - pullStartY;

                if (deltaY > 0 && deltaY < 180) {
                    pullIndicator.style.height = Math.min(deltaY * 0.5, 70) + 'px';
                    pullIndicator.style.opacity = Math.min(deltaY / 120, 1);
                }
            }, { passive: true });

            content.addEventListener('touchend', async () => {
                if (!isPulling) return;

                // Increased threshold to 120px to prevent accidental triggers
                const pullDistance = parseInt(pullIndicator.style.height) || 0;
                if (pullDistance > 60) { // 60px visible = 120px pull
                    // Show refreshing state
                    pullIndicator.classList.add('refreshing');
                    pullIndicator.style.height = '50px';
                    pullIndicator.style.opacity = '1';

                    // Refresh data (re-subscribe to items)
                    await new Promise(resolve => setTimeout(resolve, 300)); // Min feedback time
                    subscribeToItems();

                    // Hide after a moment
                    setTimeout(() => {
                        pullIndicator.classList.remove('refreshing');
                        pullIndicator.style.height = '0';
                        pullIndicator.style.opacity = '0';
                    }, 500);
                } else {
                    pullIndicator.style.height = '0';
                    pullIndicator.style.opacity = '0';
                }

                isPulling = false;
            });
        }

        // =====================================================
        // COLLABORATORS
        // =====================================================
        function renderCollaborators(data) {
            const collaborators = SharingModule.getCollaborators(data);
            const isOwner = SharingModule.isOwner(data);

            // Show/hide invite section
            inviteSection.style.display = isOwner ? 'block' : 'none';

            let html = '';

            // Show owner if not the owner
            if (!isOwner && data.ownerEmail) {
                const initial = data.ownerEmail[0].toUpperCase();
                html += `
                    <li class="collaborator-item">
                        <div class="collaborator-info">
                            <div class="collaborator-avatar">${escapeHtml(initial)}</div>
                            <div>
                                <div class="collaborator-email">${escapeHtml(data.ownerEmail)}</div>
                                <div class="collaborator-role">Owner</div>
                            </div>
                        </div>
                        <span class="owner-badge">Owner</span>
                    </li>
                `;
            }

            if (collaborators.length === 0 && isOwner) {
                collaboratorList.innerHTML = '<li class="no-collaborators">No collaborators yet</li>';
                return;
            }

            html += collaborators.map(collab => {
                const initial = (collab.email || '?')[0].toUpperCase();
                const removeBtn = isOwner
                    ? `<button class="remove-collaborator" data-id="${collab.id}">Remove</button>`
                    : '';

                return `
                    <li class="collaborator-item">
                        <div class="collaborator-info">
                            <div class="collaborator-avatar">${escapeHtml(initial)}</div>
                            <div>
                                <div class="collaborator-email">${escapeHtml(collab.email || 'Unknown')}</div>
                                <div class="collaborator-role">Collaborator</div>
                            </div>
                        </div>
                        ${removeBtn}
                    </li>
                `;
            }).join('');

            collaboratorList.innerHTML = html || '<li class="no-collaborators">No collaborators</li>';
        }

        function showShareMessage(message, type) {
            shareMessage.textContent = message;
            shareMessage.className = `share-message ${type}`;
            setTimeout(() => {
                shareMessage.className = 'share-message';
            }, 4000);
        }

        // =====================================================
        // AUTH EVENT LISTENERS
        // =====================================================
        document.querySelectorAll('.auth-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.auth-form').forEach(f => f.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab + 'Form').classList.add('active');
                authError.classList.remove('show');
            });
        });

        document.getElementById('loginBtn').addEventListener('click', async () => {
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;

            if (!email || !password) {
                showError('Please enter email and password');
                return;
            }

            try {
                await auth.signInWithEmailAndPassword(email, password);
            } catch (error) {
                showError(error.message);
            }
        });

        document.getElementById('signupBtn').addEventListener('click', async () => {
            const email = document.getElementById('signupEmail').value.trim();
            const password = document.getElementById('signupPassword').value;

            if (!email || !password) {
                showError('Please enter email and password');
                return;
            }

            if (password.length < 6) {
                showError('Password must be at least 6 characters');
                return;
            }

            try {
                await auth.createUserWithEmailAndPassword(email, password);
            } catch (error) {
                showError(error.message);
            }
        });

        document.getElementById('googleBtn').addEventListener('click', async () => {
            const provider = new firebase.auth.GoogleAuthProvider();
            try {
                await auth.signInWithPopup(provider);
            } catch (error) {
                showError(error.message);
            }
        });

        document.getElementById('logoutBtn').addEventListener('click', () => {
            auth.signOut();
        });

        document.getElementById('loginPassword').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') document.getElementById('loginBtn').click();
        });

        document.getElementById('signupPassword').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') document.getElementById('signupBtn').click();
        });

        // =====================================================
        // AUTH STATE OBSERVER
        // =====================================================
        auth.onAuthStateChanged(async (user) => {
            currentUser = user;

            if (user) {
                authContainer.style.display = 'none';
                appContainer.classList.add('active');

                await SharingModule.saveUserProfile(user);

                // Load user profile and check onboarding status
                const onboardingComplete = await loadUserProfile();
                updateProfileUI();

                // Show onboarding for new users
                if (!onboardingComplete) {
                    console.log('[Onboarding] New user detected, showing onboarding');
                    showOnboarding();
                }

                // Run one-time migration to merge duplicate shopping lists
                await migrateShoppingLists();

                await initializeLists();

                // Initialize delight features
                initPullToRefresh();
                initOnboarding();
                initProfileHandlers();

                switchTab('tasks');
            } else {
                authContainer.style.display = 'block';
                appContainer.classList.remove('active');
                hideOnboarding();
                lists = { tasks: null, shopping: null };
                listData = { tasks: null, shopping: null };
                currentTab = 'tasks';

                // Reset profile
                userProfile = {
                    displayName: '',
                    avatar: '&#128512;',
                    personality: 'subtle'
                };

                if (unsubscribeItems) {
                    unsubscribeItems();
                    unsubscribeItems = null;
                }
                if (unsubscribeList) {
                    unsubscribeList();
                    unsubscribeList = null;
                }
            }
        });

        // =====================================================
        // NAV EVENT LISTENERS
        // =====================================================
        document.querySelectorAll('.nav-item').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });

        // =====================================================
        // ITEM EVENT LISTENERS
        // =====================================================
        document.getElementById('addBtn').addEventListener('click', addItem);

        itemInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addItem();
        });

        document.getElementById('itemList').addEventListener('click', (e) => {
            // Handle clear completed button
            if (e.target.closest('#clearCompletedBtn')) {
                clearCompletedItems();
                return;
            }

            // Handle flat list (.item-card), shopping (.shopping-item), and tasks (.task-item)
            const card = e.target.closest('.item-card') || e.target.closest('.shopping-item') || e.target.closest('.task-item');
            if (!card) return;

            const itemId = card.dataset.id;
            const action = e.target.closest('[data-action]')?.dataset.action;

            if (action === 'delete') {
                deleteItem(itemId, true); // Animate deletion
            } else if (action === 'priority') {
                cyclePriority(itemId); // Cycle priority
            } else if (action === 'toggle' || e.target.closest('.item-content') || e.target.closest('.item-checkbox')) {
                toggleItem(itemId, true); // Trigger confetti
            }
        });

        // =====================================================
        // SHARE MODAL EVENT LISTENERS
        // =====================================================
        shareBtn.addEventListener('click', () => {
            const data = listData[currentTab];
            if (data) {
                renderCollaborators(data);
            }
            shareModal.classList.add('active');
            inviteEmail.value = '';
            shareMessage.className = 'share-message';
        });

        document.getElementById('manageSharingBtn').addEventListener('click', () => {
            // Switch to tasks tab and open share modal
            switchTab('tasks');
            setTimeout(() => {
                const data = listData[currentTab];
                if (data) {
                    renderCollaborators(data);
                }
                shareModal.classList.add('active');
            }, 100);
        });

        document.getElementById('clearAllCompletedBtn').addEventListener('click', async () => {
            if (!confirm('Clear all completed items from both Tasks and Shopping lists?')) {
                return;
            }
            await clearAllCompleted();
        });

        modalClose.addEventListener('click', () => {
            shareModal.classList.remove('active');
        });

        shareModal.addEventListener('click', (e) => {
            if (e.target === shareModal) {
                shareModal.classList.remove('active');
            }
        });

        inviteBtn.addEventListener('click', async () => {
            const email = inviteEmail.value.trim().toLowerCase();

            if (!email) {
                showShareMessage('Please enter an email address.', 'error');
                return;
            }

            if (!email.includes('@') || !email.includes('.')) {
                showShareMessage('Please enter a valid email.', 'error');
                return;
            }

            const listId = lists[currentTab];
            if (!listId) return;

            inviteBtn.disabled = true;
            inviteBtn.textContent = '...';

            try {
                const collaborator = await SharingModule.addCollaborator(listId, email);
                showShareMessage(`Shared with ${collaborator.email}!`, 'success');
                inviteEmail.value = '';

                const data = listData[currentTab];
                if (data) renderCollaborators(data);
            } catch (error) {
                showShareMessage(error.message, 'error');
            } finally {
                inviteBtn.disabled = false;
                inviteBtn.textContent = 'Invite';
            }
        });

        inviteEmail.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') inviteBtn.click();
        });

        collaboratorList.addEventListener('click', async (e) => {
            const removeBtn = e.target.closest('.remove-collaborator');
            if (!removeBtn) return;

            const collaboratorId = removeBtn.dataset.id;
            const listId = lists[currentTab];

            if (!listId || !collaboratorId) return;

            removeBtn.disabled = true;
            removeBtn.textContent = '...';

            try {
                await SharingModule.removeCollaborator(listId, collaboratorId);
                showShareMessage('Collaborator removed.', 'success');
            } catch (error) {
                showShareMessage(error.message, 'error');
                removeBtn.disabled = false;
                removeBtn.textContent = 'Remove';
            }
        });
    </script>
</body>
</html>
